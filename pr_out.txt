let atleast_2d = { lambda ; a:f64[3]. let
    b:f64[1,3] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 3)
      sharding=None
    ] a
  in (b,) } in
let _where = { lambda ; c:bool[1] d:f64[] e:f64[1]. let
    f:f64[] = convert_element_type[new_dtype=float64 weak_type=False] d
    g:f64[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] f
    h:f64[1] = select_n c e g
  in (h,) } in
let atleast_2d1 = { lambda ; i:f64[1]. let
    j:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] i
  in (j,) } in
let zernike_radial = { lambda ; k:f64[1,1] l:i64[25] m:i64[25]. let
    n:i64[25] = abs m
    o:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] n
    p:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] l
    q:f64[25] = sub p o
    r:f64[25] = pjit[
      name=floor_divide
      jaxpr={ lambda ; q:f64[25] s:i64[]. let
          t:f64[] = convert_element_type[new_dtype=float64 weak_type=False] s
          u:f64[25] = rem q t
          v:f64[25] = sub q u
          w:f64[25] = div v t
          x:bool[25] = ne u 0.0:f64[]
          y:f64[] = sign t
          z:f64[25] = sign u
          ba:bool[25] = ne y z
          bb:bool[25] = and x ba
          bc:f64[25] = add u t
          _:f64[25] = select_n bb u bc
          bd:f64[25] = sub w 1.0:f64[]
          be:f64[25] = select_n bb w bd
          r:f64[25] = round[rounding_method=0] be
        in (r,) }
    ] q 2:i64[]
    bf:f64[25] = pow -1.0:f64[] r
    bg:f64[1,1] = integer_pow[y=2] k
    bh:f64[1,1] = mul 2.0:f64[] bg
    bi:f64[1,1] = sub 1.0:f64[] bh
    bj:f64[1,25] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 25)
      sharding=None
    ] o
    bk:f64[1,25] = pow k bj
    bl:f64[1,25] = custom_jvp_call[
      name=_jacobi
      call_jaxpr={ lambda ; bm:f64[25] bn:f64[25] bo:i64[] bp:f64[1,1]. let
          bq:f64[1,25] = pjit[
            name=_jacobi
            jaxpr={ lambda ; bm:f64[25] bn:f64[25] bo:i64[] bp:f64[1,1] br:i64[]. let
                bs:f64[] = squeeze[dimensions=(0, 1)] bp
                bt:f64[25] = add bn bm
                bu:f64[25] = add bt 1.0:f64[]
                bv:f64[25] = div bu 2.0:f64[]
                bw:f64[25] = add bn bm
                bx:f64[25] = add bw 2.0:f64[]
                by:f64[25] = add bn bm
                bz:f64[25] = add by 1.0:f64[]
                ca:f64[25] = mul bx bz
                cb:f64[25] = div ca 4.0:f64[]
                cc:f64[25] = add bn bm
                cd:f64[25] = add cc 3.0:f64[]
                ce:f64[25] = add bn bm
                cf:f64[25] = add ce 2.0:f64[]
                cg:f64[25] = mul cd cf
                ch:f64[25] = add bn bm
                ci:f64[25] = add ch 1.0:f64[]
                cj:f64[25] = mul cg ci
                ck:f64[25] = div cj 8.0:f64[]
                cl:f64[25] = add bn bm
                cm:f64[25] = add cl 4.0:f64[]
                cn:f64[25] = add bn bm
                co:f64[25] = add cn 3.0:f64[]
                cp:f64[25] = mul cm co
                cq:f64[25] = add bn bm
                cr:f64[25] = add cq 2.0:f64[]
                cs:f64[25] = mul cp cr
                ct:f64[25] = add bn bm
                cu:f64[25] = add ct 1.0:f64[]
                cv:f64[25] = mul cs cu
                cw:f64[25] = div cv 16.0:f64[]
                cx:f64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] 1.0:f64[]
                cy:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] bv
                cz:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] cb
                da:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] ck
                db:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] cw
                dc:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(25, 1)
                  sharding=None
                ] cx
                dd:f64[25,5] = concatenate[dimension=1] dc cy cz da db
                de:bool[] = lt br 0:i64[]
                df:i64[] = convert_element_type[new_dtype=int64 weak_type=False] br
                dg:i64[] = add df 5:i64[]
                dh:i64[] = select_n de br dg
                di:i64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] dh
                dj:f64[25,1] = gather[
                  dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
                  fill_value=None
                  indices_are_sorted=True
                  mode=GatherScatterMode.PROMISE_IN_BOUNDS
                  slice_sizes=(25, 1)
                  unique_indices=True
                ] dd di
                dk:f64[25] = squeeze[dimensions=(1,)] dj
                dl:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] br
                dm:f64[25] = sub bm dl
                dn:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] br
                do:f64[25] = add bn dn
                dp:i64[] = add bo br
                dq:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] dp
                dr:f64[25] = add do dq
                ds:f64[25] = add dr 2.0:f64[]
                dt:f64[] = sub bs 1.0:f64[]
                du:f64[25] = mul ds dt
                dv:f64[25] = add do 1.0:f64[]
                dw:f64[25] = mul 2.0:f64[] dv
                dx:f64[25] = div du dw
                dy:f64[25] = add dx 1.0:f64[]
                dz:f64[25] = sub dm 1.0:f64[]
                ea:f64[25] = max dz 0.0:f64[]
                eb:i64[25] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] ea
                ec:i64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] 0:i64[]
                _:i64[25] _:i64[25] _:f64[25] ed:f64[25] = while[
                  body_jaxpr={ lambda ; ee:f64[25] ef:i64[] eg:f64[] eh:i64[25] ei:i64[25]
                      ej:f64[25] ek:f64[25]. let
                      el:i64[25] = add eh 1:i64[]
                      em:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] eh
                      en:f64[25] = add em 1.0:f64[]
                      eo:f64[25] = mul 2.0:f64[] en
                      ep:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] eo
                      eq:f64[25] = add ep ee
                      er:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] ef
                      es:f64[25] = add eq er
                      et:f64[25] = add es 1.0:f64[]
                      eu:f64[25] = mul es et
                      ev:f64[25] = add es 2.0:f64[]
                      ew:f64[25] = mul eu ev
                      ex:f64[] = sub eg 1.0:f64[]
                      ey:f64[25] = mul ew ex
                      ez:f64[25] = mul ey ek
                      fa:f64[25] = mul 2.0:f64[] en
                      fb:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] ef
                      fc:f64[25] = add en fb
                      fd:f64[25] = mul fa fc
                      fe:f64[25] = add es 2.0:f64[]
                      ff:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] fd
                      fg:f64[25] = mul ff fe
                      fh:f64[25] = mul fg ej
                      fi:f64[25] = add ez fh
                      fj:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] en
                      fk:f64[25] = add fj ee
                      fl:f64[25] = add fk 1.0:f64[]
                      fm:f64[25] = mul 2.0:f64[] fl
                      fn:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] en
                      fo:f64[25] = add fn ee
                      fp:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] ef
                      fq:f64[25] = add fo fp
                      fr:f64[25] = add fq 1.0:f64[]
                      fs:f64[25] = mul fm fr
                      ft:f64[25] = mul fs es
                      fu:f64[25] = div fi ft
                      fv:f64[25] = add fu ek
                    in (el, ei, fu, fv) }
                  body_nconsts=3
                  cond_jaxpr={ lambda ; fw:i64[25] fx:i64[25] fy:f64[25] fz:f64[25]. let
                      ga:bool[25] = lt fw fx
                    in (ga,) }
                  cond_nconsts=0
                ] do dp bs ec eb dx dy
                gb:f64[25] = add dm do
                gc:f64[25] = pjit[
                  name=_binom
                  jaxpr={ lambda ; gb:f64[25] dm:f64[25]. let
                      gd:i64[25] = convert_element_type[
                        new_dtype=int64
                        weak_type=False
                      ] dm
                      ge:i64[25] = add 1:i64[] gd
                      gf:i64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] 1:i64[]
                      gg:f64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] 1.0:f64[]
                      _:i64[25] _:i64[25] gc:f64[25] = while[
                        body_jaxpr={ lambda ; gh:f64[25] gi:i64[25] gj:i64[25] gk:f64[25]. let
                            gl:i64[25] = add gi 1:i64[]
                            gm:f64[25] = add gh 1.0:f64[]
                            gn:f64[25] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] gi
                            go:f64[25] = sub gm gn
                            gp:f64[25] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] gk
                            gq:f64[25] = mul gp go
                            gr:f64[25] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] gi
                            gs:f64[25] = div gq gr
                          in (gl, gj, gs) }
                        body_nconsts=1
                        cond_jaxpr={ lambda ; gt:i64[25] gu:i64[25] gv:f64[25]. let
                            gw:bool[25] = lt gt gu
                          in (gw,) }
                        cond_nconsts=0
                      ] gb gf ge gg
                    in (gc,) }
                ] gb dm
                gx:f64[25] = mul gc ed
                gy:bool[25] = lt dm 0.0:f64[]
                gz:f64[25] = pjit[
                  name=_where
                  jaxpr={ lambda ; gy:bool[25] ha:i64[] gx:f64[25]. let
                      hb:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] ha
                      hc:f64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] hb
                      gz:f64[25] = select_n gy gx hc
                    in (gz,) }
                ] gy 0:i64[] gx
                hd:bool[25] = eq dm 0.0:f64[]
                he:f64[25] = pjit[
                  name=_where
                  jaxpr={ lambda ; hd:bool[25] hf:f64[] gz:f64[25]. let
                      hg:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] hf
                      hh:f64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] hg
                      he:f64[25] = select_n hd gz hh
                    in (he,) }
                ] hd 1.0:f64[] gz
                hi:bool[25] = eq dm 1.0:f64[]
                hj:f64[25] = add do 1.0:f64[]
                hk:f64[25] = mul 2.0:f64[] hj
                hl:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] dp
                hm:f64[25] = add do hl
                hn:f64[25] = add hm 2.0:f64[]
                ho:f64[] = sub bs 1.0:f64[]
                hp:f64[25] = mul hn ho
                hq:f64[25] = add hk hp
                hr:f64[25] = mul 0.5:f64[] hq
                hs:f64[25] = pjit[
                  name=_where
                  jaxpr={ lambda ; hi:bool[25] hr:f64[25] he:f64[25]. let
                      hs:f64[25] = select_n hi he hr
                    in (hs,) }
                ] hi hr he
                ht:f64[25] = mul dk hs
                bq:f64[1,25] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 25)
                  sharding=None
                ] ht
              in (bq,) }
          ] bm bn bo bp 0:i64[]
        in (bq,) }
      jvp=_jacobi_jvp
      symbolic_zeros=False
    ] r o 0:i64[] bi
    hu:f64[1,25] = mul bk bl
    hv:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] l
    hw:f64[25] = sub hv o
    hx:f64[25] = pjit[
      name=remainder
      jaxpr={ lambda ; hw:f64[25] hy:i64[]. let
          hz:f64[] = convert_element_type[new_dtype=float64 weak_type=False] hy
          ia:f64[25] = rem hw hz
          ib:bool[25] = ne ia 0.0:f64[]
          ic:bool[25] = lt ia 0.0:f64[]
          id:bool[] = lt hz 0.0:f64[]
          ie:bool[25] = ne ic id
          if:bool[25] = and ie ib
          ig:f64[25] = add ia hz
          hx:f64[25] = select_n if ia ig
        in (hx,) }
    ] hw 2:i64[]
    ih:bool[25] = eq hx 0.0:f64[]
    ii:f64[1,25] = pjit[
      name=_where
      jaxpr={ lambda ; ih:bool[25] hu:f64[1,25] ij:f64[]. let
          ik:f64[] = convert_element_type[new_dtype=float64 weak_type=False] ij
          il:bool[1,25] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 25)
            sharding=None
          ] ih
          im:f64[1,25] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1, 25)
            sharding=None
          ] ik
          ii:f64[1,25] = select_n il im hu
        in (ii,) }
    ] ih hu 0.0:f64[]
    in:f64[1,25] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 25)
      sharding=None
    ] bf
    io:f64[1,25] = mul in ii
  in (io,) } in
let fourier = { lambda ; ip:f64[1,1] iq:i64[9] ir:i64[]. let
    is:bool[9] = ge iq 0:i64[]
    it:i64[9] = convert_element_type[new_dtype=int64 weak_type=False] is
    iu:i64[9] = abs iq
    iv:i64[9] = mul iu 1:i64[]
    iw:f64[9] = convert_element_type[new_dtype=float64 weak_type=True] it
    ix:f64[9] = mul iw 3.141592653589793:f64[]
    iy:f64[9] = div ix 2.0:f64[]
    iz:f64[] = convert_element_type[new_dtype=float64 weak_type=True] ir
    ja:f64[] = mul iz 3.141592653589793:f64[]
    jb:f64[] = div ja 2.0:f64[]
    jc:f64[9] = add iy jb
    jd:bool[9] = eq iv 0:i64[]
    je:bool[] = ne ir 0:i64[]
    jf:bool[9] = and jd je
    jg:i64[9] = pjit[
      name=_where
      jaxpr={ lambda ; jf:bool[9] jh:i64[] ji:i64[]. let
          jj:i64[9] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(9,)
            sharding=None
          ] jh
          jk:i64[9] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(9,)
            sharding=None
          ] ji
          jg:i64[9] = select_n jf jk jj
        in (jg,) }
    ] jf 0:i64[] 1:i64[]
    jl:i64[] = and ir 1:i64[]
    jm:i64[9] = mul jg iv
    jn:i64[9] = pjit[
      name=_where
      jaxpr={ lambda ; jl:i64[] jm:i64[9] jg:i64[9]. let
          jo:bool[] = ne jl 0:i64[]
          jn:i64[9] = select_n jo jg jm
        in (jn,) }
    ] jl jm jg
    jp:i64[9] = mul iv iv
    jq:i64[] = shift_right_logical ir 1:i64[]
    jr:i64[] = and jq 1:i64[]
    js:i64[9] = mul jn jp
    jt:i64[9] = pjit[
      name=_where
      jaxpr={ lambda ; jl:i64[] jm:i64[9] jg:i64[9]. let
          jo:bool[] = ne jl 0:i64[]
          jn:i64[9] = select_n jo jg jm
        in (jn,) }
    ] jr js jn
    ju:i64[9] = mul jp jp
    jv:i64[] = shift_right_logical jq 1:i64[]
    jw:i64[] = and jv 1:i64[]
    jx:i64[9] = mul jt ju
    jy:i64[9] = pjit[
      name=_where
      jaxpr={ lambda ; jl:i64[] jm:i64[9] jg:i64[9]. let
          jo:bool[] = ne jl 0:i64[]
          jn:i64[9] = select_n jo jg jm
        in (jn,) }
    ] jw jx jt
    jz:i64[9] = mul ju ju
    ka:i64[] = shift_right_logical jv 1:i64[]
    kb:i64[] = and ka 1:i64[]
    kc:i64[9] = mul jy jz
    kd:i64[9] = pjit[
      name=_where
      jaxpr={ lambda ; jl:i64[] jm:i64[9] jg:i64[9]. let
          jo:bool[] = ne jl 0:i64[]
          jn:i64[9] = select_n jo jg jm
        in (jn,) }
    ] kb kc jy
    ke:i64[9] = mul jz jz
    kf:i64[] = shift_right_logical ka 1:i64[]
    kg:i64[] = and kf 1:i64[]
    kh:i64[9] = mul kd ke
    ki:i64[9] = pjit[
      name=_where
      jaxpr={ lambda ; jl:i64[] jm:i64[9] jg:i64[9]. let
          jo:bool[] = ne jl 0:i64[]
          jn:i64[9] = select_n jo jg jm
        in (jn,) }
    ] kg kh kd
    kj:i64[9] = mul ke ke
    kk:i64[] = shift_right_logical kf 1:i64[]
    kl:i64[] = and kk 1:i64[]
    km:i64[9] = mul ki kj
    kn:i64[9] = pjit[
      name=_where
      jaxpr={ lambda ; jl:i64[] jm:i64[9] jg:i64[9]. let
          jo:bool[] = ne jl 0:i64[]
          jn:i64[9] = select_n jo jg jm
        in (jn,) }
    ] kl km ki
    _:i64[9] = mul kj kj
    _:i64[] = shift_right_logical kk 1:i64[]
    ko:f64[9] = convert_element_type[new_dtype=float64 weak_type=False] iv
    kp:f64[1,9] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 9)
      sharding=None
    ] ko
    kq:f64[1,9] = mul kp ip
    kr:f64[9] = convert_element_type[new_dtype=float64 weak_type=False] jc
    ks:f64[1,9] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 9)
      sharding=None
    ] kr
    kt:f64[1,9] = add kq ks
    ku:f64[1,9] = sin kt
    kv:f64[9] = convert_element_type[new_dtype=float64 weak_type=False] kn
    kw:f64[1,9] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 9)
      sharding=None
    ] kv
    kx:f64[1,9] = mul kw ku
  in (kx,) } in
let fourier1 = { lambda ; ky:f64[1,1] kz:i64[1] la:i64[] lb:i64[]. let
    lc:bool[1] = ge kz 0:i64[]
    ld:i64[1] = convert_element_type[new_dtype=int64 weak_type=False] lc
    le:i64[1] = abs kz
    lf:i64[] = convert_element_type[new_dtype=int64 weak_type=False] la
    lg:i64[1] = mul le lf
    lh:f64[1] = convert_element_type[new_dtype=float64 weak_type=True] ld
    li:f64[1] = mul lh 3.141592653589793:f64[]
    lj:f64[1] = div li 2.0:f64[]
    lk:f64[] = convert_element_type[new_dtype=float64 weak_type=True] lb
    ll:f64[] = mul lk 3.141592653589793:f64[]
    lm:f64[] = div ll 2.0:f64[]
    ln:f64[1] = add lj lm
    lo:bool[1] = eq lg 0:i64[]
    lp:bool[] = ne lb 0:i64[]
    lq:bool[1] = and lo lp
    lr:i64[1] = pjit[
      name=_where
      jaxpr={ lambda ; lq:bool[1] ls:i64[] lt:i64[]. let
          lu:i64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] ls
          lv:i64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] lt
          lr:i64[1] = select_n lq lv lu
        in (lr,) }
    ] lq 0:i64[] 1:i64[]
    lw:i64[] = and lb 1:i64[]
    lx:i64[1] = mul lr lg
    ly:i64[1] = pjit[
      name=_where
      jaxpr={ lambda ; lw:i64[] lx:i64[1] lr:i64[1]. let
          lz:bool[] = ne lw 0:i64[]
          ly:i64[1] = select_n lz lr lx
        in (ly,) }
    ] lw lx lr
    ma:i64[1] = mul lg lg
    mb:i64[] = shift_right_logical lb 1:i64[]
    mc:i64[] = and mb 1:i64[]
    md:i64[1] = mul ly ma
    me:i64[1] = pjit[
      name=_where
      jaxpr={ lambda ; lw:i64[] lx:i64[1] lr:i64[1]. let
          lz:bool[] = ne lw 0:i64[]
          ly:i64[1] = select_n lz lr lx
        in (ly,) }
    ] mc md ly
    mf:i64[1] = mul ma ma
    mg:i64[] = shift_right_logical mb 1:i64[]
    mh:i64[] = and mg 1:i64[]
    mi:i64[1] = mul me mf
    mj:i64[1] = pjit[
      name=_where
      jaxpr={ lambda ; lw:i64[] lx:i64[1] lr:i64[1]. let
          lz:bool[] = ne lw 0:i64[]
          ly:i64[1] = select_n lz lr lx
        in (ly,) }
    ] mh mi me
    mk:i64[1] = mul mf mf
    ml:i64[] = shift_right_logical mg 1:i64[]
    mm:i64[] = and ml 1:i64[]
    mn:i64[1] = mul mj mk
    mo:i64[1] = pjit[
      name=_where
      jaxpr={ lambda ; lw:i64[] lx:i64[1] lr:i64[1]. let
          lz:bool[] = ne lw 0:i64[]
          ly:i64[1] = select_n lz lr lx
        in (ly,) }
    ] mm mn mj
    mp:i64[1] = mul mk mk
    mq:i64[] = shift_right_logical ml 1:i64[]
    mr:i64[] = and mq 1:i64[]
    ms:i64[1] = mul mo mp
    mt:i64[1] = pjit[
      name=_where
      jaxpr={ lambda ; lw:i64[] lx:i64[1] lr:i64[1]. let
          lz:bool[] = ne lw 0:i64[]
          ly:i64[1] = select_n lz lr lx
        in (ly,) }
    ] mr ms mo
    mu:i64[1] = mul mp mp
    mv:i64[] = shift_right_logical mq 1:i64[]
    mw:i64[] = and mv 1:i64[]
    mx:i64[1] = mul mt mu
    my:i64[1] = pjit[
      name=_where
      jaxpr={ lambda ; lw:i64[] lx:i64[1] lr:i64[1]. let
          lz:bool[] = ne lw 0:i64[]
          ly:i64[1] = select_n lz lr lx
        in (ly,) }
    ] mw mx mt
    _:i64[1] = mul mu mu
    _:i64[] = shift_right_logical mv 1:i64[]
    mz:f64[1] = convert_element_type[new_dtype=float64 weak_type=False] lg
    na:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] mz
    nb:f64[1,1] = mul na ky
    nc:f64[1] = convert_element_type[new_dtype=float64 weak_type=False] ln
    nd:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] nc
    ne:f64[1,1] = add nb nd
    nf:f64[1,1] = sin ne
    ng:f64[1] = convert_element_type[new_dtype=float64 weak_type=False] my
    nh:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] ng
    ni:f64[1,1] = mul nh nf
  in (ni,) } in
let zernike_radial1 = { lambda ; nj:f64[1,1] nk:i64[25] nl:i64[25]. let
    nm:i64[25] = abs nl
    nn:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] nm
    no:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] nk
    np:f64[25] = sub no nn
    nq:f64[25] = pjit[
      name=floor_divide
      jaxpr={ lambda ; q:f64[25] s:i64[]. let
          t:f64[] = convert_element_type[new_dtype=float64 weak_type=False] s
          u:f64[25] = rem q t
          v:f64[25] = sub q u
          w:f64[25] = div v t
          x:bool[25] = ne u 0.0:f64[]
          y:f64[] = sign t
          z:f64[25] = sign u
          ba:bool[25] = ne y z
          bb:bool[25] = and x ba
          bc:f64[25] = add u t
          _:f64[25] = select_n bb u bc
          bd:f64[25] = sub w 1.0:f64[]
          be:f64[25] = select_n bb w bd
          r:f64[25] = round[rounding_method=0] be
        in (r,) }
    ] np 2:i64[]
    nr:f64[25] = pow -1.0:f64[] nq
    ns:f64[1,1] = integer_pow[y=2] nj
    nt:f64[1,1] = mul 2.0:f64[] ns
    nu:f64[1,1] = sub 1.0:f64[] nt
    nv:f64[1,25] = custom_jvp_call[
      name=_jacobi
      call_jaxpr={ lambda ; nw:f64[25] nx:f64[25] ny:i64[] nz:f64[1,1]. let
          oa:f64[1,25] = pjit[
            name=_jacobi
            jaxpr={ lambda ; bm:f64[25] bn:f64[25] bo:i64[] bp:f64[1,1] br:i64[]. let
                bs:f64[] = squeeze[dimensions=(0, 1)] bp
                bt:f64[25] = add bn bm
                bu:f64[25] = add bt 1.0:f64[]
                bv:f64[25] = div bu 2.0:f64[]
                bw:f64[25] = add bn bm
                bx:f64[25] = add bw 2.0:f64[]
                by:f64[25] = add bn bm
                bz:f64[25] = add by 1.0:f64[]
                ca:f64[25] = mul bx bz
                cb:f64[25] = div ca 4.0:f64[]
                cc:f64[25] = add bn bm
                cd:f64[25] = add cc 3.0:f64[]
                ce:f64[25] = add bn bm
                cf:f64[25] = add ce 2.0:f64[]
                cg:f64[25] = mul cd cf
                ch:f64[25] = add bn bm
                ci:f64[25] = add ch 1.0:f64[]
                cj:f64[25] = mul cg ci
                ck:f64[25] = div cj 8.0:f64[]
                cl:f64[25] = add bn bm
                cm:f64[25] = add cl 4.0:f64[]
                cn:f64[25] = add bn bm
                co:f64[25] = add cn 3.0:f64[]
                cp:f64[25] = mul cm co
                cq:f64[25] = add bn bm
                cr:f64[25] = add cq 2.0:f64[]
                cs:f64[25] = mul cp cr
                ct:f64[25] = add bn bm
                cu:f64[25] = add ct 1.0:f64[]
                cv:f64[25] = mul cs cu
                cw:f64[25] = div cv 16.0:f64[]
                cx:f64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] 1.0:f64[]
                cy:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] bv
                cz:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] cb
                da:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] ck
                db:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] cw
                dc:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(25, 1)
                  sharding=None
                ] cx
                dd:f64[25,5] = concatenate[dimension=1] dc cy cz da db
                de:bool[] = lt br 0:i64[]
                df:i64[] = convert_element_type[new_dtype=int64 weak_type=False] br
                dg:i64[] = add df 5:i64[]
                dh:i64[] = select_n de br dg
                di:i64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] dh
                dj:f64[25,1] = gather[
                  dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
                  fill_value=None
                  indices_are_sorted=True
                  mode=GatherScatterMode.PROMISE_IN_BOUNDS
                  slice_sizes=(25, 1)
                  unique_indices=True
                ] dd di
                dk:f64[25] = squeeze[dimensions=(1,)] dj
                dl:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] br
                dm:f64[25] = sub bm dl
                dn:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] br
                do:f64[25] = add bn dn
                dp:i64[] = add bo br
                dq:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] dp
                dr:f64[25] = add do dq
                ds:f64[25] = add dr 2.0:f64[]
                dt:f64[] = sub bs 1.0:f64[]
                du:f64[25] = mul ds dt
                dv:f64[25] = add do 1.0:f64[]
                dw:f64[25] = mul 2.0:f64[] dv
                dx:f64[25] = div du dw
                dy:f64[25] = add dx 1.0:f64[]
                dz:f64[25] = sub dm 1.0:f64[]
                ea:f64[25] = max dz 0.0:f64[]
                eb:i64[25] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] ea
                ec:i64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] 0:i64[]
                _:i64[25] _:i64[25] _:f64[25] ed:f64[25] = while[
                  body_jaxpr={ lambda ; ee:f64[25] ef:i64[] eg:f64[] eh:i64[25] ei:i64[25]
                      ej:f64[25] ek:f64[25]. let
                      el:i64[25] = add eh 1:i64[]
                      em:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] eh
                      en:f64[25] = add em 1.0:f64[]
                      eo:f64[25] = mul 2.0:f64[] en
                      ep:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] eo
                      eq:f64[25] = add ep ee
                      er:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] ef
                      es:f64[25] = add eq er
                      et:f64[25] = add es 1.0:f64[]
                      eu:f64[25] = mul es et
                      ev:f64[25] = add es 2.0:f64[]
                      ew:f64[25] = mul eu ev
                      ex:f64[] = sub eg 1.0:f64[]
                      ey:f64[25] = mul ew ex
                      ez:f64[25] = mul ey ek
                      fa:f64[25] = mul 2.0:f64[] en
                      fb:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] ef
                      fc:f64[25] = add en fb
                      fd:f64[25] = mul fa fc
                      fe:f64[25] = add es 2.0:f64[]
                      ff:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] fd
                      fg:f64[25] = mul ff fe
                      fh:f64[25] = mul fg ej
                      fi:f64[25] = add ez fh
                      fj:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] en
                      fk:f64[25] = add fj ee
                      fl:f64[25] = add fk 1.0:f64[]
                      fm:f64[25] = mul 2.0:f64[] fl
                      fn:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] en
                      fo:f64[25] = add fn ee
                      fp:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] ef
                      fq:f64[25] = add fo fp
                      fr:f64[25] = add fq 1.0:f64[]
                      fs:f64[25] = mul fm fr
                      ft:f64[25] = mul fs es
                      fu:f64[25] = div fi ft
                      fv:f64[25] = add fu ek
                    in (el, ei, fu, fv) }
                  body_nconsts=3
                  cond_jaxpr={ lambda ; fw:i64[25] fx:i64[25] fy:f64[25] fz:f64[25]. let
                      ga:bool[25] = lt fw fx
                    in (ga,) }
                  cond_nconsts=0
                ] do dp bs ec eb dx dy
                gb:f64[25] = add dm do
                gc:f64[25] = pjit[
                  name=_binom
                  jaxpr={ lambda ; gb:f64[25] dm:f64[25]. let
                      gd:i64[25] = convert_element_type[
                        new_dtype=int64
                        weak_type=False
                      ] dm
                      ge:i64[25] = add 1:i64[] gd
                      gf:i64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] 1:i64[]
                      gg:f64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] 1.0:f64[]
                      _:i64[25] _:i64[25] gc:f64[25] = while[
                        body_jaxpr={ lambda ; gh:f64[25] gi:i64[25] gj:i64[25] gk:f64[25]. let
                            gl:i64[25] = add gi 1:i64[]
                            gm:f64[25] = add gh 1.0:f64[]
                            gn:f64[25] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] gi
                            go:f64[25] = sub gm gn
                            gp:f64[25] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] gk
                            gq:f64[25] = mul gp go
                            gr:f64[25] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] gi
                            gs:f64[25] = div gq gr
                          in (gl, gj, gs) }
                        body_nconsts=1
                        cond_jaxpr={ lambda ; gt:i64[25] gu:i64[25] gv:f64[25]. let
                            gw:bool[25] = lt gt gu
                          in (gw,) }
                        cond_nconsts=0
                      ] gb gf ge gg
                    in (gc,) }
                ] gb dm
                gx:f64[25] = mul gc ed
                gy:bool[25] = lt dm 0.0:f64[]
                gz:f64[25] = pjit[
                  name=_where
                  jaxpr={ lambda ; gy:bool[25] ha:i64[] gx:f64[25]. let
                      hb:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] ha
                      hc:f64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] hb
                      gz:f64[25] = select_n gy gx hc
                    in (gz,) }
                ] gy 0:i64[] gx
                hd:bool[25] = eq dm 0.0:f64[]
                he:f64[25] = pjit[
                  name=_where
                  jaxpr={ lambda ; hd:bool[25] hf:f64[] gz:f64[25]. let
                      hg:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] hf
                      hh:f64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] hg
                      he:f64[25] = select_n hd gz hh
                    in (he,) }
                ] hd 1.0:f64[] gz
                hi:bool[25] = eq dm 1.0:f64[]
                hj:f64[25] = add do 1.0:f64[]
                hk:f64[25] = mul 2.0:f64[] hj
                hl:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] dp
                hm:f64[25] = add do hl
                hn:f64[25] = add hm 2.0:f64[]
                ho:f64[] = sub bs 1.0:f64[]
                hp:f64[25] = mul hn ho
                hq:f64[25] = add hk hp
                hr:f64[25] = mul 0.5:f64[] hq
                hs:f64[25] = pjit[
                  name=_where
                  jaxpr={ lambda ; hi:bool[25] hr:f64[25] he:f64[25]. let
                      hs:f64[25] = select_n hi he hr
                    in (hs,) }
                ] hi hr he
                ht:f64[25] = mul dk hs
                bq:f64[1,25] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 25)
                  sharding=None
                ] ht
              in (bq,) }
          ] nw nx ny nz 0:i64[]
        in (oa,) }
      jvp=_jacobi_jvp
      symbolic_zeros=False
    ] nq nn 0:i64[] nu
    ob:f64[1,25] = custom_jvp_call[
      name=_jacobi
      call_jaxpr={ lambda ; oc:f64[25] od:f64[25] oe:i64[] of:f64[1,1]. let
          og:f64[1,25] = pjit[
            name=_jacobi
            jaxpr={ lambda ; bm:f64[25] bn:f64[25] bo:i64[] bp:f64[1,1] br:i64[]. let
                bs:f64[] = squeeze[dimensions=(0, 1)] bp
                bt:f64[25] = add bn bm
                bu:f64[25] = add bt 1.0:f64[]
                bv:f64[25] = div bu 2.0:f64[]
                bw:f64[25] = add bn bm
                bx:f64[25] = add bw 2.0:f64[]
                by:f64[25] = add bn bm
                bz:f64[25] = add by 1.0:f64[]
                ca:f64[25] = mul bx bz
                cb:f64[25] = div ca 4.0:f64[]
                cc:f64[25] = add bn bm
                cd:f64[25] = add cc 3.0:f64[]
                ce:f64[25] = add bn bm
                cf:f64[25] = add ce 2.0:f64[]
                cg:f64[25] = mul cd cf
                ch:f64[25] = add bn bm
                ci:f64[25] = add ch 1.0:f64[]
                cj:f64[25] = mul cg ci
                ck:f64[25] = div cj 8.0:f64[]
                cl:f64[25] = add bn bm
                cm:f64[25] = add cl 4.0:f64[]
                cn:f64[25] = add bn bm
                co:f64[25] = add cn 3.0:f64[]
                cp:f64[25] = mul cm co
                cq:f64[25] = add bn bm
                cr:f64[25] = add cq 2.0:f64[]
                cs:f64[25] = mul cp cr
                ct:f64[25] = add bn bm
                cu:f64[25] = add ct 1.0:f64[]
                cv:f64[25] = mul cs cu
                cw:f64[25] = div cv 16.0:f64[]
                cx:f64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] 1.0:f64[]
                cy:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] bv
                cz:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] cb
                da:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] ck
                db:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(25, 1)
                  sharding=None
                ] cw
                dc:f64[25,1] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(25, 1)
                  sharding=None
                ] cx
                dd:f64[25,5] = concatenate[dimension=1] dc cy cz da db
                de:bool[] = lt br 0:i64[]
                df:i64[] = convert_element_type[new_dtype=int64 weak_type=False] br
                dg:i64[] = add df 5:i64[]
                dh:i64[] = select_n de br dg
                di:i64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] dh
                dj:f64[25,1] = gather[
                  dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
                  fill_value=None
                  indices_are_sorted=True
                  mode=GatherScatterMode.PROMISE_IN_BOUNDS
                  slice_sizes=(25, 1)
                  unique_indices=True
                ] dd di
                dk:f64[25] = squeeze[dimensions=(1,)] dj
                dl:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] br
                dm:f64[25] = sub bm dl
                dn:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] br
                do:f64[25] = add bn dn
                dp:i64[] = add bo br
                dq:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] dp
                dr:f64[25] = add do dq
                ds:f64[25] = add dr 2.0:f64[]
                dt:f64[] = sub bs 1.0:f64[]
                du:f64[25] = mul ds dt
                dv:f64[25] = add do 1.0:f64[]
                dw:f64[25] = mul 2.0:f64[] dv
                dx:f64[25] = div du dw
                dy:f64[25] = add dx 1.0:f64[]
                dz:f64[25] = sub dm 1.0:f64[]
                ea:f64[25] = max dz 0.0:f64[]
                eb:i64[25] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] ea
                ec:i64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] 0:i64[]
                _:i64[25] _:i64[25] _:f64[25] ed:f64[25] = while[
                  body_jaxpr={ lambda ; ee:f64[25] ef:i64[] eg:f64[] eh:i64[25] ei:i64[25]
                      ej:f64[25] ek:f64[25]. let
                      el:i64[25] = add eh 1:i64[]
                      em:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] eh
                      en:f64[25] = add em 1.0:f64[]
                      eo:f64[25] = mul 2.0:f64[] en
                      ep:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] eo
                      eq:f64[25] = add ep ee
                      er:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] ef
                      es:f64[25] = add eq er
                      et:f64[25] = add es 1.0:f64[]
                      eu:f64[25] = mul es et
                      ev:f64[25] = add es 2.0:f64[]
                      ew:f64[25] = mul eu ev
                      ex:f64[] = sub eg 1.0:f64[]
                      ey:f64[25] = mul ew ex
                      ez:f64[25] = mul ey ek
                      fa:f64[25] = mul 2.0:f64[] en
                      fb:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] ef
                      fc:f64[25] = add en fb
                      fd:f64[25] = mul fa fc
                      fe:f64[25] = add es 2.0:f64[]
                      ff:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] fd
                      fg:f64[25] = mul ff fe
                      fh:f64[25] = mul fg ej
                      fi:f64[25] = add ez fh
                      fj:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] en
                      fk:f64[25] = add fj ee
                      fl:f64[25] = add fk 1.0:f64[]
                      fm:f64[25] = mul 2.0:f64[] fl
                      fn:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] en
                      fo:f64[25] = add fn ee
                      fp:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] ef
                      fq:f64[25] = add fo fp
                      fr:f64[25] = add fq 1.0:f64[]
                      fs:f64[25] = mul fm fr
                      ft:f64[25] = mul fs es
                      fu:f64[25] = div fi ft
                      fv:f64[25] = add fu ek
                    in (el, ei, fu, fv) }
                  body_nconsts=3
                  cond_jaxpr={ lambda ; fw:i64[25] fx:i64[25] fy:f64[25] fz:f64[25]. let
                      ga:bool[25] = lt fw fx
                    in (ga,) }
                  cond_nconsts=0
                ] do dp bs ec eb dx dy
                gb:f64[25] = add dm do
                gc:f64[25] = pjit[
                  name=_binom
                  jaxpr={ lambda ; gb:f64[25] dm:f64[25]. let
                      gd:i64[25] = convert_element_type[
                        new_dtype=int64
                        weak_type=False
                      ] dm
                      ge:i64[25] = add 1:i64[] gd
                      gf:i64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] 1:i64[]
                      gg:f64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] 1.0:f64[]
                      _:i64[25] _:i64[25] gc:f64[25] = while[
                        body_jaxpr={ lambda ; gh:f64[25] gi:i64[25] gj:i64[25] gk:f64[25]. let
                            gl:i64[25] = add gi 1:i64[]
                            gm:f64[25] = add gh 1.0:f64[]
                            gn:f64[25] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] gi
                            go:f64[25] = sub gm gn
                            gp:f64[25] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] gk
                            gq:f64[25] = mul gp go
                            gr:f64[25] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] gi
                            gs:f64[25] = div gq gr
                          in (gl, gj, gs) }
                        body_nconsts=1
                        cond_jaxpr={ lambda ; gt:i64[25] gu:i64[25] gv:f64[25]. let
                            gw:bool[25] = lt gt gu
                          in (gw,) }
                        cond_nconsts=0
                      ] gb gf ge gg
                    in (gc,) }
                ] gb dm
                gx:f64[25] = mul gc ed
                gy:bool[25] = lt dm 0.0:f64[]
                gz:f64[25] = pjit[
                  name=_where
                  jaxpr={ lambda ; gy:bool[25] ha:i64[] gx:f64[25]. let
                      hb:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] ha
                      hc:f64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] hb
                      gz:f64[25] = select_n gy gx hc
                    in (gz,) }
                ] gy 0:i64[] gx
                hd:bool[25] = eq dm 0.0:f64[]
                he:f64[25] = pjit[
                  name=_where
                  jaxpr={ lambda ; hd:bool[25] hf:f64[] gz:f64[25]. let
                      hg:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] hf
                      hh:f64[25] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(25,)
                        sharding=None
                      ] hg
                      he:f64[25] = select_n hd gz hh
                    in (he,) }
                ] hd 1.0:f64[] gz
                hi:bool[25] = eq dm 1.0:f64[]
                hj:f64[25] = add do 1.0:f64[]
                hk:f64[25] = mul 2.0:f64[] hj
                hl:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] dp
                hm:f64[25] = add do hl
                hn:f64[25] = add hm 2.0:f64[]
                ho:f64[] = sub bs 1.0:f64[]
                hp:f64[25] = mul hn ho
                hq:f64[25] = add hk hp
                hr:f64[25] = mul 0.5:f64[] hq
                hs:f64[25] = pjit[
                  name=_where
                  jaxpr={ lambda ; hi:bool[25] hr:f64[25] he:f64[25]. let
                      hs:f64[25] = select_n hi he hr
                    in (hs,) }
                ] hi hr he
                ht:f64[25] = mul dk hs
                bq:f64[1,25] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 25)
                  sharding=None
                ] ht
              in (bq,) }
          ] oc od oe of 1:i64[]
        in (og,) }
      jvp=_jacobi_jvp
      symbolic_zeros=False
    ] nq nn 0:i64[] nu
    oh:f64[25] = sub nn 1.0:f64[]
    oi:f64[25] = max oh 0.0:f64[]
    oj:f64[1,25] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 25)
      sharding=None
    ] oi
    ok:f64[1,25] = pow nj oj
    ol:f64[1,25] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 25)
      sharding=None
    ] nn
    om:f64[1,25] = mul ol ok
    on:f64[1,25] = mul om nv
    oo:f64[25] = add nn 1.0:f64[]
    op:f64[1,25] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 25)
      sharding=None
    ] oo
    oq:f64[1,25] = pow nj op
    or:f64[1,25] = mul 4.0:f64[] oq
    os:f64[1,25] = mul or ob
    ot:f64[1,25] = sub on os
    ou:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] nk
    ov:f64[25] = sub ou nn
    ow:f64[25] = pjit[
      name=remainder
      jaxpr={ lambda ; hw:f64[25] hy:i64[]. let
          hz:f64[] = convert_element_type[new_dtype=float64 weak_type=False] hy
          ia:f64[25] = rem hw hz
          ib:bool[25] = ne ia 0.0:f64[]
          ic:bool[25] = lt ia 0.0:f64[]
          id:bool[] = lt hz 0.0:f64[]
          ie:bool[25] = ne ic id
          if:bool[25] = and ie ib
          ig:f64[25] = add ia hz
          hx:f64[25] = select_n if ia ig
        in (hx,) }
    ] ov 2:i64[]
    ox:bool[25] = eq ow 0.0:f64[]
    oy:f64[1,25] = pjit[
      name=_where
      jaxpr={ lambda ; ih:bool[25] hu:f64[1,25] ij:f64[]. let
          ik:f64[] = convert_element_type[new_dtype=float64 weak_type=False] ij
          il:bool[1,25] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 25)
            sharding=None
          ] ih
          im:f64[1,25] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1, 25)
            sharding=None
          ] ik
          ii:f64[1,25] = select_n il im hu
        in (ii,) }
    ] ox ot 0.0:f64[]
    oz:f64[1,25] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 25)
      sharding=None
    ] nr
    pa:f64[1,25] = mul oz oy
  in (pa,) } in
let zernike_radial2 = { lambda ; pb:f64[1,1] pc:i64[20] pd:i64[20]. let
    pe:i64[20] = abs pd
    pf:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] pe
    pg:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] pc
    ph:f64[20] = sub pg pf
    pi:f64[20] = pjit[
      name=floor_divide
      jaxpr={ lambda ; ph:f64[20] pj:i64[]. let
          pk:f64[] = convert_element_type[new_dtype=float64 weak_type=False] pj
          pl:f64[20] = rem ph pk
          pm:f64[20] = sub ph pl
          pn:f64[20] = div pm pk
          po:bool[20] = ne pl 0.0:f64[]
          pp:f64[] = sign pk
          pq:f64[20] = sign pl
          pr:bool[20] = ne pp pq
          ps:bool[20] = and po pr
          pt:f64[20] = add pl pk
          _:f64[20] = select_n ps pl pt
          pu:f64[20] = sub pn 1.0:f64[]
          pv:f64[20] = select_n ps pn pu
          pi:f64[20] = round[rounding_method=0] pv
        in (pi,) }
    ] ph 2:i64[]
    pw:f64[20] = pow -1.0:f64[] pi
    px:f64[1,1] = integer_pow[y=2] pb
    py:f64[1,1] = mul 2.0:f64[] px
    pz:f64[1,1] = sub 1.0:f64[] py
    qa:f64[1,20] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 20)
      sharding=None
    ] pf
    qb:f64[1,20] = pow pb qa
    qc:f64[1,20] = custom_jvp_call[
      name=_jacobi
      call_jaxpr={ lambda ; qd:f64[20] qe:f64[20] qf:i64[] qg:f64[1,1]. let
          qh:f64[1,20] = pjit[
            name=_jacobi
            jaxpr={ lambda ; qd:f64[20] qe:f64[20] qf:i64[] qg:f64[1,1] qi:i64[]. let
                qj:f64[] = squeeze[dimensions=(0, 1)] qg
                qk:f64[20] = add qe qd
                ql:f64[20] = add qk 1.0:f64[]
                qm:f64[20] = div ql 2.0:f64[]
                qn:f64[20] = add qe qd
                qo:f64[20] = add qn 2.0:f64[]
                qp:f64[20] = add qe qd
                qq:f64[20] = add qp 1.0:f64[]
                qr:f64[20] = mul qo qq
                qs:f64[20] = div qr 4.0:f64[]
                qt:f64[20] = add qe qd
                qu:f64[20] = add qt 3.0:f64[]
                qv:f64[20] = add qe qd
                qw:f64[20] = add qv 2.0:f64[]
                qx:f64[20] = mul qu qw
                qy:f64[20] = add qe qd
                qz:f64[20] = add qy 1.0:f64[]
                ra:f64[20] = mul qx qz
                rb:f64[20] = div ra 8.0:f64[]
                rc:f64[20] = add qe qd
                rd:f64[20] = add rc 4.0:f64[]
                re:f64[20] = add qe qd
                rf:f64[20] = add re 3.0:f64[]
                rg:f64[20] = mul rd rf
                rh:f64[20] = add qe qd
                ri:f64[20] = add rh 2.0:f64[]
                rj:f64[20] = mul rg ri
                rk:f64[20] = add qe qd
                rl:f64[20] = add rk 1.0:f64[]
                rm:f64[20] = mul rj rl
                rn:f64[20] = div rm 16.0:f64[]
                ro:f64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] 1.0:f64[]
                rp:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] qm
                rq:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] qs
                rr:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] rb
                rs:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] rn
                rt:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(20, 1)
                  sharding=None
                ] ro
                ru:f64[20,5] = concatenate[dimension=1] rt rp rq rr rs
                rv:bool[] = lt qi 0:i64[]
                rw:i64[] = convert_element_type[new_dtype=int64 weak_type=False] qi
                rx:i64[] = add rw 5:i64[]
                ry:i64[] = select_n rv qi rx
                rz:i64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] ry
                sa:f64[20,1] = gather[
                  dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
                  fill_value=None
                  indices_are_sorted=True
                  mode=GatherScatterMode.PROMISE_IN_BOUNDS
                  slice_sizes=(20, 1)
                  unique_indices=True
                ] ru rz
                sb:f64[20] = squeeze[dimensions=(1,)] sa
                sc:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] qi
                sd:f64[20] = sub qd sc
                se:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] qi
                sf:f64[20] = add qe se
                sg:i64[] = add qf qi
                sh:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sg
                si:f64[20] = add sf sh
                sj:f64[20] = add si 2.0:f64[]
                sk:f64[] = sub qj 1.0:f64[]
                sl:f64[20] = mul sj sk
                sm:f64[20] = add sf 1.0:f64[]
                sn:f64[20] = mul 2.0:f64[] sm
                so:f64[20] = div sl sn
                sp:f64[20] = add so 1.0:f64[]
                sq:f64[20] = sub sd 1.0:f64[]
                sr:f64[20] = max sq 0.0:f64[]
                ss:i64[20] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] sr
                st:i64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] 0:i64[]
                _:i64[20] _:i64[20] _:f64[20] su:f64[20] = while[
                  body_jaxpr={ lambda ; sv:f64[20] sw:i64[] sx:f64[] sy:i64[20] sz:i64[20]
                      ta:f64[20] tb:f64[20]. let
                      tc:i64[20] = add sy 1:i64[]
                      td:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] sy
                      te:f64[20] = add td 1.0:f64[]
                      tf:f64[20] = mul 2.0:f64[] te
                      tg:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] tf
                      th:f64[20] = add tg sv
                      ti:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] sw
                      tj:f64[20] = add th ti
                      tk:f64[20] = add tj 1.0:f64[]
                      tl:f64[20] = mul tj tk
                      tm:f64[20] = add tj 2.0:f64[]
                      tn:f64[20] = mul tl tm
                      to:f64[] = sub sx 1.0:f64[]
                      tp:f64[20] = mul tn to
                      tq:f64[20] = mul tp tb
                      tr:f64[20] = mul 2.0:f64[] te
                      ts:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] sw
                      tt:f64[20] = add te ts
                      tu:f64[20] = mul tr tt
                      tv:f64[20] = add tj 2.0:f64[]
                      tw:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] tu
                      tx:f64[20] = mul tw tv
                      ty:f64[20] = mul tx ta
                      tz:f64[20] = add tq ty
                      ua:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] te
                      ub:f64[20] = add ua sv
                      uc:f64[20] = add ub 1.0:f64[]
                      ud:f64[20] = mul 2.0:f64[] uc
                      ue:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] te
                      uf:f64[20] = add ue sv
                      ug:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] sw
                      uh:f64[20] = add uf ug
                      ui:f64[20] = add uh 1.0:f64[]
                      uj:f64[20] = mul ud ui
                      uk:f64[20] = mul uj tj
                      ul:f64[20] = div tz uk
                      um:f64[20] = add ul tb
                    in (tc, sz, ul, um) }
                  body_nconsts=3
                  cond_jaxpr={ lambda ; un:i64[20] uo:i64[20] up:f64[20] uq:f64[20]. let
                      ur:bool[20] = lt un uo
                    in (ur,) }
                  cond_nconsts=0
                ] sf sg qj st ss so sp
                us:f64[20] = add sd sf
                ut:f64[20] = pjit[
                  name=_binom
                  jaxpr={ lambda ; us:f64[20] sd:f64[20]. let
                      uu:i64[20] = convert_element_type[
                        new_dtype=int64
                        weak_type=False
                      ] sd
                      uv:i64[20] = add 1:i64[] uu
                      uw:i64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] 1:i64[]
                      ux:f64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] 1.0:f64[]
                      _:i64[20] _:i64[20] ut:f64[20] = while[
                        body_jaxpr={ lambda ; uy:f64[20] uz:i64[20] va:i64[20] vb:f64[20]. let
                            vc:i64[20] = add uz 1:i64[]
                            vd:f64[20] = add uy 1.0:f64[]
                            ve:f64[20] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] uz
                            vf:f64[20] = sub vd ve
                            vg:f64[20] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] vb
                            vh:f64[20] = mul vg vf
                            vi:f64[20] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] uz
                            vj:f64[20] = div vh vi
                          in (vc, va, vj) }
                        body_nconsts=1
                        cond_jaxpr={ lambda ; vk:i64[20] vl:i64[20] vm:f64[20]. let
                            vn:bool[20] = lt vk vl
                          in (vn,) }
                        cond_nconsts=0
                      ] us uw uv ux
                    in (ut,) }
                ] us sd
                vo:f64[20] = mul ut su
                vp:bool[20] = lt sd 0.0:f64[]
                vq:f64[20] = pjit[
                  name=_where
                  jaxpr={ lambda ; vp:bool[20] vr:i64[] vo:f64[20]. let
                      vs:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] vr
                      vt:f64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] vs
                      vq:f64[20] = select_n vp vo vt
                    in (vq,) }
                ] vp 0:i64[] vo
                vu:bool[20] = eq sd 0.0:f64[]
                vv:f64[20] = pjit[
                  name=_where
                  jaxpr={ lambda ; vu:bool[20] vw:f64[] vq:f64[20]. let
                      vx:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] vw
                      vy:f64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] vx
                      vv:f64[20] = select_n vu vq vy
                    in (vv,) }
                ] vu 1.0:f64[] vq
                vz:bool[20] = eq sd 1.0:f64[]
                wa:f64[20] = add sf 1.0:f64[]
                wb:f64[20] = mul 2.0:f64[] wa
                wc:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sg
                wd:f64[20] = add sf wc
                we:f64[20] = add wd 2.0:f64[]
                wf:f64[] = sub qj 1.0:f64[]
                wg:f64[20] = mul we wf
                wh:f64[20] = add wb wg
                wi:f64[20] = mul 0.5:f64[] wh
                wj:f64[20] = pjit[
                  name=_where
                  jaxpr={ lambda ; vz:bool[20] wi:f64[20] vv:f64[20]. let
                      wj:f64[20] = select_n vz vv wi
                    in (wj,) }
                ] vz wi vv
                wk:f64[20] = mul sb wj
                qh:f64[1,20] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 20)
                  sharding=None
                ] wk
              in (qh,) }
          ] qd qe qf qg 0:i64[]
        in (qh,) }
      jvp=_jacobi_jvp
      symbolic_zeros=False
    ] pi pf 0:i64[] pz
    wl:f64[1,20] = mul qb qc
    wm:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] pc
    wn:f64[20] = sub wm pf
    wo:f64[20] = pjit[
      name=remainder
      jaxpr={ lambda ; wn:f64[20] wp:i64[]. let
          wq:f64[] = convert_element_type[new_dtype=float64 weak_type=False] wp
          wr:f64[20] = rem wn wq
          ws:bool[20] = ne wr 0.0:f64[]
          wt:bool[20] = lt wr 0.0:f64[]
          wu:bool[] = lt wq 0.0:f64[]
          wv:bool[20] = ne wt wu
          ww:bool[20] = and wv ws
          wx:f64[20] = add wr wq
          wo:f64[20] = select_n ww wr wx
        in (wo,) }
    ] wn 2:i64[]
    wy:bool[20] = eq wo 0.0:f64[]
    wz:f64[1,20] = pjit[
      name=_where
      jaxpr={ lambda ; wy:bool[20] wl:f64[1,20] xa:f64[]. let
          xb:f64[] = convert_element_type[new_dtype=float64 weak_type=False] xa
          xc:bool[1,20] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 20)
            sharding=None
          ] wy
          xd:f64[1,20] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1, 20)
            sharding=None
          ] xb
          wz:f64[1,20] = select_n xc xd wl
        in (wz,) }
    ] wy wl 0.0:f64[]
    xe:f64[1,20] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 20)
      sharding=None
    ] pw
    xf:f64[1,20] = mul xe wz
  in (xf,) } in
let fourier2 = { lambda ; xg:f64[1,1] xh:i64[8] xi:i64[]. let
    xj:bool[8] = ge xh 0:i64[]
    xk:i64[8] = convert_element_type[new_dtype=int64 weak_type=False] xj
    xl:i64[8] = abs xh
    xm:i64[8] = mul xl 1:i64[]
    xn:f64[8] = convert_element_type[new_dtype=float64 weak_type=True] xk
    xo:f64[8] = mul xn 3.141592653589793:f64[]
    xp:f64[8] = div xo 2.0:f64[]
    xq:f64[] = convert_element_type[new_dtype=float64 weak_type=True] xi
    xr:f64[] = mul xq 3.141592653589793:f64[]
    xs:f64[] = div xr 2.0:f64[]
    xt:f64[8] = add xp xs
    xu:bool[8] = eq xm 0:i64[]
    xv:bool[] = ne xi 0:i64[]
    xw:bool[8] = and xu xv
    xx:i64[8] = pjit[
      name=_where
      jaxpr={ lambda ; xw:bool[8] xy:i64[] xz:i64[]. let
          ya:i64[8] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(8,)
            sharding=None
          ] xy
          yb:i64[8] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(8,)
            sharding=None
          ] xz
          xx:i64[8] = select_n xw yb ya
        in (xx,) }
    ] xw 0:i64[] 1:i64[]
    yc:i64[] = and xi 1:i64[]
    yd:i64[8] = mul xx xm
    ye:i64[8] = pjit[
      name=_where
      jaxpr={ lambda ; yc:i64[] yd:i64[8] xx:i64[8]. let
          yf:bool[] = ne yc 0:i64[]
          ye:i64[8] = select_n yf xx yd
        in (ye,) }
    ] yc yd xx
    yg:i64[8] = mul xm xm
    yh:i64[] = shift_right_logical xi 1:i64[]
    yi:i64[] = and yh 1:i64[]
    yj:i64[8] = mul ye yg
    yk:i64[8] = pjit[
      name=_where
      jaxpr={ lambda ; yc:i64[] yd:i64[8] xx:i64[8]. let
          yf:bool[] = ne yc 0:i64[]
          ye:i64[8] = select_n yf xx yd
        in (ye,) }
    ] yi yj ye
    yl:i64[8] = mul yg yg
    ym:i64[] = shift_right_logical yh 1:i64[]
    yn:i64[] = and ym 1:i64[]
    yo:i64[8] = mul yk yl
    yp:i64[8] = pjit[
      name=_where
      jaxpr={ lambda ; yc:i64[] yd:i64[8] xx:i64[8]. let
          yf:bool[] = ne yc 0:i64[]
          ye:i64[8] = select_n yf xx yd
        in (ye,) }
    ] yn yo yk
    yq:i64[8] = mul yl yl
    yr:i64[] = shift_right_logical ym 1:i64[]
    ys:i64[] = and yr 1:i64[]
    yt:i64[8] = mul yp yq
    yu:i64[8] = pjit[
      name=_where
      jaxpr={ lambda ; yc:i64[] yd:i64[8] xx:i64[8]. let
          yf:bool[] = ne yc 0:i64[]
          ye:i64[8] = select_n yf xx yd
        in (ye,) }
    ] ys yt yp
    yv:i64[8] = mul yq yq
    yw:i64[] = shift_right_logical yr 1:i64[]
    yx:i64[] = and yw 1:i64[]
    yy:i64[8] = mul yu yv
    yz:i64[8] = pjit[
      name=_where
      jaxpr={ lambda ; yc:i64[] yd:i64[8] xx:i64[8]. let
          yf:bool[] = ne yc 0:i64[]
          ye:i64[8] = select_n yf xx yd
        in (ye,) }
    ] yx yy yu
    za:i64[8] = mul yv yv
    zb:i64[] = shift_right_logical yw 1:i64[]
    zc:i64[] = and zb 1:i64[]
    zd:i64[8] = mul yz za
    ze:i64[8] = pjit[
      name=_where
      jaxpr={ lambda ; yc:i64[] yd:i64[8] xx:i64[8]. let
          yf:bool[] = ne yc 0:i64[]
          ye:i64[8] = select_n yf xx yd
        in (ye,) }
    ] zc zd yz
    _:i64[8] = mul za za
    _:i64[] = shift_right_logical zb 1:i64[]
    zf:f64[8] = convert_element_type[new_dtype=float64 weak_type=False] xm
    zg:f64[1,8] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 8)
      sharding=None
    ] zf
    zh:f64[1,8] = mul zg xg
    zi:f64[8] = convert_element_type[new_dtype=float64 weak_type=False] xt
    zj:f64[1,8] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 8)
      sharding=None
    ] zi
    zk:f64[1,8] = add zh zj
    zl:f64[1,8] = sin zk
    zm:f64[8] = convert_element_type[new_dtype=float64 weak_type=False] ze
    zn:f64[1,8] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 8)
      sharding=None
    ] zm
    zo:f64[1,8] = mul zn zl
  in (zo,) } in
let zernike_radial3 = { lambda ; zp:f64[1,1] zq:i64[20] zr:i64[20]. let
    zs:i64[20] = abs zr
    zt:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] zs
    zu:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] zq
    zv:f64[20] = sub zu zt
    zw:f64[20] = pjit[
      name=floor_divide
      jaxpr={ lambda ; ph:f64[20] pj:i64[]. let
          pk:f64[] = convert_element_type[new_dtype=float64 weak_type=False] pj
          pl:f64[20] = rem ph pk
          pm:f64[20] = sub ph pl
          pn:f64[20] = div pm pk
          po:bool[20] = ne pl 0.0:f64[]
          pp:f64[] = sign pk
          pq:f64[20] = sign pl
          pr:bool[20] = ne pp pq
          ps:bool[20] = and po pr
          pt:f64[20] = add pl pk
          _:f64[20] = select_n ps pl pt
          pu:f64[20] = sub pn 1.0:f64[]
          pv:f64[20] = select_n ps pn pu
          pi:f64[20] = round[rounding_method=0] pv
        in (pi,) }
    ] zv 2:i64[]
    zx:f64[20] = pow -1.0:f64[] zw
    zy:f64[1,1] = integer_pow[y=2] zp
    zz:f64[1,1] = mul 2.0:f64[] zy
    baa:f64[1,1] = sub 1.0:f64[] zz
    bab:f64[1,20] = custom_jvp_call[
      name=_jacobi
      call_jaxpr={ lambda ; bac:f64[20] bad:f64[20] bae:i64[] baf:f64[1,1]. let
          bag:f64[1,20] = pjit[
            name=_jacobi
            jaxpr={ lambda ; qd:f64[20] qe:f64[20] qf:i64[] qg:f64[1,1] qi:i64[]. let
                qj:f64[] = squeeze[dimensions=(0, 1)] qg
                qk:f64[20] = add qe qd
                ql:f64[20] = add qk 1.0:f64[]
                qm:f64[20] = div ql 2.0:f64[]
                qn:f64[20] = add qe qd
                qo:f64[20] = add qn 2.0:f64[]
                qp:f64[20] = add qe qd
                qq:f64[20] = add qp 1.0:f64[]
                qr:f64[20] = mul qo qq
                qs:f64[20] = div qr 4.0:f64[]
                qt:f64[20] = add qe qd
                qu:f64[20] = add qt 3.0:f64[]
                qv:f64[20] = add qe qd
                qw:f64[20] = add qv 2.0:f64[]
                qx:f64[20] = mul qu qw
                qy:f64[20] = add qe qd
                qz:f64[20] = add qy 1.0:f64[]
                ra:f64[20] = mul qx qz
                rb:f64[20] = div ra 8.0:f64[]
                rc:f64[20] = add qe qd
                rd:f64[20] = add rc 4.0:f64[]
                re:f64[20] = add qe qd
                rf:f64[20] = add re 3.0:f64[]
                rg:f64[20] = mul rd rf
                rh:f64[20] = add qe qd
                ri:f64[20] = add rh 2.0:f64[]
                rj:f64[20] = mul rg ri
                rk:f64[20] = add qe qd
                rl:f64[20] = add rk 1.0:f64[]
                rm:f64[20] = mul rj rl
                rn:f64[20] = div rm 16.0:f64[]
                ro:f64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] 1.0:f64[]
                rp:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] qm
                rq:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] qs
                rr:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] rb
                rs:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] rn
                rt:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(20, 1)
                  sharding=None
                ] ro
                ru:f64[20,5] = concatenate[dimension=1] rt rp rq rr rs
                rv:bool[] = lt qi 0:i64[]
                rw:i64[] = convert_element_type[new_dtype=int64 weak_type=False] qi
                rx:i64[] = add rw 5:i64[]
                ry:i64[] = select_n rv qi rx
                rz:i64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] ry
                sa:f64[20,1] = gather[
                  dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
                  fill_value=None
                  indices_are_sorted=True
                  mode=GatherScatterMode.PROMISE_IN_BOUNDS
                  slice_sizes=(20, 1)
                  unique_indices=True
                ] ru rz
                sb:f64[20] = squeeze[dimensions=(1,)] sa
                sc:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] qi
                sd:f64[20] = sub qd sc
                se:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] qi
                sf:f64[20] = add qe se
                sg:i64[] = add qf qi
                sh:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sg
                si:f64[20] = add sf sh
                sj:f64[20] = add si 2.0:f64[]
                sk:f64[] = sub qj 1.0:f64[]
                sl:f64[20] = mul sj sk
                sm:f64[20] = add sf 1.0:f64[]
                sn:f64[20] = mul 2.0:f64[] sm
                so:f64[20] = div sl sn
                sp:f64[20] = add so 1.0:f64[]
                sq:f64[20] = sub sd 1.0:f64[]
                sr:f64[20] = max sq 0.0:f64[]
                ss:i64[20] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] sr
                st:i64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] 0:i64[]
                _:i64[20] _:i64[20] _:f64[20] su:f64[20] = while[
                  body_jaxpr={ lambda ; sv:f64[20] sw:i64[] sx:f64[] sy:i64[20] sz:i64[20]
                      ta:f64[20] tb:f64[20]. let
                      tc:i64[20] = add sy 1:i64[]
                      td:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] sy
                      te:f64[20] = add td 1.0:f64[]
                      tf:f64[20] = mul 2.0:f64[] te
                      tg:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] tf
                      th:f64[20] = add tg sv
                      ti:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] sw
                      tj:f64[20] = add th ti
                      tk:f64[20] = add tj 1.0:f64[]
                      tl:f64[20] = mul tj tk
                      tm:f64[20] = add tj 2.0:f64[]
                      tn:f64[20] = mul tl tm
                      to:f64[] = sub sx 1.0:f64[]
                      tp:f64[20] = mul tn to
                      tq:f64[20] = mul tp tb
                      tr:f64[20] = mul 2.0:f64[] te
                      ts:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] sw
                      tt:f64[20] = add te ts
                      tu:f64[20] = mul tr tt
                      tv:f64[20] = add tj 2.0:f64[]
                      tw:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] tu
                      tx:f64[20] = mul tw tv
                      ty:f64[20] = mul tx ta
                      tz:f64[20] = add tq ty
                      ua:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] te
                      ub:f64[20] = add ua sv
                      uc:f64[20] = add ub 1.0:f64[]
                      ud:f64[20] = mul 2.0:f64[] uc
                      ue:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] te
                      uf:f64[20] = add ue sv
                      ug:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] sw
                      uh:f64[20] = add uf ug
                      ui:f64[20] = add uh 1.0:f64[]
                      uj:f64[20] = mul ud ui
                      uk:f64[20] = mul uj tj
                      ul:f64[20] = div tz uk
                      um:f64[20] = add ul tb
                    in (tc, sz, ul, um) }
                  body_nconsts=3
                  cond_jaxpr={ lambda ; un:i64[20] uo:i64[20] up:f64[20] uq:f64[20]. let
                      ur:bool[20] = lt un uo
                    in (ur,) }
                  cond_nconsts=0
                ] sf sg qj st ss so sp
                us:f64[20] = add sd sf
                ut:f64[20] = pjit[
                  name=_binom
                  jaxpr={ lambda ; us:f64[20] sd:f64[20]. let
                      uu:i64[20] = convert_element_type[
                        new_dtype=int64
                        weak_type=False
                      ] sd
                      uv:i64[20] = add 1:i64[] uu
                      uw:i64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] 1:i64[]
                      ux:f64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] 1.0:f64[]
                      _:i64[20] _:i64[20] ut:f64[20] = while[
                        body_jaxpr={ lambda ; uy:f64[20] uz:i64[20] va:i64[20] vb:f64[20]. let
                            vc:i64[20] = add uz 1:i64[]
                            vd:f64[20] = add uy 1.0:f64[]
                            ve:f64[20] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] uz
                            vf:f64[20] = sub vd ve
                            vg:f64[20] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] vb
                            vh:f64[20] = mul vg vf
                            vi:f64[20] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] uz
                            vj:f64[20] = div vh vi
                          in (vc, va, vj) }
                        body_nconsts=1
                        cond_jaxpr={ lambda ; vk:i64[20] vl:i64[20] vm:f64[20]. let
                            vn:bool[20] = lt vk vl
                          in (vn,) }
                        cond_nconsts=0
                      ] us uw uv ux
                    in (ut,) }
                ] us sd
                vo:f64[20] = mul ut su
                vp:bool[20] = lt sd 0.0:f64[]
                vq:f64[20] = pjit[
                  name=_where
                  jaxpr={ lambda ; vp:bool[20] vr:i64[] vo:f64[20]. let
                      vs:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] vr
                      vt:f64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] vs
                      vq:f64[20] = select_n vp vo vt
                    in (vq,) }
                ] vp 0:i64[] vo
                vu:bool[20] = eq sd 0.0:f64[]
                vv:f64[20] = pjit[
                  name=_where
                  jaxpr={ lambda ; vu:bool[20] vw:f64[] vq:f64[20]. let
                      vx:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] vw
                      vy:f64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] vx
                      vv:f64[20] = select_n vu vq vy
                    in (vv,) }
                ] vu 1.0:f64[] vq
                vz:bool[20] = eq sd 1.0:f64[]
                wa:f64[20] = add sf 1.0:f64[]
                wb:f64[20] = mul 2.0:f64[] wa
                wc:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sg
                wd:f64[20] = add sf wc
                we:f64[20] = add wd 2.0:f64[]
                wf:f64[] = sub qj 1.0:f64[]
                wg:f64[20] = mul we wf
                wh:f64[20] = add wb wg
                wi:f64[20] = mul 0.5:f64[] wh
                wj:f64[20] = pjit[
                  name=_where
                  jaxpr={ lambda ; vz:bool[20] wi:f64[20] vv:f64[20]. let
                      wj:f64[20] = select_n vz vv wi
                    in (wj,) }
                ] vz wi vv
                wk:f64[20] = mul sb wj
                qh:f64[1,20] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 20)
                  sharding=None
                ] wk
              in (qh,) }
          ] bac bad bae baf 0:i64[]
        in (bag,) }
      jvp=_jacobi_jvp
      symbolic_zeros=False
    ] zw zt 0:i64[] baa
    bah:f64[1,20] = custom_jvp_call[
      name=_jacobi
      call_jaxpr={ lambda ; bai:f64[20] baj:f64[20] bak:i64[] bal:f64[1,1]. let
          bam:f64[1,20] = pjit[
            name=_jacobi
            jaxpr={ lambda ; qd:f64[20] qe:f64[20] qf:i64[] qg:f64[1,1] qi:i64[]. let
                qj:f64[] = squeeze[dimensions=(0, 1)] qg
                qk:f64[20] = add qe qd
                ql:f64[20] = add qk 1.0:f64[]
                qm:f64[20] = div ql 2.0:f64[]
                qn:f64[20] = add qe qd
                qo:f64[20] = add qn 2.0:f64[]
                qp:f64[20] = add qe qd
                qq:f64[20] = add qp 1.0:f64[]
                qr:f64[20] = mul qo qq
                qs:f64[20] = div qr 4.0:f64[]
                qt:f64[20] = add qe qd
                qu:f64[20] = add qt 3.0:f64[]
                qv:f64[20] = add qe qd
                qw:f64[20] = add qv 2.0:f64[]
                qx:f64[20] = mul qu qw
                qy:f64[20] = add qe qd
                qz:f64[20] = add qy 1.0:f64[]
                ra:f64[20] = mul qx qz
                rb:f64[20] = div ra 8.0:f64[]
                rc:f64[20] = add qe qd
                rd:f64[20] = add rc 4.0:f64[]
                re:f64[20] = add qe qd
                rf:f64[20] = add re 3.0:f64[]
                rg:f64[20] = mul rd rf
                rh:f64[20] = add qe qd
                ri:f64[20] = add rh 2.0:f64[]
                rj:f64[20] = mul rg ri
                rk:f64[20] = add qe qd
                rl:f64[20] = add rk 1.0:f64[]
                rm:f64[20] = mul rj rl
                rn:f64[20] = div rm 16.0:f64[]
                ro:f64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] 1.0:f64[]
                rp:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] qm
                rq:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] qs
                rr:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] rb
                rs:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(0,)
                  shape=(20, 1)
                  sharding=None
                ] rn
                rt:f64[20,1] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(20, 1)
                  sharding=None
                ] ro
                ru:f64[20,5] = concatenate[dimension=1] rt rp rq rr rs
                rv:bool[] = lt qi 0:i64[]
                rw:i64[] = convert_element_type[new_dtype=int64 weak_type=False] qi
                rx:i64[] = add rw 5:i64[]
                ry:i64[] = select_n rv qi rx
                rz:i64[1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(1,)
                  sharding=None
                ] ry
                sa:f64[20,1] = gather[
                  dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
                  fill_value=None
                  indices_are_sorted=True
                  mode=GatherScatterMode.PROMISE_IN_BOUNDS
                  slice_sizes=(20, 1)
                  unique_indices=True
                ] ru rz
                sb:f64[20] = squeeze[dimensions=(1,)] sa
                sc:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] qi
                sd:f64[20] = sub qd sc
                se:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] qi
                sf:f64[20] = add qe se
                sg:i64[] = add qf qi
                sh:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sg
                si:f64[20] = add sf sh
                sj:f64[20] = add si 2.0:f64[]
                sk:f64[] = sub qj 1.0:f64[]
                sl:f64[20] = mul sj sk
                sm:f64[20] = add sf 1.0:f64[]
                sn:f64[20] = mul 2.0:f64[] sm
                so:f64[20] = div sl sn
                sp:f64[20] = add so 1.0:f64[]
                sq:f64[20] = sub sd 1.0:f64[]
                sr:f64[20] = max sq 0.0:f64[]
                ss:i64[20] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] sr
                st:i64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] 0:i64[]
                _:i64[20] _:i64[20] _:f64[20] su:f64[20] = while[
                  body_jaxpr={ lambda ; sv:f64[20] sw:i64[] sx:f64[] sy:i64[20] sz:i64[20]
                      ta:f64[20] tb:f64[20]. let
                      tc:i64[20] = add sy 1:i64[]
                      td:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] sy
                      te:f64[20] = add td 1.0:f64[]
                      tf:f64[20] = mul 2.0:f64[] te
                      tg:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] tf
                      th:f64[20] = add tg sv
                      ti:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] sw
                      tj:f64[20] = add th ti
                      tk:f64[20] = add tj 1.0:f64[]
                      tl:f64[20] = mul tj tk
                      tm:f64[20] = add tj 2.0:f64[]
                      tn:f64[20] = mul tl tm
                      to:f64[] = sub sx 1.0:f64[]
                      tp:f64[20] = mul tn to
                      tq:f64[20] = mul tp tb
                      tr:f64[20] = mul 2.0:f64[] te
                      ts:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=True
                      ] sw
                      tt:f64[20] = add te ts
                      tu:f64[20] = mul tr tt
                      tv:f64[20] = add tj 2.0:f64[]
                      tw:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] tu
                      tx:f64[20] = mul tw tv
                      ty:f64[20] = mul tx ta
                      tz:f64[20] = add tq ty
                      ua:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] te
                      ub:f64[20] = add ua sv
                      uc:f64[20] = add ub 1.0:f64[]
                      ud:f64[20] = mul 2.0:f64[] uc
                      ue:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] te
                      uf:f64[20] = add ue sv
                      ug:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] sw
                      uh:f64[20] = add uf ug
                      ui:f64[20] = add uh 1.0:f64[]
                      uj:f64[20] = mul ud ui
                      uk:f64[20] = mul uj tj
                      ul:f64[20] = div tz uk
                      um:f64[20] = add ul tb
                    in (tc, sz, ul, um) }
                  body_nconsts=3
                  cond_jaxpr={ lambda ; un:i64[20] uo:i64[20] up:f64[20] uq:f64[20]. let
                      ur:bool[20] = lt un uo
                    in (ur,) }
                  cond_nconsts=0
                ] sf sg qj st ss so sp
                us:f64[20] = add sd sf
                ut:f64[20] = pjit[
                  name=_binom
                  jaxpr={ lambda ; us:f64[20] sd:f64[20]. let
                      uu:i64[20] = convert_element_type[
                        new_dtype=int64
                        weak_type=False
                      ] sd
                      uv:i64[20] = add 1:i64[] uu
                      uw:i64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] 1:i64[]
                      ux:f64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] 1.0:f64[]
                      _:i64[20] _:i64[20] ut:f64[20] = while[
                        body_jaxpr={ lambda ; uy:f64[20] uz:i64[20] va:i64[20] vb:f64[20]. let
                            vc:i64[20] = add uz 1:i64[]
                            vd:f64[20] = add uy 1.0:f64[]
                            ve:f64[20] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] uz
                            vf:f64[20] = sub vd ve
                            vg:f64[20] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] vb
                            vh:f64[20] = mul vg vf
                            vi:f64[20] = convert_element_type[
                              new_dtype=float64
                              weak_type=False
                            ] uz
                            vj:f64[20] = div vh vi
                          in (vc, va, vj) }
                        body_nconsts=1
                        cond_jaxpr={ lambda ; vk:i64[20] vl:i64[20] vm:f64[20]. let
                            vn:bool[20] = lt vk vl
                          in (vn,) }
                        cond_nconsts=0
                      ] us uw uv ux
                    in (ut,) }
                ] us sd
                vo:f64[20] = mul ut su
                vp:bool[20] = lt sd 0.0:f64[]
                vq:f64[20] = pjit[
                  name=_where
                  jaxpr={ lambda ; vp:bool[20] vr:i64[] vo:f64[20]. let
                      vs:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] vr
                      vt:f64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] vs
                      vq:f64[20] = select_n vp vo vt
                    in (vq,) }
                ] vp 0:i64[] vo
                vu:bool[20] = eq sd 0.0:f64[]
                vv:f64[20] = pjit[
                  name=_where
                  jaxpr={ lambda ; vu:bool[20] vw:f64[] vq:f64[20]. let
                      vx:f64[] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] vw
                      vy:f64[20] = broadcast_in_dim[
                        broadcast_dimensions=()
                        shape=(20,)
                        sharding=None
                      ] vx
                      vv:f64[20] = select_n vu vq vy
                    in (vv,) }
                ] vu 1.0:f64[] vq
                vz:bool[20] = eq sd 1.0:f64[]
                wa:f64[20] = add sf 1.0:f64[]
                wb:f64[20] = mul 2.0:f64[] wa
                wc:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sg
                wd:f64[20] = add sf wc
                we:f64[20] = add wd 2.0:f64[]
                wf:f64[] = sub qj 1.0:f64[]
                wg:f64[20] = mul we wf
                wh:f64[20] = add wb wg
                wi:f64[20] = mul 0.5:f64[] wh
                wj:f64[20] = pjit[
                  name=_where
                  jaxpr={ lambda ; vz:bool[20] wi:f64[20] vv:f64[20]. let
                      wj:f64[20] = select_n vz vv wi
                    in (wj,) }
                ] vz wi vv
                wk:f64[20] = mul sb wj
                qh:f64[1,20] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 20)
                  sharding=None
                ] wk
              in (qh,) }
          ] bai baj bak bal 1:i64[]
        in (bam,) }
      jvp=_jacobi_jvp
      symbolic_zeros=False
    ] zw zt 0:i64[] baa
    ban:f64[20] = sub zt 1.0:f64[]
    bao:f64[20] = max ban 0.0:f64[]
    bap:f64[1,20] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 20)
      sharding=None
    ] bao
    baq:f64[1,20] = pow zp bap
    bar:f64[1,20] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 20)
      sharding=None
    ] zt
    bas:f64[1,20] = mul bar baq
    bat:f64[1,20] = mul bas bab
    bau:f64[20] = add zt 1.0:f64[]
    bav:f64[1,20] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 20)
      sharding=None
    ] bau
    baw:f64[1,20] = pow zp bav
    bax:f64[1,20] = mul 4.0:f64[] baw
    bay:f64[1,20] = mul bax bah
    baz:f64[1,20] = sub bat bay
    bba:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] zq
    bbb:f64[20] = sub bba zt
    bbc:f64[20] = pjit[
      name=remainder
      jaxpr={ lambda ; wn:f64[20] wp:i64[]. let
          wq:f64[] = convert_element_type[new_dtype=float64 weak_type=False] wp
          wr:f64[20] = rem wn wq
          ws:bool[20] = ne wr 0.0:f64[]
          wt:bool[20] = lt wr 0.0:f64[]
          wu:bool[] = lt wq 0.0:f64[]
          wv:bool[20] = ne wt wu
          ww:bool[20] = and wv ws
          wx:f64[20] = add wr wq
          wo:f64[20] = select_n ww wr wx
        in (wo,) }
    ] bbb 2:i64[]
    bbd:bool[20] = eq bbc 0.0:f64[]
    bbe:f64[1,20] = pjit[
      name=_where
      jaxpr={ lambda ; wy:bool[20] wl:f64[1,20] xa:f64[]. let
          xb:f64[] = convert_element_type[new_dtype=float64 weak_type=False] xa
          xc:bool[1,20] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 20)
            sharding=None
          ] wy
          xd:f64[1,20] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1, 20)
            sharding=None
          ] xb
          wz:f64[1,20] = select_n xc xd wl
        in (wz,) }
    ] bbd baz 0.0:f64[]
    bbf:f64[1,20] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 20)
      sharding=None
    ] zx
    bbg:f64[1,20] = mul bbf bbe
  in (bbg,) } in
let cross = { lambda ; bbh:f64[1,3] bbi:f64[1,3]. let
    bbj:f64[1,1] = slice[limit_indices=(1, 1) start_indices=(0, 0) strides=None] bbh
    bbk:f64[1] = squeeze[dimensions=(1,)] bbj
    bbl:f64[1,1] = slice[limit_indices=(1, 2) start_indices=(0, 1) strides=None] bbh
    bbm:f64[1] = squeeze[dimensions=(1,)] bbl
    bbn:f64[1,1] = slice[limit_indices=(1, 3) start_indices=(0, 2) strides=None] bbh
    bbo:f64[1] = squeeze[dimensions=(1,)] bbn
    bbp:f64[1,1] = slice[limit_indices=(1, 1) start_indices=(0, 0) strides=None] bbi
    bbq:f64[1] = squeeze[dimensions=(1,)] bbp
    bbr:f64[1,1] = slice[limit_indices=(1, 2) start_indices=(0, 1) strides=None] bbi
    bbs:f64[1] = squeeze[dimensions=(1,)] bbr
    bbt:f64[1,1] = slice[limit_indices=(1, 3) start_indices=(0, 2) strides=None] bbi
    bbu:f64[1] = squeeze[dimensions=(1,)] bbt
    bbv:f64[1] = mul bbm bbu
    bbw:f64[1] = mul bbo bbs
    bbx:f64[1] = sub bbv bbw
    bby:f64[1] = mul bbo bbq
    bbz:f64[1] = mul bbk bbu
    bca:f64[1] = sub bby bbz
    bcb:f64[1] = mul bbk bbs
    bcc:f64[1] = mul bbm bbq
    bcd:f64[1] = sub bcb bcc
    bce:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bbx
    bcf:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bca
    bcg:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bcd
    bch:f64[3,1] = concatenate[dimension=0] bce bcf bcg
    bci:f64[1,3] = transpose[permutation=(1, 0)] bch
  in (bci,) } in
let _where1 = { lambda ; bcj:bool[1] bck:i64[] bcl:f64[1]. let
    bcm:f64[] = convert_element_type[new_dtype=float64 weak_type=False] bck
    bcn:f64[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] bcm
    bco:f64[1] = select_n bcj bcl bcn
  in (bco,) } in
let nan_to_num = { lambda ; bcp:f64[1]. let
    bcq:bool[1] = ne bcp bcp
    bcr:f64[1] = pjit[
      name=_where
      jaxpr={ lambda ; bcq:bool[1] bcs:f64[] bcp:f64[1]. let
          bct:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] bcs
          bcr:f64[1] = select_n bcq bcp bct
        in (bcr,) }
    ] bcq 0.0:f64[] bcp
    bcu:bool[1] = eq bcr inf:f64[]
    bcv:f64[1] = pjit[
      name=_where
      jaxpr={ lambda ; bcq:bool[1] bcs:f64[] bcp:f64[1]. let
          bct:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] bcs
          bcr:f64[1] = select_n bcq bcp bct
        in (bcr,) }
    ] bcu 1.7976931348623157e+308:f64[] bcr
    bcw:bool[1] = eq bcv -inf:f64[]
    bcx:f64[1] = pjit[
      name=_where
      jaxpr={ lambda ; bcq:bool[1] bcs:f64[] bcp:f64[1]. let
          bct:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] bcs
          bcr:f64[1] = select_n bcq bcp bct
        in (bcr,) }
    ] bcw -1.7976931348623157e+308:f64[] bcv
  in (bcx,) } in
let interp1d = { lambda bcy:i64[4,4]; bcz:i64[] bda:bool[] bdb:f64[9] bdc:f64[9]
    bdd:f64[1]. let
    bde:f64[1] = pjit[
      name=atleast_1d
      jaxpr={ lambda ; bdd:f64[1]. let  in (bdd,) }
    ] bdd
    bdf:i32[1] = pjit[
      name=searchsorted
      jaxpr={ lambda ; bdc:f64[9] bde:f64[1]. let
          bdg:f64[] = squeeze[dimensions=(0,)] bde
          _:i32[] bdh:i32[] = scan[
            _split_transpose=False
            jaxpr={ lambda ; bdi:f64[9] bdj:f64[] bdk:i32[] bdl:i32[]. let
                bdm:u32[] = convert_element_type[
                  new_dtype=uint32
                  weak_type=False
                ] bdk
                bdn:u32[] = convert_element_type[
                  new_dtype=uint32
                  weak_type=False
                ] bdl
                bdo:u32[] = add bdm bdn
                bdp:u32[] = div bdo 2:u32[]
                bdq:i32[] = convert_element_type[
                  new_dtype=int32
                  weak_type=False
                ] bdp
                bdr:bool[] = lt bdq 0:i32[]
                bds:i32[] = add bdq 9:i32[]
                bdt:i32[] = select_n bdr bdq bds
                bdu:f64[1] = dynamic_slice[slice_sizes=(1,)] bdi bdt
                bdv:f64[] = squeeze[dimensions=(0,)] bdu
                bdw:bool[] = eq bdj 0.0:f64[]
                bdx:f64[] = select_n bdw bdj 0.0:f64[]
                bdy:bool[] = ne bdj bdj
                bdz:f64[] = select_n bdy bdx nan:f64[]
                bea:bool[] = eq bdv 0.0:f64[]
                beb:f64[] = select_n bea bdv 0.0:f64[]
                bec:bool[] = ne bdv bdv
                bed:f64[] = select_n bec beb nan:f64[]
                bee:bool[] = lt_to bdz bed
                bef:i32[] = pjit[
                  name=_where
                  jaxpr={ lambda ; bee:bool[] bdk:i32[] bdq:i32[]. let
                      bef:i32[] = select_n bee bdq bdk
                    in (bef,) }
                ] bee bdk bdq
                beg:i32[] = pjit[
                  name=_where
                  jaxpr={ lambda ; bee:bool[] bdk:i32[] bdq:i32[]. let
                      bef:i32[] = select_n bee bdq bdk
                    in (bef,) }
                ] bee bdq bdl
              in (bef, beg) }
            length=4
            linear=(False, False, False, False)
            num_carry=2
            num_consts=2
            reverse=False
            unroll=1
          ] bdc bdg 0:i32[] 9:i32[]
          bdf:i32[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] bdh
        in (bdf,) }
    ] bdc bde
    beh:i32[1] = pjit[
      name=clip
      jaxpr={ lambda ; bdf:i32[1] bei:i64[] bej:i64[]. let
          bek:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bei
          bel:i32[1] = max bek bdf
          bem:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bej
          beh:i32[1] = min bem bel
        in (beh,) }
    ] bdf 1:i64[] 8:i64[]
    _:i64[] ben:f64[9] = pjit[
      name=_cubic2
      jaxpr={ lambda ; bdc:f64[9] bdb:f64[9]. let
          beo:f64[8] = pjit[
            name=diff
            jaxpr={ lambda ; bdc:f64[9]. let
                bep:f64[8] = slice[
                  limit_indices=(9,)
                  start_indices=(1,)
                  strides=None
                ] bdc
                beq:f64[8] = slice[
                  limit_indices=(8,)
                  start_indices=(0,)
                  strides=None
                ] bdc
                beo:f64[8] = sub bep beq
              in (beo,) }
          ] bdc
          ber:f64[8] = pjit[
            name=diff
            jaxpr={ lambda ; bdb:f64[9]. let
                bes:f64[8] = slice[
                  limit_indices=(9,)
                  start_indices=(1,)
                  strides=None
                ] bdb
                bet:f64[8] = slice[
                  limit_indices=(8,)
                  start_indices=(0,)
                  strides=None
                ] bdb
                ber:f64[8] = sub bes bet
              in (ber,) }
          ] bdb
          beu:bool[8] = eq beo 0.0:f64[]
          bev:bool[8] = eq beo 0.0:f64[]
          bew:f64[8] = pjit[
            name=_where
            jaxpr={ lambda ; bev:bool[8] bex:i64[] beo:f64[8]. let
                bey:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] bex
                bez:f64[8] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(8,)
                  sharding=None
                ] bey
                bew:f64[8] = select_n bev beo bez
              in (bew,) }
          ] bev 1:i64[] beo
          bfa:f64[8] = div 1.0:f64[] bew
          bfb:f64[8] = pjit[
            name=_where
            jaxpr={ lambda ; bev:bool[8] bex:i64[] beo:f64[8]. let
                bey:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] bex
                bez:f64[8] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(8,)
                  sharding=None
                ] bey
                bew:f64[8] = select_n bev beo bez
              in (bew,) }
          ] beu 0:i64[] bfa
          bfc:f64[8] = mul bfb ber
          bfd:f64[9] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(9,)
            sharding=None
          ] 0.0:f64[]
          bfe:f64[7] = slice[limit_indices=(7,) start_indices=(0,) strides=None] beo
          bff:f64[7] = slice[limit_indices=(8,) start_indices=(1,) strides=None] beo
          bfg:f64[7] = add bfe bff
          bfh:f64[7] = mul 2.0:f64[] bfg
          bfi:i32[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 1:i32[]
          bfj:f64[9] = scatter[
            dimension_numbers=ScatterDimensionNumbers(update_window_dims=(0,), inserted_window_dims=(), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
            indices_are_sorted=True
            mode=GatherScatterMode.FILL_OR_DROP
            unique_indices=True
            update_consts=()
            update_jaxpr=None
          ] bfd bfi bfh
          bfk:f64[8] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(8,)
            sharding=None
          ] 0.0:f64[]
          bfl:f64[7] = slice[limit_indices=(7,) start_indices=(0,) strides=None] beo
          bfm:i32[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 1:i32[]
          bfn:f64[8] = scatter[
            dimension_numbers=ScatterDimensionNumbers(update_window_dims=(0,), inserted_window_dims=(), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
            indices_are_sorted=True
            mode=GatherScatterMode.FILL_OR_DROP
            unique_indices=True
            update_consts=()
            update_jaxpr=None
          ] bfk bfm bfl
          bfo:f64[8] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(8,)
            sharding=None
          ] 0.0:f64[]
          bfp:f64[7] = slice[limit_indices=(8,) start_indices=(1,) strides=None] beo
          bfq:i32[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 0:i32[]
          bfr:f64[8] = scatter[
            dimension_numbers=ScatterDimensionNumbers(update_window_dims=(0,), inserted_window_dims=(), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
            indices_are_sorted=True
            mode=GatherScatterMode.FILL_OR_DROP
            unique_indices=True
            update_consts=()
            update_jaxpr=None
          ] bfo bfq bfp
          bfs:f64[9] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(9,)
            sharding=None
          ] 0.0:f64[]
          bft:f64[7] = slice[limit_indices=(8,) start_indices=(1,) strides=None] beo
          bfu:f64[7] = slice[limit_indices=(7,) start_indices=(0,) strides=None] bfc
          bfv:f64[7] = mul bft bfu
          bfw:f64[7] = slice[limit_indices=(7,) start_indices=(0,) strides=None] beo
          bfx:f64[7] = slice[limit_indices=(8,) start_indices=(1,) strides=None] bfc
          bfy:f64[7] = mul bfw bfx
          bfz:f64[7] = add bfv bfy
          bga:f64[7] = mul 3.0:f64[] bfz
          bgb:i32[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 1:i32[]
          bgc:f64[9] = scatter[
            dimension_numbers=ScatterDimensionNumbers(update_window_dims=(0,), inserted_window_dims=(), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
            indices_are_sorted=True
            mode=GatherScatterMode.FILL_OR_DROP
            unique_indices=True
            update_consts=()
            update_jaxpr=None
          ] bfs bgb bga
          bgd:f64[1] = slice[limit_indices=(3,) start_indices=(2,) strides=None] bdc
          bge:f64[] = squeeze[dimensions=(0,)] bgd
          bgf:f64[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] bdc
          bgg:f64[] = squeeze[dimensions=(0,)] bgf
          bgh:f64[] = sub bge bgg
          bgi:f64[1] = slice[limit_indices=(2,) start_indices=(1,) strides=None] beo
          bgj:f64[] = squeeze[dimensions=(0,)] bgi
          bgk:i32[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 0:i32[]
          bgl:f64[9] = scatter[
            dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
            indices_are_sorted=True
            mode=GatherScatterMode.FILL_OR_DROP
            unique_indices=True
            update_consts=()
            update_jaxpr=None
          ] bfj bgk bgj
          bgm:i32[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 0:i32[]
          bgn:f64[8] = scatter[
            dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
            indices_are_sorted=True
            mode=GatherScatterMode.FILL_OR_DROP
            unique_indices=True
            update_consts=()
            update_jaxpr=None
          ] bfn bgm bgh
          bgo:f64[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] beo
          bgp:f64[] = squeeze[dimensions=(0,)] bgo
          bgq:f64[] = mul 2.0:f64[] bgh
          bgr:f64[] = add bgp bgq
          bgs:f64[1] = slice[limit_indices=(2,) start_indices=(1,) strides=None] beo
          bgt:f64[] = squeeze[dimensions=(0,)] bgs
          bgu:f64[] = mul bgr bgt
          bgv:f64[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] bfc
          bgw:f64[] = squeeze[dimensions=(0,)] bgv
          bgx:f64[] = mul bgu bgw
          bgy:f64[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] beo
          bgz:f64[] = squeeze[dimensions=(0,)] bgy
          bha:f64[] = integer_pow[y=2] bgz
          bhb:f64[1] = slice[limit_indices=(2,) start_indices=(1,) strides=None] bfc
          bhc:f64[] = squeeze[dimensions=(0,)] bhb
          bhd:f64[] = mul bha bhc
          bhe:f64[] = add bgx bhd
          bhf:f64[] = div bhe bgh
          bhg:i32[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 0:i32[]
          bhh:f64[9] = scatter[
            dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
            indices_are_sorted=True
            mode=GatherScatterMode.FILL_OR_DROP
            unique_indices=True
            update_consts=()
            update_jaxpr=None
          ] bgc bhg bhf
          bhi:f64[1] = dynamic_slice[slice_sizes=(1,)] bdc 8:i64[]
          bhj:f64[] = squeeze[dimensions=(0,)] bhi
          bhk:f64[1] = dynamic_slice[slice_sizes=(1,)] bdc 6:i64[]
          bhl:f64[] = squeeze[dimensions=(0,)] bhk
          bhm:f64[] = sub bhj bhl
          bhn:f64[1] = dynamic_slice[slice_sizes=(1,)] beo 6:i64[]
          bho:f64[] = squeeze[dimensions=(0,)] bhn
          bhp:i64[] = add -1:i64[] 9:i64[]
          bhq:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bhp
          bhr:i32[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] bhq
          bhs:f64[9] = scatter[
            dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
            indices_are_sorted=True
            mode=GatherScatterMode.FILL_OR_DROP
            unique_indices=True
            update_consts=()
            update_jaxpr=None
          ] bgl bhr bho
          bht:i64[] = add -1:i64[] 8:i64[]
          bhu:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bht
          bhv:i32[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] bhu
          bhw:f64[8] = scatter[
            dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
            indices_are_sorted=True
            mode=GatherScatterMode.FILL_OR_DROP
            unique_indices=True
            update_consts=()
            update_jaxpr=None
          ] bfr bhv bhm
          bhx:f64[1] = dynamic_slice[slice_sizes=(1,)] beo 7:i64[]
          bhy:f64[] = squeeze[dimensions=(0,)] bhx
          bhz:f64[] = integer_pow[y=2] bhy
          bia:f64[1] = dynamic_slice[slice_sizes=(1,)] bfc 6:i64[]
          bib:f64[] = squeeze[dimensions=(0,)] bia
          bic:f64[] = mul bhz bib
          bid:f64[] = mul 2.0:f64[] bhm
          bie:f64[1] = dynamic_slice[slice_sizes=(1,)] beo 7:i64[]
          bif:f64[] = squeeze[dimensions=(0,)] bie
          big:f64[] = add bid bif
          bih:f64[1] = dynamic_slice[slice_sizes=(1,)] beo 6:i64[]
          bii:f64[] = squeeze[dimensions=(0,)] bih
          bij:f64[] = mul big bii
          bik:f64[1] = dynamic_slice[slice_sizes=(1,)] bfc 7:i64[]
          bil:f64[] = squeeze[dimensions=(0,)] bik
          bim:f64[] = mul bij bil
          bin:f64[] = add bic bim
          bio:f64[] = div bin bhm
          bip:i64[] = add -1:i64[] 9:i64[]
          biq:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bip
          bir:i32[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] biq
          bis:f64[9] = scatter[
            dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
            indices_are_sorted=True
            mode=GatherScatterMode.FILL_OR_DROP
            unique_indices=True
            update_consts=()
            update_jaxpr=None
          ] bhh bir bio
          bit:bool[9] = eq bhs 0.0:f64[]
          biu:f64[9] = pjit[
            name=_where
            jaxpr={ lambda ; bit:bool[9] biv:i64[] bhs:f64[9]. let
                biw:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] biv
                bix:f64[9] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(9,)
                  sharding=None
                ] biw
                biu:f64[9] = select_n bit bhs bix
              in (biu,) }
          ] bit 1:i64[] bhs
          biy:bool[8] = slice[
            limit_indices=(9,)
            start_indices=(1,)
            strides=None
          ] bit
          biz:f64[8] = pjit[
            name=_where
            jaxpr={ lambda ; bev:bool[8] bex:i64[] beo:f64[8]. let
                bey:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] bex
                bez:f64[8] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(8,)
                  sharding=None
                ] bey
                bew:f64[8] = select_n bev beo bez
              in (bew,) }
          ] biy 0:i64[] bhw
          bja:bool[8] = slice[
            limit_indices=(8,)
            start_indices=(0,)
            strides=None
          ] bit
          bjb:f64[8] = pjit[
            name=_where
            jaxpr={ lambda ; bev:bool[8] bex:i64[] beo:f64[8]. let
                bey:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] bex
                bez:f64[8] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(8,)
                  sharding=None
                ] bey
                bew:f64[8] = select_n bev beo bez
              in (bew,) }
          ] bja 0:i64[] bgn
          bjc:f64[9] = pjit[
            name=_where
            jaxpr={ lambda ; bit:bool[9] biv:i64[] bhs:f64[9]. let
                biw:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] biv
                bix:f64[9] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(9,)
                  sharding=None
                ] biw
                biu:f64[9] = select_n bit bhs bix
              in (biu,) }
          ] bit 0:i64[] bis
          bjd:f64[9] = custom_jvp_call[
            name=_asarray
            call_jaxpr={ lambda ; bje:f64[9]. let  in (bje,) }
            jvp=_asarray_jvp
            symbolic_zeros=False
          ] biu
          bjf:f64[8] = custom_jvp_call[
            name=_asarray
            call_jaxpr={ lambda ; bjg:f64[8]. let  in (bjg,) }
            jvp=_asarray_jvp
            symbolic_zeros=False
          ] biz
          bjh:f64[8] = custom_jvp_call[
            name=_asarray
            call_jaxpr={ lambda ; bji:f64[8]. let  in (bji,) }
            jvp=_asarray_jvp
            symbolic_zeros=False
          ] bjb
          _:i64[] ben:f64[9] _:i32[] _:f64[9] _:f64[8] _:f64[8] = pjit[
            name=linear_solve
            jaxpr={ lambda ; bjd:f64[9] bjf:f64[8] bjh:f64[8] bjc:f64[9]. let
                bjj:f64[9] = custom_jvp_call[
                  name=_asarray
                  call_jaxpr={ lambda ; bjk:f64[9]. let  in (bjk,) }
                  jvp=_asarray_jvp
                  symbolic_zeros=False
                ] bjc
                bjl:f64[9] = stop_gradient bjd
                bjm:f64[8] = stop_gradient bjf
                bjn:f64[8] = stop_gradient bjh
                _:f64[9] _:f64[8] _:f64[8] = custom_jvp_call[
                  name=_nondifferentiable
                  call_jaxpr={ lambda ; bjo:f64[9] bjp:f64[8] bjq:f64[8]. let
                      
                    in (bjo, bjp, bjq) }
                  jvp=_nondifferentiable_jvp
                  symbolic_zeros=False
                ] bjl bjm bjn
                custom_jvp_call[
                  name=_nondifferentiable
                  call_jaxpr={ lambda ; . let  in () }
                  jvp=_nondifferentiable_jvp
                  symbolic_zeros=False
                ] 
                custom_jvp_call[
                  name=_nondifferentiable
                  call_jaxpr={ lambda ; . let  in () }
                  jvp=_nondifferentiable_jvp
                  symbolic_zeros=False
                ] 
                ben:f64[9] _:i32[] = linear_solve[
                  flatten=<equinox.internal._primitive.Flatten object at 0x7f2ebc792710>
                  static=(<object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, True)
                  treedef=PyTreeDef((CustomNode(TridiagonalLinearOperator[('diagonal', 'lower_diagonal', 'upper_diagonal'), ()], [*, *, *]), ((*, *, *), CustomNode(Static[(), (('_leaves', [ShapeDtypeStruct(shape=(9,), dtype=float64), ShapeDtypeStruct(shape=(9,), dtype=float64), PyTreeDef((*, *))]), ('_treedef', PyTreeDef(([*, *], *))))], [])), *, {}, CustomNode(Tridiagonal[(), ()], []), *))
                ] bjd bjf bjh _ _ _ bjj
              in (0:i64[], ben, _, _, _, _) }
          ] bjd bjf bjh bjc
        in (0:i64[], ben) }
    ] bdc bdb
    bjr:bool[1] = lt beh 0:i32[]
    bjs:i32[1] = add beh 9:i32[]
    bjt:i32[1] = select_n bjr beh bjs
    bju:i32[1,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(1, 1)
      sharding=None
    ] bjt
    bjv:f64[1] = gather[
      dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
      fill_value=None
      indices_are_sorted=False
      mode=GatherScatterMode.PROMISE_IN_BOUNDS
      slice_sizes=(1,)
      unique_indices=False
    ] bdc bju
    bjw:i32[1] = sub beh 1:i32[]
    bjx:bool[1] = lt bjw 0:i32[]
    bjy:i32[1] = add bjw 9:i32[]
    bjz:i32[1] = select_n bjx bjw bjy
    bka:i32[1,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(1, 1)
      sharding=None
    ] bjz
    bkb:f64[1] = gather[
      dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
      fill_value=None
      indices_are_sorted=False
      mode=GatherScatterMode.PROMISE_IN_BOUNDS
      slice_sizes=(1,)
      unique_indices=False
    ] bdc bka
    bkc:f64[1] = sub bjv bkb
    bkd:i32[1] = sub beh 1:i32[]
    bke:bool[1] = lt bkd 0:i32[]
    bkf:i32[1] = add bkd 9:i32[]
    bkg:i32[1] = select_n bke bkd bkf
    bkh:i32[1,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(1, 1)
      sharding=None
    ] bkg
    bki:f64[1] = gather[
      dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
      fill_value=None
      indices_are_sorted=False
      mode=GatherScatterMode.PROMISE_IN_BOUNDS
      slice_sizes=(1,)
      unique_indices=False
    ] bdc bkh
    bkj:f64[1] = sub bde bki
    bkk:bool[1] = eq bkc 0.0:f64[]
    bkl:f64[1] = div 1.0:f64[] bkc
    bkm:f64[1] = pjit[name=_where jaxpr=_where1] bkk 0:i64[] bkl
    bkn:f64[1] = mul bkj bkm
    bko:i32[1] = sub beh 1:i32[]
    bkp:f64[1] = pjit[
      name=_take
      jaxpr={ lambda ; bdb:f64[9] bko:i32[1]. let
          bkq:bool[1] = lt bko 0:i32[]
          bkr:i32[1] = add bko 9:i32[]
          bks:i32[1] = pjit[
            name=_where
            jaxpr={ lambda ; bkq:bool[1] bkr:i32[1] bko:i32[1]. let
                bks:i32[1] = select_n bkq bko bkr
              in (bks,) }
          ] bkq bkr bko
          bkt:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] bks
          bkp:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=nan
            indices_are_sorted=False
            mode=GatherScatterMode.FILL_OR_DROP
            slice_sizes=(1,)
            unique_indices=False
          ] bdb bkt
        in (bkp,) }
    ] bdb bko
    bku:f64[1] = pjit[
      name=_take
      jaxpr={ lambda ; bdb:f64[9] bko:i32[1]. let
          bkq:bool[1] = lt bko 0:i32[]
          bkr:i32[1] = add bko 9:i32[]
          bks:i32[1] = pjit[
            name=_where
            jaxpr={ lambda ; bkq:bool[1] bkr:i32[1] bko:i32[1]. let
                bks:i32[1] = select_n bkq bko bkr
              in (bks,) }
          ] bkq bkr bko
          bkt:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] bks
          bkp:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=nan
            indices_are_sorted=False
            mode=GatherScatterMode.FILL_OR_DROP
            slice_sizes=(1,)
            unique_indices=False
          ] bdb bkt
        in (bkp,) }
    ] bdb beh
    bkv:i32[1] = sub beh 1:i32[]
    bkw:f64[1] = pjit[
      name=_take
      jaxpr={ lambda ; bdb:f64[9] bko:i32[1]. let
          bkq:bool[1] = lt bko 0:i32[]
          bkr:i32[1] = add bko 9:i32[]
          bks:i32[1] = pjit[
            name=_where
            jaxpr={ lambda ; bkq:bool[1] bkr:i32[1] bko:i32[1]. let
                bks:i32[1] = select_n bkq bko bkr
              in (bks,) }
          ] bkq bkr bko
          bkt:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] bks
          bkp:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=nan
            indices_are_sorted=False
            mode=GatherScatterMode.FILL_OR_DROP
            slice_sizes=(1,)
            unique_indices=False
          ] bdb bkt
        in (bkp,) }
    ] ben bkv
    bkx:f64[1] = mul bkw bkc
    bky:f64[1] = pjit[
      name=_take
      jaxpr={ lambda ; bdb:f64[9] bko:i32[1]. let
          bkq:bool[1] = lt bko 0:i32[]
          bkr:i32[1] = add bko 9:i32[]
          bks:i32[1] = pjit[
            name=_where
            jaxpr={ lambda ; bkq:bool[1] bkr:i32[1] bko:i32[1]. let
                bks:i32[1] = select_n bkq bko bkr
              in (bks,) }
          ] bkq bkr bko
          bkt:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] bks
          bkp:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=nan
            indices_are_sorted=False
            mode=GatherScatterMode.FILL_OR_DROP
            slice_sizes=(1,)
            unique_indices=False
          ] bdb bkt
        in (bkp,) }
    ] ben beh
    bkz:f64[1] = mul bky bkc
    bla:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bkp
    blb:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bku
    blc:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bkx
    bld:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bkz
    ble:f64[4,1] = concatenate[dimension=0] bla blb blc bld
    blf:f64[1,4] = transpose[permutation=(1, 0)] ble
    blg:i64[4,4] = device_put[
      copy_semantics=(<CopySemantics.ALIAS: 1>,)
      devices=(None,)
      srcs=(None,)
    ] bcy
    blh:f64[4] = squeeze[dimensions=(0,)] blf
    bli:f64[4] = dot_general[
      dimension_numbers=(([1], [0]), ([], []))
      preferred_element_type=float64
    ] blg blh
    blj:f64[1,4] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 4)
      sharding=None
    ] bli
    blk:f64[4,1] = transpose[permutation=(1, 0)] blj
    bll:f64[1,4] = pjit[
      name=_get_t_der
      jaxpr={ lambda ; bkn:f64[1] bcz:i64[] bkm:f64[1]. let
          blm:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 0.0:f64[]
          bln:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 1.0:f64[]
          blo:f64[1] = pjit[
            name=atleast_1d
            jaxpr={ lambda ; bdd:f64[1]. let  in (bdd,) }
          ] bkm
          blp:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] blo
          blq:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bcz
          blr:i32[] = clamp 0:i32[] blq 4:i32[]
          bll:f64[1,4] = cond[
            branches=(
              { lambda ; bls:f64[1] blt:f64[1] blu:f64[1,1] blv:f64[1]. let
                  blw:f64[1] = integer_pow[y=2] bls
                  blx:f64[1] = integer_pow[y=3] bls
                  bly:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] blt
                  blz:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bls
                  bma:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] blw
                  bmb:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] blx
                  bmc:f64[4,1] = concatenate[dimension=0] bly blz bma bmb
                  bmd:f64[1,4] = transpose[permutation=(1, 0)] bmc
                  bme:f64[1,1] = integer_pow[y=0] blu
                  bmf:f64[1,4] = mul bmd bme
                in (bmf,) }
              { lambda ; bmg:f64[1] bmh:f64[1] bmi:f64[1,1] bmj:f64[1]. let
                  bmk:f64[1] = mul 2.0:f64[] bmg
                  bml:f64[1] = integer_pow[y=2] bmg
                  bmm:f64[1] = mul 3.0:f64[] bml
                  bmn:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bmj
                  bmo:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bmh
                  bmp:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bmk
                  bmq:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bmm
                  bmr:f64[4,1] = concatenate[dimension=0] bmn bmo bmp bmq
                  bms:f64[1,4] = transpose[permutation=(1, 0)] bmr
                  bmt:f64[1,4] = mul bms bmi
                in (bmt,) }
              { lambda ; bmu:f64[1] bmv:f64[1] bmw:f64[1,1] bmx:f64[1]. let
                  bmy:f64[1] = mul 2.0:f64[] bmv
                  bmz:f64[1] = mul 6.0:f64[] bmu
                  bna:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bmx
                  bnb:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bmx
                  bnc:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bmy
                  bnd:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bmz
                  bne:f64[4,1] = concatenate[dimension=0] bna bnb bnc bnd
                  bnf:f64[1,4] = transpose[permutation=(1, 0)] bne
                  bng:f64[1,1] = integer_pow[y=2] bmw
                  bnh:f64[1,4] = mul bnf bng
                in (bnh,) }
              { lambda ; bni:f64[1] bnj:f64[1] bnk:f64[1,1] bnl:f64[1]. let
                  bnm:f64[1] = mul 6.0:f64[] bnj
                  bnn:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bnl
                  bno:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bnl
                  bnp:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bnl
                  bnq:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bnm
                  bnr:f64[4,1] = concatenate[dimension=0] bnn bno bnp bnq
                  bns:f64[1,4] = transpose[permutation=(1, 0)] bnr
                  bnt:f64[1,1] = integer_pow[y=3] bnk
                  bnu:f64[1,4] = mul bns bnt
                in (bnu,) }
              { lambda ; bnv:f64[1] bnw:f64[1] bnx:f64[1,1] bny:f64[1]. let
                  bnz:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bny
                  boa:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bny
                  bob:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bny
                  boc:f64[1,1] = broadcast_in_dim[
                    broadcast_dimensions=(1,)
                    shape=(1, 1)
                    sharding=None
                  ] bny
                  bod:f64[4,1] = concatenate[dimension=0] bnz boa bob boc
                  boe:f64[1,4] = transpose[permutation=(1, 0)] bod
                  bof:f64[1,1] = mul bnx 0.0:f64[]
                  bog:f64[1,4] = mul boe bof
                in (bog,) }
            )
          ] blr bkn bln blp blm
        in (bll,) }
    ] bkn bcz bkm
    boh:f64[1] = dot_general[
      dimension_numbers=(([0], [1]), ([1], [0]))
      preferred_element_type=float64
    ] blk bll
    boi:f64[1] = pjit[
      name=_extrap
      jaxpr={ lambda ; bde:f64[1] boh:f64[1] bdc:f64[9] bda:bool[] boj:bool[]. let
          bok:bool[] = and True:bool[] bda
          bol:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bok
          bom:f64[1] = cond[
            branches=(
              { lambda ; bon:f64[9] boo:f64[1] bop:f64[1] boq:bool[]. let
                  bor:f64[1] = slice[
                    limit_indices=(1,)
                    start_indices=(0,)
                    strides=None
                  ] bon
                  bos:f64[] = squeeze[dimensions=(0,)] bor
                  bot:bool[1] = lt boo bos
                  bou:f64[1] = pjit[name=_where jaxpr=_where] bot nan:f64[] bop
                in (bou,) }
              { lambda ; bov:f64[9] bow:f64[1] box:f64[1] boy:bool[]. let
                  
                in (box,) }
            )
          ] bol bdc bde boh bda
          boz:bool[] = and True:bool[] boj
          bpa:i32[] = convert_element_type[new_dtype=int32 weak_type=False] boz
          boi:f64[1] = cond[
            branches=(
              { lambda ; bpb:f64[9] bpc:f64[1] bpd:f64[1] bpe:bool[]. let
                  bpf:f64[1] = dynamic_slice[slice_sizes=(1,)] bpb 8:i64[]
                  bpg:f64[] = squeeze[dimensions=(0,)] bpf
                  bph:bool[1] = gt bpc bpg
                  bpi:f64[1] = pjit[name=_where jaxpr=_where] bph nan:f64[] bpd
                in (bpi,) }
              { lambda ; bov:f64[9] bow:f64[1] box:f64[1] boy:bool[]. let
                  
                in (box,) }
            )
          ] bpa bdc bde bom boj
        in (boi,) }
    ] bde boh bdc bda bda
  in (boi,) } in
let floor_divide = { lambda ; q:f64[25] s:i64[]. let
    t:f64[] = convert_element_type[new_dtype=float64 weak_type=False] s
    u:f64[25] = rem q t
    v:f64[25] = sub q u
    w:f64[25] = div v t
    x:bool[25] = ne u 0.0:f64[]
    y:f64[] = sign t
    z:f64[25] = sign u
    ba:bool[25] = ne y z
    bb:bool[25] = and x ba
    bc:f64[25] = add u t
    _:f64[25] = select_n bb u bc
    bd:f64[25] = sub w 1.0:f64[]
    be:f64[25] = select_n bb w bd
    r:f64[25] = round[rounding_method=0] be
  in (r,) } in
let jaxpr = { lambda ; bm:f64[25] bn:f64[25] bo:i64[] bp:f64[1,1]. let
    bq:f64[1,25] = pjit[
      name=_jacobi
      jaxpr={ lambda ; bm:f64[25] bn:f64[25] bo:i64[] bp:f64[1,1] br:i64[]. let
          bs:f64[] = squeeze[dimensions=(0, 1)] bp
          bt:f64[25] = add bn bm
          bu:f64[25] = add bt 1.0:f64[]
          bv:f64[25] = div bu 2.0:f64[]
          bw:f64[25] = add bn bm
          bx:f64[25] = add bw 2.0:f64[]
          by:f64[25] = add bn bm
          bz:f64[25] = add by 1.0:f64[]
          ca:f64[25] = mul bx bz
          cb:f64[25] = div ca 4.0:f64[]
          cc:f64[25] = add bn bm
          cd:f64[25] = add cc 3.0:f64[]
          ce:f64[25] = add bn bm
          cf:f64[25] = add ce 2.0:f64[]
          cg:f64[25] = mul cd cf
          ch:f64[25] = add bn bm
          ci:f64[25] = add ch 1.0:f64[]
          cj:f64[25] = mul cg ci
          ck:f64[25] = div cj 8.0:f64[]
          cl:f64[25] = add bn bm
          cm:f64[25] = add cl 4.0:f64[]
          cn:f64[25] = add bn bm
          co:f64[25] = add cn 3.0:f64[]
          cp:f64[25] = mul cm co
          cq:f64[25] = add bn bm
          cr:f64[25] = add cq 2.0:f64[]
          cs:f64[25] = mul cp cr
          ct:f64[25] = add bn bm
          cu:f64[25] = add ct 1.0:f64[]
          cv:f64[25] = mul cs cu
          cw:f64[25] = div cv 16.0:f64[]
          cx:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 1.0:f64[]
          cy:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] bv
          cz:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cb
          da:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] ck
          db:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cw
          dc:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(25, 1)
            sharding=None
          ] cx
          dd:f64[25,5] = concatenate[dimension=1] dc cy cz da db
          de:bool[] = lt br 0:i64[]
          df:i64[] = convert_element_type[new_dtype=int64 weak_type=False] br
          dg:i64[] = add df 5:i64[]
          dh:i64[] = select_n de br dg
          di:i64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] dh
          dj:f64[25,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=True
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(25, 1)
            unique_indices=True
          ] dd di
          dk:f64[25] = squeeze[dimensions=(1,)] dj
          dl:f64[] = convert_element_type[new_dtype=float64 weak_type=False] br
          dm:f64[25] = sub bm dl
          dn:f64[] = convert_element_type[new_dtype=float64 weak_type=False] br
          do:f64[25] = add bn dn
          dp:i64[] = add bo br
          dq:f64[] = convert_element_type[new_dtype=float64 weak_type=False] dp
          dr:f64[25] = add do dq
          ds:f64[25] = add dr 2.0:f64[]
          dt:f64[] = sub bs 1.0:f64[]
          du:f64[25] = mul ds dt
          dv:f64[25] = add do 1.0:f64[]
          dw:f64[25] = mul 2.0:f64[] dv
          dx:f64[25] = div du dw
          dy:f64[25] = add dx 1.0:f64[]
          dz:f64[25] = sub dm 1.0:f64[]
          ea:f64[25] = max dz 0.0:f64[]
          eb:i64[25] = convert_element_type[new_dtype=int64 weak_type=False] ea
          ec:i64[25] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(25,)
            sharding=None
          ] 0:i64[]
          _:i64[25] _:i64[25] _:f64[25] ed:f64[25] = while[
            body_jaxpr={ lambda ; ee:f64[25] ef:i64[] eg:f64[] eh:i64[25] ei:i64[25]
                ej:f64[25] ek:f64[25]. let
                el:i64[25] = add eh 1:i64[]
                em:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] eh
                en:f64[25] = add em 1.0:f64[]
                eo:f64[25] = mul 2.0:f64[] en
                ep:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] eo
                eq:f64[25] = add ep ee
                er:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] ef
                es:f64[25] = add eq er
                et:f64[25] = add es 1.0:f64[]
                eu:f64[25] = mul es et
                ev:f64[25] = add es 2.0:f64[]
                ew:f64[25] = mul eu ev
                ex:f64[] = sub eg 1.0:f64[]
                ey:f64[25] = mul ew ex
                ez:f64[25] = mul ey ek
                fa:f64[25] = mul 2.0:f64[] en
                fb:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] ef
                fc:f64[25] = add en fb
                fd:f64[25] = mul fa fc
                fe:f64[25] = add es 2.0:f64[]
                ff:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] fd
                fg:f64[25] = mul ff fe
                fh:f64[25] = mul fg ej
                fi:f64[25] = add ez fh
                fj:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] en
                fk:f64[25] = add fj ee
                fl:f64[25] = add fk 1.0:f64[]
                fm:f64[25] = mul 2.0:f64[] fl
                fn:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] en
                fo:f64[25] = add fn ee
                fp:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] ef
                fq:f64[25] = add fo fp
                fr:f64[25] = add fq 1.0:f64[]
                fs:f64[25] = mul fm fr
                ft:f64[25] = mul fs es
                fu:f64[25] = div fi ft
                fv:f64[25] = add fu ek
              in (el, ei, fu, fv) }
            body_nconsts=3
            cond_jaxpr={ lambda ; fw:i64[25] fx:i64[25] fy:f64[25] fz:f64[25]. let
                ga:bool[25] = lt fw fx
              in (ga,) }
            cond_nconsts=0
          ] do dp bs ec eb dx dy
          gb:f64[25] = add dm do
          gc:f64[25] = pjit[
            name=_binom
            jaxpr={ lambda ; gb:f64[25] dm:f64[25]. let
                gd:i64[25] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] dm
                ge:i64[25] = add 1:i64[] gd
                gf:i64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] 1:i64[]
                gg:f64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] 1.0:f64[]
                _:i64[25] _:i64[25] gc:f64[25] = while[
                  body_jaxpr={ lambda ; gh:f64[25] gi:i64[25] gj:i64[25] gk:f64[25]. let
                      gl:i64[25] = add gi 1:i64[]
                      gm:f64[25] = add gh 1.0:f64[]
                      gn:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] gi
                      go:f64[25] = sub gm gn
                      gp:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] gk
                      gq:f64[25] = mul gp go
                      gr:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] gi
                      gs:f64[25] = div gq gr
                    in (gl, gj, gs) }
                  body_nconsts=1
                  cond_jaxpr={ lambda ; gt:i64[25] gu:i64[25] gv:f64[25]. let
                      gw:bool[25] = lt gt gu
                    in (gw,) }
                  cond_nconsts=0
                ] gb gf ge gg
              in (gc,) }
          ] gb dm
          gx:f64[25] = mul gc ed
          gy:bool[25] = lt dm 0.0:f64[]
          gz:f64[25] = pjit[
            name=_where
            jaxpr={ lambda ; gy:bool[25] ha:i64[] gx:f64[25]. let
                hb:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] ha
                hc:f64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] hb
                gz:f64[25] = select_n gy gx hc
              in (gz,) }
          ] gy 0:i64[] gx
          hd:bool[25] = eq dm 0.0:f64[]
          he:f64[25] = pjit[
            name=_where
            jaxpr={ lambda ; hd:bool[25] hf:f64[] gz:f64[25]. let
                hg:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] hf
                hh:f64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] hg
                he:f64[25] = select_n hd gz hh
              in (he,) }
          ] hd 1.0:f64[] gz
          hi:bool[25] = eq dm 1.0:f64[]
          hj:f64[25] = add do 1.0:f64[]
          hk:f64[25] = mul 2.0:f64[] hj
          hl:f64[] = convert_element_type[new_dtype=float64 weak_type=False] dp
          hm:f64[25] = add do hl
          hn:f64[25] = add hm 2.0:f64[]
          ho:f64[] = sub bs 1.0:f64[]
          hp:f64[25] = mul hn ho
          hq:f64[25] = add hk hp
          hr:f64[25] = mul 0.5:f64[] hq
          hs:f64[25] = pjit[
            name=_where
            jaxpr={ lambda ; hi:bool[25] hr:f64[25] he:f64[25]. let
                hs:f64[25] = select_n hi he hr
              in (hs,) }
          ] hi hr he
          ht:f64[25] = mul dk hs
          bq:f64[1,25] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 25)
            sharding=None
          ] ht
        in (bq,) }
    ] bm bn bo bp 0:i64[]
  in (bq,) } in
let remainder = { lambda ; hw:f64[25] hy:i64[]. let
    hz:f64[] = convert_element_type[new_dtype=float64 weak_type=False] hy
    ia:f64[25] = rem hw hz
    ib:bool[25] = ne ia 0.0:f64[]
    ic:bool[25] = lt ia 0.0:f64[]
    id:bool[] = lt hz 0.0:f64[]
    ie:bool[25] = ne ic id
    if:bool[25] = and ie ib
    ig:f64[25] = add ia hz
    hx:f64[25] = select_n if ia ig
  in (hx,) } in
let _where2 = { lambda ; ih:bool[25] hu:f64[1,25] ij:f64[]. let
    ik:f64[] = convert_element_type[new_dtype=float64 weak_type=False] ij
    il:bool[1,25] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 25)
      sharding=None
    ] ih
    im:f64[1,25] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1, 25)
      sharding=None
    ] ik
    ii:f64[1,25] = select_n il im hu
  in (ii,) } in
let _where3 = { lambda ; jf:bool[9] jh:i64[] ji:i64[]. let
    jj:i64[9] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(9,)
      sharding=None
    ] jh
    jk:i64[9] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(9,)
      sharding=None
    ] ji
    jg:i64[9] = select_n jf jk jj
  in (jg,) } in
let _where4 = { lambda ; jl:i64[] jm:i64[9] jg:i64[9]. let
    jo:bool[] = ne jl 0:i64[]
    jn:i64[9] = select_n jo jg jm
  in (jn,) } in
let _where5 = { lambda ; lq:bool[1] ls:i64[] lt:i64[]. let
    lu:i64[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] ls
    lv:i64[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] lt
    lr:i64[1] = select_n lq lv lu
  in (lr,) } in
let _where6 = { lambda ; lw:i64[] lx:i64[1] lr:i64[1]. let
    lz:bool[] = ne lw 0:i64[]
    ly:i64[1] = select_n lz lr lx
  in (ly,) } in
let jaxpr1 = { lambda ; nw:f64[25] nx:f64[25] ny:i64[] nz:f64[1,1]. let
    oa:f64[1,25] = pjit[
      name=_jacobi
      jaxpr={ lambda ; bm:f64[25] bn:f64[25] bo:i64[] bp:f64[1,1] br:i64[]. let
          bs:f64[] = squeeze[dimensions=(0, 1)] bp
          bt:f64[25] = add bn bm
          bu:f64[25] = add bt 1.0:f64[]
          bv:f64[25] = div bu 2.0:f64[]
          bw:f64[25] = add bn bm
          bx:f64[25] = add bw 2.0:f64[]
          by:f64[25] = add bn bm
          bz:f64[25] = add by 1.0:f64[]
          ca:f64[25] = mul bx bz
          cb:f64[25] = div ca 4.0:f64[]
          cc:f64[25] = add bn bm
          cd:f64[25] = add cc 3.0:f64[]
          ce:f64[25] = add bn bm
          cf:f64[25] = add ce 2.0:f64[]
          cg:f64[25] = mul cd cf
          ch:f64[25] = add bn bm
          ci:f64[25] = add ch 1.0:f64[]
          cj:f64[25] = mul cg ci
          ck:f64[25] = div cj 8.0:f64[]
          cl:f64[25] = add bn bm
          cm:f64[25] = add cl 4.0:f64[]
          cn:f64[25] = add bn bm
          co:f64[25] = add cn 3.0:f64[]
          cp:f64[25] = mul cm co
          cq:f64[25] = add bn bm
          cr:f64[25] = add cq 2.0:f64[]
          cs:f64[25] = mul cp cr
          ct:f64[25] = add bn bm
          cu:f64[25] = add ct 1.0:f64[]
          cv:f64[25] = mul cs cu
          cw:f64[25] = div cv 16.0:f64[]
          cx:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 1.0:f64[]
          cy:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] bv
          cz:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cb
          da:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] ck
          db:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cw
          dc:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(25, 1)
            sharding=None
          ] cx
          dd:f64[25,5] = concatenate[dimension=1] dc cy cz da db
          de:bool[] = lt br 0:i64[]
          df:i64[] = convert_element_type[new_dtype=int64 weak_type=False] br
          dg:i64[] = add df 5:i64[]
          dh:i64[] = select_n de br dg
          di:i64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] dh
          dj:f64[25,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=True
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(25, 1)
            unique_indices=True
          ] dd di
          dk:f64[25] = squeeze[dimensions=(1,)] dj
          dl:f64[] = convert_element_type[new_dtype=float64 weak_type=False] br
          dm:f64[25] = sub bm dl
          dn:f64[] = convert_element_type[new_dtype=float64 weak_type=False] br
          do:f64[25] = add bn dn
          dp:i64[] = add bo br
          dq:f64[] = convert_element_type[new_dtype=float64 weak_type=False] dp
          dr:f64[25] = add do dq
          ds:f64[25] = add dr 2.0:f64[]
          dt:f64[] = sub bs 1.0:f64[]
          du:f64[25] = mul ds dt
          dv:f64[25] = add do 1.0:f64[]
          dw:f64[25] = mul 2.0:f64[] dv
          dx:f64[25] = div du dw
          dy:f64[25] = add dx 1.0:f64[]
          dz:f64[25] = sub dm 1.0:f64[]
          ea:f64[25] = max dz 0.0:f64[]
          eb:i64[25] = convert_element_type[new_dtype=int64 weak_type=False] ea
          ec:i64[25] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(25,)
            sharding=None
          ] 0:i64[]
          _:i64[25] _:i64[25] _:f64[25] ed:f64[25] = while[
            body_jaxpr={ lambda ; ee:f64[25] ef:i64[] eg:f64[] eh:i64[25] ei:i64[25]
                ej:f64[25] ek:f64[25]. let
                el:i64[25] = add eh 1:i64[]
                em:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] eh
                en:f64[25] = add em 1.0:f64[]
                eo:f64[25] = mul 2.0:f64[] en
                ep:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] eo
                eq:f64[25] = add ep ee
                er:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] ef
                es:f64[25] = add eq er
                et:f64[25] = add es 1.0:f64[]
                eu:f64[25] = mul es et
                ev:f64[25] = add es 2.0:f64[]
                ew:f64[25] = mul eu ev
                ex:f64[] = sub eg 1.0:f64[]
                ey:f64[25] = mul ew ex
                ez:f64[25] = mul ey ek
                fa:f64[25] = mul 2.0:f64[] en
                fb:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] ef
                fc:f64[25] = add en fb
                fd:f64[25] = mul fa fc
                fe:f64[25] = add es 2.0:f64[]
                ff:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] fd
                fg:f64[25] = mul ff fe
                fh:f64[25] = mul fg ej
                fi:f64[25] = add ez fh
                fj:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] en
                fk:f64[25] = add fj ee
                fl:f64[25] = add fk 1.0:f64[]
                fm:f64[25] = mul 2.0:f64[] fl
                fn:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] en
                fo:f64[25] = add fn ee
                fp:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] ef
                fq:f64[25] = add fo fp
                fr:f64[25] = add fq 1.0:f64[]
                fs:f64[25] = mul fm fr
                ft:f64[25] = mul fs es
                fu:f64[25] = div fi ft
                fv:f64[25] = add fu ek
              in (el, ei, fu, fv) }
            body_nconsts=3
            cond_jaxpr={ lambda ; fw:i64[25] fx:i64[25] fy:f64[25] fz:f64[25]. let
                ga:bool[25] = lt fw fx
              in (ga,) }
            cond_nconsts=0
          ] do dp bs ec eb dx dy
          gb:f64[25] = add dm do
          gc:f64[25] = pjit[
            name=_binom
            jaxpr={ lambda ; gb:f64[25] dm:f64[25]. let
                gd:i64[25] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] dm
                ge:i64[25] = add 1:i64[] gd
                gf:i64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] 1:i64[]
                gg:f64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] 1.0:f64[]
                _:i64[25] _:i64[25] gc:f64[25] = while[
                  body_jaxpr={ lambda ; gh:f64[25] gi:i64[25] gj:i64[25] gk:f64[25]. let
                      gl:i64[25] = add gi 1:i64[]
                      gm:f64[25] = add gh 1.0:f64[]
                      gn:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] gi
                      go:f64[25] = sub gm gn
                      gp:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] gk
                      gq:f64[25] = mul gp go
                      gr:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] gi
                      gs:f64[25] = div gq gr
                    in (gl, gj, gs) }
                  body_nconsts=1
                  cond_jaxpr={ lambda ; gt:i64[25] gu:i64[25] gv:f64[25]. let
                      gw:bool[25] = lt gt gu
                    in (gw,) }
                  cond_nconsts=0
                ] gb gf ge gg
              in (gc,) }
          ] gb dm
          gx:f64[25] = mul gc ed
          gy:bool[25] = lt dm 0.0:f64[]
          gz:f64[25] = pjit[
            name=_where
            jaxpr={ lambda ; gy:bool[25] ha:i64[] gx:f64[25]. let
                hb:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] ha
                hc:f64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] hb
                gz:f64[25] = select_n gy gx hc
              in (gz,) }
          ] gy 0:i64[] gx
          hd:bool[25] = eq dm 0.0:f64[]
          he:f64[25] = pjit[
            name=_where
            jaxpr={ lambda ; hd:bool[25] hf:f64[] gz:f64[25]. let
                hg:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] hf
                hh:f64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] hg
                he:f64[25] = select_n hd gz hh
              in (he,) }
          ] hd 1.0:f64[] gz
          hi:bool[25] = eq dm 1.0:f64[]
          hj:f64[25] = add do 1.0:f64[]
          hk:f64[25] = mul 2.0:f64[] hj
          hl:f64[] = convert_element_type[new_dtype=float64 weak_type=False] dp
          hm:f64[25] = add do hl
          hn:f64[25] = add hm 2.0:f64[]
          ho:f64[] = sub bs 1.0:f64[]
          hp:f64[25] = mul hn ho
          hq:f64[25] = add hk hp
          hr:f64[25] = mul 0.5:f64[] hq
          hs:f64[25] = pjit[
            name=_where
            jaxpr={ lambda ; hi:bool[25] hr:f64[25] he:f64[25]. let
                hs:f64[25] = select_n hi he hr
              in (hs,) }
          ] hi hr he
          ht:f64[25] = mul dk hs
          bq:f64[1,25] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 25)
            sharding=None
          ] ht
        in (bq,) }
    ] nw nx ny nz 0:i64[]
  in (oa,) } in
let jaxpr2 = { lambda ; oc:f64[25] od:f64[25] oe:i64[] of:f64[1,1]. let
    og:f64[1,25] = pjit[
      name=_jacobi
      jaxpr={ lambda ; bm:f64[25] bn:f64[25] bo:i64[] bp:f64[1,1] br:i64[]. let
          bs:f64[] = squeeze[dimensions=(0, 1)] bp
          bt:f64[25] = add bn bm
          bu:f64[25] = add bt 1.0:f64[]
          bv:f64[25] = div bu 2.0:f64[]
          bw:f64[25] = add bn bm
          bx:f64[25] = add bw 2.0:f64[]
          by:f64[25] = add bn bm
          bz:f64[25] = add by 1.0:f64[]
          ca:f64[25] = mul bx bz
          cb:f64[25] = div ca 4.0:f64[]
          cc:f64[25] = add bn bm
          cd:f64[25] = add cc 3.0:f64[]
          ce:f64[25] = add bn bm
          cf:f64[25] = add ce 2.0:f64[]
          cg:f64[25] = mul cd cf
          ch:f64[25] = add bn bm
          ci:f64[25] = add ch 1.0:f64[]
          cj:f64[25] = mul cg ci
          ck:f64[25] = div cj 8.0:f64[]
          cl:f64[25] = add bn bm
          cm:f64[25] = add cl 4.0:f64[]
          cn:f64[25] = add bn bm
          co:f64[25] = add cn 3.0:f64[]
          cp:f64[25] = mul cm co
          cq:f64[25] = add bn bm
          cr:f64[25] = add cq 2.0:f64[]
          cs:f64[25] = mul cp cr
          ct:f64[25] = add bn bm
          cu:f64[25] = add ct 1.0:f64[]
          cv:f64[25] = mul cs cu
          cw:f64[25] = div cv 16.0:f64[]
          cx:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 1.0:f64[]
          cy:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] bv
          cz:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cb
          da:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] ck
          db:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cw
          dc:f64[25,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(25, 1)
            sharding=None
          ] cx
          dd:f64[25,5] = concatenate[dimension=1] dc cy cz da db
          de:bool[] = lt br 0:i64[]
          df:i64[] = convert_element_type[new_dtype=int64 weak_type=False] br
          dg:i64[] = add df 5:i64[]
          dh:i64[] = select_n de br dg
          di:i64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] dh
          dj:f64[25,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=True
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(25, 1)
            unique_indices=True
          ] dd di
          dk:f64[25] = squeeze[dimensions=(1,)] dj
          dl:f64[] = convert_element_type[new_dtype=float64 weak_type=False] br
          dm:f64[25] = sub bm dl
          dn:f64[] = convert_element_type[new_dtype=float64 weak_type=False] br
          do:f64[25] = add bn dn
          dp:i64[] = add bo br
          dq:f64[] = convert_element_type[new_dtype=float64 weak_type=False] dp
          dr:f64[25] = add do dq
          ds:f64[25] = add dr 2.0:f64[]
          dt:f64[] = sub bs 1.0:f64[]
          du:f64[25] = mul ds dt
          dv:f64[25] = add do 1.0:f64[]
          dw:f64[25] = mul 2.0:f64[] dv
          dx:f64[25] = div du dw
          dy:f64[25] = add dx 1.0:f64[]
          dz:f64[25] = sub dm 1.0:f64[]
          ea:f64[25] = max dz 0.0:f64[]
          eb:i64[25] = convert_element_type[new_dtype=int64 weak_type=False] ea
          ec:i64[25] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(25,)
            sharding=None
          ] 0:i64[]
          _:i64[25] _:i64[25] _:f64[25] ed:f64[25] = while[
            body_jaxpr={ lambda ; ee:f64[25] ef:i64[] eg:f64[] eh:i64[25] ei:i64[25]
                ej:f64[25] ek:f64[25]. let
                el:i64[25] = add eh 1:i64[]
                em:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] eh
                en:f64[25] = add em 1.0:f64[]
                eo:f64[25] = mul 2.0:f64[] en
                ep:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] eo
                eq:f64[25] = add ep ee
                er:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] ef
                es:f64[25] = add eq er
                et:f64[25] = add es 1.0:f64[]
                eu:f64[25] = mul es et
                ev:f64[25] = add es 2.0:f64[]
                ew:f64[25] = mul eu ev
                ex:f64[] = sub eg 1.0:f64[]
                ey:f64[25] = mul ew ex
                ez:f64[25] = mul ey ek
                fa:f64[25] = mul 2.0:f64[] en
                fb:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] ef
                fc:f64[25] = add en fb
                fd:f64[25] = mul fa fc
                fe:f64[25] = add es 2.0:f64[]
                ff:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] fd
                fg:f64[25] = mul ff fe
                fh:f64[25] = mul fg ej
                fi:f64[25] = add ez fh
                fj:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] en
                fk:f64[25] = add fj ee
                fl:f64[25] = add fk 1.0:f64[]
                fm:f64[25] = mul 2.0:f64[] fl
                fn:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] en
                fo:f64[25] = add fn ee
                fp:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] ef
                fq:f64[25] = add fo fp
                fr:f64[25] = add fq 1.0:f64[]
                fs:f64[25] = mul fm fr
                ft:f64[25] = mul fs es
                fu:f64[25] = div fi ft
                fv:f64[25] = add fu ek
              in (el, ei, fu, fv) }
            body_nconsts=3
            cond_jaxpr={ lambda ; fw:i64[25] fx:i64[25] fy:f64[25] fz:f64[25]. let
                ga:bool[25] = lt fw fx
              in (ga,) }
            cond_nconsts=0
          ] do dp bs ec eb dx dy
          gb:f64[25] = add dm do
          gc:f64[25] = pjit[
            name=_binom
            jaxpr={ lambda ; gb:f64[25] dm:f64[25]. let
                gd:i64[25] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] dm
                ge:i64[25] = add 1:i64[] gd
                gf:i64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] 1:i64[]
                gg:f64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] 1.0:f64[]
                _:i64[25] _:i64[25] gc:f64[25] = while[
                  body_jaxpr={ lambda ; gh:f64[25] gi:i64[25] gj:i64[25] gk:f64[25]. let
                      gl:i64[25] = add gi 1:i64[]
                      gm:f64[25] = add gh 1.0:f64[]
                      gn:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] gi
                      go:f64[25] = sub gm gn
                      gp:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] gk
                      gq:f64[25] = mul gp go
                      gr:f64[25] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] gi
                      gs:f64[25] = div gq gr
                    in (gl, gj, gs) }
                  body_nconsts=1
                  cond_jaxpr={ lambda ; gt:i64[25] gu:i64[25] gv:f64[25]. let
                      gw:bool[25] = lt gt gu
                    in (gw,) }
                  cond_nconsts=0
                ] gb gf ge gg
              in (gc,) }
          ] gb dm
          gx:f64[25] = mul gc ed
          gy:bool[25] = lt dm 0.0:f64[]
          gz:f64[25] = pjit[
            name=_where
            jaxpr={ lambda ; gy:bool[25] ha:i64[] gx:f64[25]. let
                hb:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] ha
                hc:f64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] hb
                gz:f64[25] = select_n gy gx hc
              in (gz,) }
          ] gy 0:i64[] gx
          hd:bool[25] = eq dm 0.0:f64[]
          he:f64[25] = pjit[
            name=_where
            jaxpr={ lambda ; hd:bool[25] hf:f64[] gz:f64[25]. let
                hg:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] hf
                hh:f64[25] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(25,)
                  sharding=None
                ] hg
                he:f64[25] = select_n hd gz hh
              in (he,) }
          ] hd 1.0:f64[] gz
          hi:bool[25] = eq dm 1.0:f64[]
          hj:f64[25] = add do 1.0:f64[]
          hk:f64[25] = mul 2.0:f64[] hj
          hl:f64[] = convert_element_type[new_dtype=float64 weak_type=False] dp
          hm:f64[25] = add do hl
          hn:f64[25] = add hm 2.0:f64[]
          ho:f64[] = sub bs 1.0:f64[]
          hp:f64[25] = mul hn ho
          hq:f64[25] = add hk hp
          hr:f64[25] = mul 0.5:f64[] hq
          hs:f64[25] = pjit[
            name=_where
            jaxpr={ lambda ; hi:bool[25] hr:f64[25] he:f64[25]. let
                hs:f64[25] = select_n hi he hr
              in (hs,) }
          ] hi hr he
          ht:f64[25] = mul dk hs
          bq:f64[1,25] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 25)
            sharding=None
          ] ht
        in (bq,) }
    ] oc od oe of 1:i64[]
  in (og,) } in
let floor_divide1 = { lambda ; ph:f64[20] pj:i64[]. let
    pk:f64[] = convert_element_type[new_dtype=float64 weak_type=False] pj
    pl:f64[20] = rem ph pk
    pm:f64[20] = sub ph pl
    pn:f64[20] = div pm pk
    po:bool[20] = ne pl 0.0:f64[]
    pp:f64[] = sign pk
    pq:f64[20] = sign pl
    pr:bool[20] = ne pp pq
    ps:bool[20] = and po pr
    pt:f64[20] = add pl pk
    _:f64[20] = select_n ps pl pt
    pu:f64[20] = sub pn 1.0:f64[]
    pv:f64[20] = select_n ps pn pu
    pi:f64[20] = round[rounding_method=0] pv
  in (pi,) } in
let jaxpr3 = { lambda ; qd:f64[20] qe:f64[20] qf:i64[] qg:f64[1,1]. let
    qh:f64[1,20] = pjit[
      name=_jacobi
      jaxpr={ lambda ; qd:f64[20] qe:f64[20] qf:i64[] qg:f64[1,1] qi:i64[]. let
          qj:f64[] = squeeze[dimensions=(0, 1)] qg
          qk:f64[20] = add qe qd
          ql:f64[20] = add qk 1.0:f64[]
          qm:f64[20] = div ql 2.0:f64[]
          qn:f64[20] = add qe qd
          qo:f64[20] = add qn 2.0:f64[]
          qp:f64[20] = add qe qd
          qq:f64[20] = add qp 1.0:f64[]
          qr:f64[20] = mul qo qq
          qs:f64[20] = div qr 4.0:f64[]
          qt:f64[20] = add qe qd
          qu:f64[20] = add qt 3.0:f64[]
          qv:f64[20] = add qe qd
          qw:f64[20] = add qv 2.0:f64[]
          qx:f64[20] = mul qu qw
          qy:f64[20] = add qe qd
          qz:f64[20] = add qy 1.0:f64[]
          ra:f64[20] = mul qx qz
          rb:f64[20] = div ra 8.0:f64[]
          rc:f64[20] = add qe qd
          rd:f64[20] = add rc 4.0:f64[]
          re:f64[20] = add qe qd
          rf:f64[20] = add re 3.0:f64[]
          rg:f64[20] = mul rd rf
          rh:f64[20] = add qe qd
          ri:f64[20] = add rh 2.0:f64[]
          rj:f64[20] = mul rg ri
          rk:f64[20] = add qe qd
          rl:f64[20] = add rk 1.0:f64[]
          rm:f64[20] = mul rj rl
          rn:f64[20] = div rm 16.0:f64[]
          ro:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 1.0:f64[]
          rp:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] qm
          rq:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] qs
          rr:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] rb
          rs:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] rn
          rt:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(20, 1)
            sharding=None
          ] ro
          ru:f64[20,5] = concatenate[dimension=1] rt rp rq rr rs
          rv:bool[] = lt qi 0:i64[]
          rw:i64[] = convert_element_type[new_dtype=int64 weak_type=False] qi
          rx:i64[] = add rw 5:i64[]
          ry:i64[] = select_n rv qi rx
          rz:i64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] ry
          sa:f64[20,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=True
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(20, 1)
            unique_indices=True
          ] ru rz
          sb:f64[20] = squeeze[dimensions=(1,)] sa
          sc:f64[] = convert_element_type[new_dtype=float64 weak_type=False] qi
          sd:f64[20] = sub qd sc
          se:f64[] = convert_element_type[new_dtype=float64 weak_type=False] qi
          sf:f64[20] = add qe se
          sg:i64[] = add qf qi
          sh:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sg
          si:f64[20] = add sf sh
          sj:f64[20] = add si 2.0:f64[]
          sk:f64[] = sub qj 1.0:f64[]
          sl:f64[20] = mul sj sk
          sm:f64[20] = add sf 1.0:f64[]
          sn:f64[20] = mul 2.0:f64[] sm
          so:f64[20] = div sl sn
          sp:f64[20] = add so 1.0:f64[]
          sq:f64[20] = sub sd 1.0:f64[]
          sr:f64[20] = max sq 0.0:f64[]
          ss:i64[20] = convert_element_type[new_dtype=int64 weak_type=False] sr
          st:i64[20] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(20,)
            sharding=None
          ] 0:i64[]
          _:i64[20] _:i64[20] _:f64[20] su:f64[20] = while[
            body_jaxpr={ lambda ; sv:f64[20] sw:i64[] sx:f64[] sy:i64[20] sz:i64[20]
                ta:f64[20] tb:f64[20]. let
                tc:i64[20] = add sy 1:i64[]
                td:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] sy
                te:f64[20] = add td 1.0:f64[]
                tf:f64[20] = mul 2.0:f64[] te
                tg:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] tf
                th:f64[20] = add tg sv
                ti:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sw
                tj:f64[20] = add th ti
                tk:f64[20] = add tj 1.0:f64[]
                tl:f64[20] = mul tj tk
                tm:f64[20] = add tj 2.0:f64[]
                tn:f64[20] = mul tl tm
                to:f64[] = sub sx 1.0:f64[]
                tp:f64[20] = mul tn to
                tq:f64[20] = mul tp tb
                tr:f64[20] = mul 2.0:f64[] te
                ts:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] sw
                tt:f64[20] = add te ts
                tu:f64[20] = mul tr tt
                tv:f64[20] = add tj 2.0:f64[]
                tw:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] tu
                tx:f64[20] = mul tw tv
                ty:f64[20] = mul tx ta
                tz:f64[20] = add tq ty
                ua:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] te
                ub:f64[20] = add ua sv
                uc:f64[20] = add ub 1.0:f64[]
                ud:f64[20] = mul 2.0:f64[] uc
                ue:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] te
                uf:f64[20] = add ue sv
                ug:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sw
                uh:f64[20] = add uf ug
                ui:f64[20] = add uh 1.0:f64[]
                uj:f64[20] = mul ud ui
                uk:f64[20] = mul uj tj
                ul:f64[20] = div tz uk
                um:f64[20] = add ul tb
              in (tc, sz, ul, um) }
            body_nconsts=3
            cond_jaxpr={ lambda ; un:i64[20] uo:i64[20] up:f64[20] uq:f64[20]. let
                ur:bool[20] = lt un uo
              in (ur,) }
            cond_nconsts=0
          ] sf sg qj st ss so sp
          us:f64[20] = add sd sf
          ut:f64[20] = pjit[
            name=_binom
            jaxpr={ lambda ; us:f64[20] sd:f64[20]. let
                uu:i64[20] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] sd
                uv:i64[20] = add 1:i64[] uu
                uw:i64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] 1:i64[]
                ux:f64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] 1.0:f64[]
                _:i64[20] _:i64[20] ut:f64[20] = while[
                  body_jaxpr={ lambda ; uy:f64[20] uz:i64[20] va:i64[20] vb:f64[20]. let
                      vc:i64[20] = add uz 1:i64[]
                      vd:f64[20] = add uy 1.0:f64[]
                      ve:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] uz
                      vf:f64[20] = sub vd ve
                      vg:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] vb
                      vh:f64[20] = mul vg vf
                      vi:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] uz
                      vj:f64[20] = div vh vi
                    in (vc, va, vj) }
                  body_nconsts=1
                  cond_jaxpr={ lambda ; vk:i64[20] vl:i64[20] vm:f64[20]. let
                      vn:bool[20] = lt vk vl
                    in (vn,) }
                  cond_nconsts=0
                ] us uw uv ux
              in (ut,) }
          ] us sd
          vo:f64[20] = mul ut su
          vp:bool[20] = lt sd 0.0:f64[]
          vq:f64[20] = pjit[
            name=_where
            jaxpr={ lambda ; vp:bool[20] vr:i64[] vo:f64[20]. let
                vs:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] vr
                vt:f64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] vs
                vq:f64[20] = select_n vp vo vt
              in (vq,) }
          ] vp 0:i64[] vo
          vu:bool[20] = eq sd 0.0:f64[]
          vv:f64[20] = pjit[
            name=_where
            jaxpr={ lambda ; vu:bool[20] vw:f64[] vq:f64[20]. let
                vx:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] vw
                vy:f64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] vx
                vv:f64[20] = select_n vu vq vy
              in (vv,) }
          ] vu 1.0:f64[] vq
          vz:bool[20] = eq sd 1.0:f64[]
          wa:f64[20] = add sf 1.0:f64[]
          wb:f64[20] = mul 2.0:f64[] wa
          wc:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sg
          wd:f64[20] = add sf wc
          we:f64[20] = add wd 2.0:f64[]
          wf:f64[] = sub qj 1.0:f64[]
          wg:f64[20] = mul we wf
          wh:f64[20] = add wb wg
          wi:f64[20] = mul 0.5:f64[] wh
          wj:f64[20] = pjit[
            name=_where
            jaxpr={ lambda ; vz:bool[20] wi:f64[20] vv:f64[20]. let
                wj:f64[20] = select_n vz vv wi
              in (wj,) }
          ] vz wi vv
          wk:f64[20] = mul sb wj
          qh:f64[1,20] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 20)
            sharding=None
          ] wk
        in (qh,) }
    ] qd qe qf qg 0:i64[]
  in (qh,) } in
let remainder1 = { lambda ; wn:f64[20] wp:i64[]. let
    wq:f64[] = convert_element_type[new_dtype=float64 weak_type=False] wp
    wr:f64[20] = rem wn wq
    ws:bool[20] = ne wr 0.0:f64[]
    wt:bool[20] = lt wr 0.0:f64[]
    wu:bool[] = lt wq 0.0:f64[]
    wv:bool[20] = ne wt wu
    ww:bool[20] = and wv ws
    wx:f64[20] = add wr wq
    wo:f64[20] = select_n ww wr wx
  in (wo,) } in
let _where7 = { lambda ; wy:bool[20] wl:f64[1,20] xa:f64[]. let
    xb:f64[] = convert_element_type[new_dtype=float64 weak_type=False] xa
    xc:bool[1,20] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 20)
      sharding=None
    ] wy
    xd:f64[1,20] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1, 20)
      sharding=None
    ] xb
    wz:f64[1,20] = select_n xc xd wl
  in (wz,) } in
let _where8 = { lambda ; xw:bool[8] xy:i64[] xz:i64[]. let
    ya:i64[8] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(8,)
      sharding=None
    ] xy
    yb:i64[8] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(8,)
      sharding=None
    ] xz
    xx:i64[8] = select_n xw yb ya
  in (xx,) } in
let _where9 = { lambda ; yc:i64[] yd:i64[8] xx:i64[8]. let
    yf:bool[] = ne yc 0:i64[]
    ye:i64[8] = select_n yf xx yd
  in (ye,) } in
let jaxpr4 = { lambda ; bac:f64[20] bad:f64[20] bae:i64[] baf:f64[1,1]. let
    bag:f64[1,20] = pjit[
      name=_jacobi
      jaxpr={ lambda ; qd:f64[20] qe:f64[20] qf:i64[] qg:f64[1,1] qi:i64[]. let
          qj:f64[] = squeeze[dimensions=(0, 1)] qg
          qk:f64[20] = add qe qd
          ql:f64[20] = add qk 1.0:f64[]
          qm:f64[20] = div ql 2.0:f64[]
          qn:f64[20] = add qe qd
          qo:f64[20] = add qn 2.0:f64[]
          qp:f64[20] = add qe qd
          qq:f64[20] = add qp 1.0:f64[]
          qr:f64[20] = mul qo qq
          qs:f64[20] = div qr 4.0:f64[]
          qt:f64[20] = add qe qd
          qu:f64[20] = add qt 3.0:f64[]
          qv:f64[20] = add qe qd
          qw:f64[20] = add qv 2.0:f64[]
          qx:f64[20] = mul qu qw
          qy:f64[20] = add qe qd
          qz:f64[20] = add qy 1.0:f64[]
          ra:f64[20] = mul qx qz
          rb:f64[20] = div ra 8.0:f64[]
          rc:f64[20] = add qe qd
          rd:f64[20] = add rc 4.0:f64[]
          re:f64[20] = add qe qd
          rf:f64[20] = add re 3.0:f64[]
          rg:f64[20] = mul rd rf
          rh:f64[20] = add qe qd
          ri:f64[20] = add rh 2.0:f64[]
          rj:f64[20] = mul rg ri
          rk:f64[20] = add qe qd
          rl:f64[20] = add rk 1.0:f64[]
          rm:f64[20] = mul rj rl
          rn:f64[20] = div rm 16.0:f64[]
          ro:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 1.0:f64[]
          rp:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] qm
          rq:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] qs
          rr:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] rb
          rs:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] rn
          rt:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(20, 1)
            sharding=None
          ] ro
          ru:f64[20,5] = concatenate[dimension=1] rt rp rq rr rs
          rv:bool[] = lt qi 0:i64[]
          rw:i64[] = convert_element_type[new_dtype=int64 weak_type=False] qi
          rx:i64[] = add rw 5:i64[]
          ry:i64[] = select_n rv qi rx
          rz:i64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] ry
          sa:f64[20,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=True
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(20, 1)
            unique_indices=True
          ] ru rz
          sb:f64[20] = squeeze[dimensions=(1,)] sa
          sc:f64[] = convert_element_type[new_dtype=float64 weak_type=False] qi
          sd:f64[20] = sub qd sc
          se:f64[] = convert_element_type[new_dtype=float64 weak_type=False] qi
          sf:f64[20] = add qe se
          sg:i64[] = add qf qi
          sh:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sg
          si:f64[20] = add sf sh
          sj:f64[20] = add si 2.0:f64[]
          sk:f64[] = sub qj 1.0:f64[]
          sl:f64[20] = mul sj sk
          sm:f64[20] = add sf 1.0:f64[]
          sn:f64[20] = mul 2.0:f64[] sm
          so:f64[20] = div sl sn
          sp:f64[20] = add so 1.0:f64[]
          sq:f64[20] = sub sd 1.0:f64[]
          sr:f64[20] = max sq 0.0:f64[]
          ss:i64[20] = convert_element_type[new_dtype=int64 weak_type=False] sr
          st:i64[20] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(20,)
            sharding=None
          ] 0:i64[]
          _:i64[20] _:i64[20] _:f64[20] su:f64[20] = while[
            body_jaxpr={ lambda ; sv:f64[20] sw:i64[] sx:f64[] sy:i64[20] sz:i64[20]
                ta:f64[20] tb:f64[20]. let
                tc:i64[20] = add sy 1:i64[]
                td:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] sy
                te:f64[20] = add td 1.0:f64[]
                tf:f64[20] = mul 2.0:f64[] te
                tg:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] tf
                th:f64[20] = add tg sv
                ti:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sw
                tj:f64[20] = add th ti
                tk:f64[20] = add tj 1.0:f64[]
                tl:f64[20] = mul tj tk
                tm:f64[20] = add tj 2.0:f64[]
                tn:f64[20] = mul tl tm
                to:f64[] = sub sx 1.0:f64[]
                tp:f64[20] = mul tn to
                tq:f64[20] = mul tp tb
                tr:f64[20] = mul 2.0:f64[] te
                ts:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] sw
                tt:f64[20] = add te ts
                tu:f64[20] = mul tr tt
                tv:f64[20] = add tj 2.0:f64[]
                tw:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] tu
                tx:f64[20] = mul tw tv
                ty:f64[20] = mul tx ta
                tz:f64[20] = add tq ty
                ua:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] te
                ub:f64[20] = add ua sv
                uc:f64[20] = add ub 1.0:f64[]
                ud:f64[20] = mul 2.0:f64[] uc
                ue:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] te
                uf:f64[20] = add ue sv
                ug:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sw
                uh:f64[20] = add uf ug
                ui:f64[20] = add uh 1.0:f64[]
                uj:f64[20] = mul ud ui
                uk:f64[20] = mul uj tj
                ul:f64[20] = div tz uk
                um:f64[20] = add ul tb
              in (tc, sz, ul, um) }
            body_nconsts=3
            cond_jaxpr={ lambda ; un:i64[20] uo:i64[20] up:f64[20] uq:f64[20]. let
                ur:bool[20] = lt un uo
              in (ur,) }
            cond_nconsts=0
          ] sf sg qj st ss so sp
          us:f64[20] = add sd sf
          ut:f64[20] = pjit[
            name=_binom
            jaxpr={ lambda ; us:f64[20] sd:f64[20]. let
                uu:i64[20] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] sd
                uv:i64[20] = add 1:i64[] uu
                uw:i64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] 1:i64[]
                ux:f64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] 1.0:f64[]
                _:i64[20] _:i64[20] ut:f64[20] = while[
                  body_jaxpr={ lambda ; uy:f64[20] uz:i64[20] va:i64[20] vb:f64[20]. let
                      vc:i64[20] = add uz 1:i64[]
                      vd:f64[20] = add uy 1.0:f64[]
                      ve:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] uz
                      vf:f64[20] = sub vd ve
                      vg:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] vb
                      vh:f64[20] = mul vg vf
                      vi:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] uz
                      vj:f64[20] = div vh vi
                    in (vc, va, vj) }
                  body_nconsts=1
                  cond_jaxpr={ lambda ; vk:i64[20] vl:i64[20] vm:f64[20]. let
                      vn:bool[20] = lt vk vl
                    in (vn,) }
                  cond_nconsts=0
                ] us uw uv ux
              in (ut,) }
          ] us sd
          vo:f64[20] = mul ut su
          vp:bool[20] = lt sd 0.0:f64[]
          vq:f64[20] = pjit[
            name=_where
            jaxpr={ lambda ; vp:bool[20] vr:i64[] vo:f64[20]. let
                vs:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] vr
                vt:f64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] vs
                vq:f64[20] = select_n vp vo vt
              in (vq,) }
          ] vp 0:i64[] vo
          vu:bool[20] = eq sd 0.0:f64[]
          vv:f64[20] = pjit[
            name=_where
            jaxpr={ lambda ; vu:bool[20] vw:f64[] vq:f64[20]. let
                vx:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] vw
                vy:f64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] vx
                vv:f64[20] = select_n vu vq vy
              in (vv,) }
          ] vu 1.0:f64[] vq
          vz:bool[20] = eq sd 1.0:f64[]
          wa:f64[20] = add sf 1.0:f64[]
          wb:f64[20] = mul 2.0:f64[] wa
          wc:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sg
          wd:f64[20] = add sf wc
          we:f64[20] = add wd 2.0:f64[]
          wf:f64[] = sub qj 1.0:f64[]
          wg:f64[20] = mul we wf
          wh:f64[20] = add wb wg
          wi:f64[20] = mul 0.5:f64[] wh
          wj:f64[20] = pjit[
            name=_where
            jaxpr={ lambda ; vz:bool[20] wi:f64[20] vv:f64[20]. let
                wj:f64[20] = select_n vz vv wi
              in (wj,) }
          ] vz wi vv
          wk:f64[20] = mul sb wj
          qh:f64[1,20] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 20)
            sharding=None
          ] wk
        in (qh,) }
    ] bac bad bae baf 0:i64[]
  in (bag,) } in
let jaxpr5 = { lambda ; bai:f64[20] baj:f64[20] bak:i64[] bal:f64[1,1]. let
    bam:f64[1,20] = pjit[
      name=_jacobi
      jaxpr={ lambda ; qd:f64[20] qe:f64[20] qf:i64[] qg:f64[1,1] qi:i64[]. let
          qj:f64[] = squeeze[dimensions=(0, 1)] qg
          qk:f64[20] = add qe qd
          ql:f64[20] = add qk 1.0:f64[]
          qm:f64[20] = div ql 2.0:f64[]
          qn:f64[20] = add qe qd
          qo:f64[20] = add qn 2.0:f64[]
          qp:f64[20] = add qe qd
          qq:f64[20] = add qp 1.0:f64[]
          qr:f64[20] = mul qo qq
          qs:f64[20] = div qr 4.0:f64[]
          qt:f64[20] = add qe qd
          qu:f64[20] = add qt 3.0:f64[]
          qv:f64[20] = add qe qd
          qw:f64[20] = add qv 2.0:f64[]
          qx:f64[20] = mul qu qw
          qy:f64[20] = add qe qd
          qz:f64[20] = add qy 1.0:f64[]
          ra:f64[20] = mul qx qz
          rb:f64[20] = div ra 8.0:f64[]
          rc:f64[20] = add qe qd
          rd:f64[20] = add rc 4.0:f64[]
          re:f64[20] = add qe qd
          rf:f64[20] = add re 3.0:f64[]
          rg:f64[20] = mul rd rf
          rh:f64[20] = add qe qd
          ri:f64[20] = add rh 2.0:f64[]
          rj:f64[20] = mul rg ri
          rk:f64[20] = add qe qd
          rl:f64[20] = add rk 1.0:f64[]
          rm:f64[20] = mul rj rl
          rn:f64[20] = div rm 16.0:f64[]
          ro:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 1.0:f64[]
          rp:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] qm
          rq:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] qs
          rr:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] rb
          rs:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] rn
          rt:f64[20,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(20, 1)
            sharding=None
          ] ro
          ru:f64[20,5] = concatenate[dimension=1] rt rp rq rr rs
          rv:bool[] = lt qi 0:i64[]
          rw:i64[] = convert_element_type[new_dtype=int64 weak_type=False] qi
          rx:i64[] = add rw 5:i64[]
          ry:i64[] = select_n rv qi rx
          rz:i64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] ry
          sa:f64[20,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=True
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(20, 1)
            unique_indices=True
          ] ru rz
          sb:f64[20] = squeeze[dimensions=(1,)] sa
          sc:f64[] = convert_element_type[new_dtype=float64 weak_type=False] qi
          sd:f64[20] = sub qd sc
          se:f64[] = convert_element_type[new_dtype=float64 weak_type=False] qi
          sf:f64[20] = add qe se
          sg:i64[] = add qf qi
          sh:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sg
          si:f64[20] = add sf sh
          sj:f64[20] = add si 2.0:f64[]
          sk:f64[] = sub qj 1.0:f64[]
          sl:f64[20] = mul sj sk
          sm:f64[20] = add sf 1.0:f64[]
          sn:f64[20] = mul 2.0:f64[] sm
          so:f64[20] = div sl sn
          sp:f64[20] = add so 1.0:f64[]
          sq:f64[20] = sub sd 1.0:f64[]
          sr:f64[20] = max sq 0.0:f64[]
          ss:i64[20] = convert_element_type[new_dtype=int64 weak_type=False] sr
          st:i64[20] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(20,)
            sharding=None
          ] 0:i64[]
          _:i64[20] _:i64[20] _:f64[20] su:f64[20] = while[
            body_jaxpr={ lambda ; sv:f64[20] sw:i64[] sx:f64[] sy:i64[20] sz:i64[20]
                ta:f64[20] tb:f64[20]. let
                tc:i64[20] = add sy 1:i64[]
                td:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] sy
                te:f64[20] = add td 1.0:f64[]
                tf:f64[20] = mul 2.0:f64[] te
                tg:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] tf
                th:f64[20] = add tg sv
                ti:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sw
                tj:f64[20] = add th ti
                tk:f64[20] = add tj 1.0:f64[]
                tl:f64[20] = mul tj tk
                tm:f64[20] = add tj 2.0:f64[]
                tn:f64[20] = mul tl tm
                to:f64[] = sub sx 1.0:f64[]
                tp:f64[20] = mul tn to
                tq:f64[20] = mul tp tb
                tr:f64[20] = mul 2.0:f64[] te
                ts:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=True
                ] sw
                tt:f64[20] = add te ts
                tu:f64[20] = mul tr tt
                tv:f64[20] = add tj 2.0:f64[]
                tw:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] tu
                tx:f64[20] = mul tw tv
                ty:f64[20] = mul tx ta
                tz:f64[20] = add tq ty
                ua:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] te
                ub:f64[20] = add ua sv
                uc:f64[20] = add ub 1.0:f64[]
                ud:f64[20] = mul 2.0:f64[] uc
                ue:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] te
                uf:f64[20] = add ue sv
                ug:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] sw
                uh:f64[20] = add uf ug
                ui:f64[20] = add uh 1.0:f64[]
                uj:f64[20] = mul ud ui
                uk:f64[20] = mul uj tj
                ul:f64[20] = div tz uk
                um:f64[20] = add ul tb
              in (tc, sz, ul, um) }
            body_nconsts=3
            cond_jaxpr={ lambda ; un:i64[20] uo:i64[20] up:f64[20] uq:f64[20]. let
                ur:bool[20] = lt un uo
              in (ur,) }
            cond_nconsts=0
          ] sf sg qj st ss so sp
          us:f64[20] = add sd sf
          ut:f64[20] = pjit[
            name=_binom
            jaxpr={ lambda ; us:f64[20] sd:f64[20]. let
                uu:i64[20] = convert_element_type[
                  new_dtype=int64
                  weak_type=False
                ] sd
                uv:i64[20] = add 1:i64[] uu
                uw:i64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] 1:i64[]
                ux:f64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] 1.0:f64[]
                _:i64[20] _:i64[20] ut:f64[20] = while[
                  body_jaxpr={ lambda ; uy:f64[20] uz:i64[20] va:i64[20] vb:f64[20]. let
                      vc:i64[20] = add uz 1:i64[]
                      vd:f64[20] = add uy 1.0:f64[]
                      ve:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] uz
                      vf:f64[20] = sub vd ve
                      vg:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] vb
                      vh:f64[20] = mul vg vf
                      vi:f64[20] = convert_element_type[
                        new_dtype=float64
                        weak_type=False
                      ] uz
                      vj:f64[20] = div vh vi
                    in (vc, va, vj) }
                  body_nconsts=1
                  cond_jaxpr={ lambda ; vk:i64[20] vl:i64[20] vm:f64[20]. let
                      vn:bool[20] = lt vk vl
                    in (vn,) }
                  cond_nconsts=0
                ] us uw uv ux
              in (ut,) }
          ] us sd
          vo:f64[20] = mul ut su
          vp:bool[20] = lt sd 0.0:f64[]
          vq:f64[20] = pjit[
            name=_where
            jaxpr={ lambda ; vp:bool[20] vr:i64[] vo:f64[20]. let
                vs:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] vr
                vt:f64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] vs
                vq:f64[20] = select_n vp vo vt
              in (vq,) }
          ] vp 0:i64[] vo
          vu:bool[20] = eq sd 0.0:f64[]
          vv:f64[20] = pjit[
            name=_where
            jaxpr={ lambda ; vu:bool[20] vw:f64[] vq:f64[20]. let
                vx:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] vw
                vy:f64[20] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(20,)
                  sharding=None
                ] vx
                vv:f64[20] = select_n vu vq vy
              in (vv,) }
          ] vu 1.0:f64[] vq
          vz:bool[20] = eq sd 1.0:f64[]
          wa:f64[20] = add sf 1.0:f64[]
          wb:f64[20] = mul 2.0:f64[] wa
          wc:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sg
          wd:f64[20] = add sf wc
          we:f64[20] = add wd 2.0:f64[]
          wf:f64[] = sub qj 1.0:f64[]
          wg:f64[20] = mul we wf
          wh:f64[20] = add wb wg
          wi:f64[20] = mul 0.5:f64[] wh
          wj:f64[20] = pjit[
            name=_where
            jaxpr={ lambda ; vz:bool[20] wi:f64[20] vv:f64[20]. let
                wj:f64[20] = select_n vz vv wi
              in (wj,) }
          ] vz wi vv
          wk:f64[20] = mul sb wj
          qh:f64[1,20] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 20)
            sharding=None
          ] wk
        in (qh,) }
    ] bai baj bak bal 1:i64[]
  in (bam,) } in
let _where10 = { lambda ; bcq:bool[1] bcs:f64[] bcp:f64[1]. let
    bct:f64[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] bcs
    bcr:f64[1] = select_n bcq bcp bct
  in (bcr,) } in
let atleast_1d = { lambda ; bdd:f64[1]. let  in (bdd,) } in
let searchsorted = { lambda ; bdc:f64[9] bde:f64[1]. let
    bdg:f64[] = squeeze[dimensions=(0,)] bde
    _:i32[] bdh:i32[] = scan[
      _split_transpose=False
      jaxpr={ lambda ; bdi:f64[9] bdj:f64[] bdk:i32[] bdl:i32[]. let
          bdm:u32[] = convert_element_type[new_dtype=uint32 weak_type=False] bdk
          bdn:u32[] = convert_element_type[new_dtype=uint32 weak_type=False] bdl
          bdo:u32[] = add bdm bdn
          bdp:u32[] = div bdo 2:u32[]
          bdq:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bdp
          bdr:bool[] = lt bdq 0:i32[]
          bds:i32[] = add bdq 9:i32[]
          bdt:i32[] = select_n bdr bdq bds
          bdu:f64[1] = dynamic_slice[slice_sizes=(1,)] bdi bdt
          bdv:f64[] = squeeze[dimensions=(0,)] bdu
          bdw:bool[] = eq bdj 0.0:f64[]
          bdx:f64[] = select_n bdw bdj 0.0:f64[]
          bdy:bool[] = ne bdj bdj
          bdz:f64[] = select_n bdy bdx nan:f64[]
          bea:bool[] = eq bdv 0.0:f64[]
          beb:f64[] = select_n bea bdv 0.0:f64[]
          bec:bool[] = ne bdv bdv
          bed:f64[] = select_n bec beb nan:f64[]
          bee:bool[] = lt_to bdz bed
          bef:i32[] = pjit[
            name=_where
            jaxpr={ lambda ; bee:bool[] bdk:i32[] bdq:i32[]. let
                bef:i32[] = select_n bee bdq bdk
              in (bef,) }
          ] bee bdk bdq
          beg:i32[] = pjit[
            name=_where
            jaxpr={ lambda ; bee:bool[] bdk:i32[] bdq:i32[]. let
                bef:i32[] = select_n bee bdq bdk
              in (bef,) }
          ] bee bdq bdl
        in (bef, beg) }
      length=4
      linear=(False, False, False, False)
      num_carry=2
      num_consts=2
      reverse=False
      unroll=1
    ] bdc bdg 0:i32[] 9:i32[]
    bdf:i32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] bdh
  in (bdf,) } in
let clip = { lambda ; bdf:i32[1] bei:i64[] bej:i64[]. let
    bek:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bei
    bel:i32[1] = max bek bdf
    bem:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bej
    beh:i32[1] = min bem bel
  in (beh,) } in
let _cubic2 = { lambda ; bdc:f64[9] bdb:f64[9]. let
    beo:f64[8] = pjit[
      name=diff
      jaxpr={ lambda ; bdc:f64[9]. let
          bep:f64[8] = slice[limit_indices=(9,) start_indices=(1,) strides=None] bdc
          beq:f64[8] = slice[limit_indices=(8,) start_indices=(0,) strides=None] bdc
          beo:f64[8] = sub bep beq
        in (beo,) }
    ] bdc
    ber:f64[8] = pjit[
      name=diff
      jaxpr={ lambda ; bdb:f64[9]. let
          bes:f64[8] = slice[limit_indices=(9,) start_indices=(1,) strides=None] bdb
          bet:f64[8] = slice[limit_indices=(8,) start_indices=(0,) strides=None] bdb
          ber:f64[8] = sub bes bet
        in (ber,) }
    ] bdb
    beu:bool[8] = eq beo 0.0:f64[]
    bev:bool[8] = eq beo 0.0:f64[]
    bew:f64[8] = pjit[
      name=_where
      jaxpr={ lambda ; bev:bool[8] bex:i64[] beo:f64[8]. let
          bey:f64[] = convert_element_type[new_dtype=float64 weak_type=False] bex
          bez:f64[8] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(8,)
            sharding=None
          ] bey
          bew:f64[8] = select_n bev beo bez
        in (bew,) }
    ] bev 1:i64[] beo
    bfa:f64[8] = div 1.0:f64[] bew
    bfb:f64[8] = pjit[
      name=_where
      jaxpr={ lambda ; bev:bool[8] bex:i64[] beo:f64[8]. let
          bey:f64[] = convert_element_type[new_dtype=float64 weak_type=False] bex
          bez:f64[8] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(8,)
            sharding=None
          ] bey
          bew:f64[8] = select_n bev beo bez
        in (bew,) }
    ] beu 0:i64[] bfa
    bfc:f64[8] = mul bfb ber
    bfd:f64[9] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(9,)
      sharding=None
    ] 0.0:f64[]
    bfe:f64[7] = slice[limit_indices=(7,) start_indices=(0,) strides=None] beo
    bff:f64[7] = slice[limit_indices=(8,) start_indices=(1,) strides=None] beo
    bfg:f64[7] = add bfe bff
    bfh:f64[7] = mul 2.0:f64[] bfg
    bfi:i32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] 1:i32[]
    bfj:f64[9] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(0,), inserted_window_dims=(), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr=None
    ] bfd bfi bfh
    bfk:f64[8] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(8,)
      sharding=None
    ] 0.0:f64[]
    bfl:f64[7] = slice[limit_indices=(7,) start_indices=(0,) strides=None] beo
    bfm:i32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] 1:i32[]
    bfn:f64[8] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(0,), inserted_window_dims=(), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr=None
    ] bfk bfm bfl
    bfo:f64[8] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(8,)
      sharding=None
    ] 0.0:f64[]
    bfp:f64[7] = slice[limit_indices=(8,) start_indices=(1,) strides=None] beo
    bfq:i32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] 0:i32[]
    bfr:f64[8] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(0,), inserted_window_dims=(), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr=None
    ] bfo bfq bfp
    bfs:f64[9] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(9,)
      sharding=None
    ] 0.0:f64[]
    bft:f64[7] = slice[limit_indices=(8,) start_indices=(1,) strides=None] beo
    bfu:f64[7] = slice[limit_indices=(7,) start_indices=(0,) strides=None] bfc
    bfv:f64[7] = mul bft bfu
    bfw:f64[7] = slice[limit_indices=(7,) start_indices=(0,) strides=None] beo
    bfx:f64[7] = slice[limit_indices=(8,) start_indices=(1,) strides=None] bfc
    bfy:f64[7] = mul bfw bfx
    bfz:f64[7] = add bfv bfy
    bga:f64[7] = mul 3.0:f64[] bfz
    bgb:i32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] 1:i32[]
    bgc:f64[9] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(0,), inserted_window_dims=(), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr=None
    ] bfs bgb bga
    bgd:f64[1] = slice[limit_indices=(3,) start_indices=(2,) strides=None] bdc
    bge:f64[] = squeeze[dimensions=(0,)] bgd
    bgf:f64[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] bdc
    bgg:f64[] = squeeze[dimensions=(0,)] bgf
    bgh:f64[] = sub bge bgg
    bgi:f64[1] = slice[limit_indices=(2,) start_indices=(1,) strides=None] beo
    bgj:f64[] = squeeze[dimensions=(0,)] bgi
    bgk:i32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] 0:i32[]
    bgl:f64[9] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr=None
    ] bfj bgk bgj
    bgm:i32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] 0:i32[]
    bgn:f64[8] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr=None
    ] bfn bgm bgh
    bgo:f64[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] beo
    bgp:f64[] = squeeze[dimensions=(0,)] bgo
    bgq:f64[] = mul 2.0:f64[] bgh
    bgr:f64[] = add bgp bgq
    bgs:f64[1] = slice[limit_indices=(2,) start_indices=(1,) strides=None] beo
    bgt:f64[] = squeeze[dimensions=(0,)] bgs
    bgu:f64[] = mul bgr bgt
    bgv:f64[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] bfc
    bgw:f64[] = squeeze[dimensions=(0,)] bgv
    bgx:f64[] = mul bgu bgw
    bgy:f64[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] beo
    bgz:f64[] = squeeze[dimensions=(0,)] bgy
    bha:f64[] = integer_pow[y=2] bgz
    bhb:f64[1] = slice[limit_indices=(2,) start_indices=(1,) strides=None] bfc
    bhc:f64[] = squeeze[dimensions=(0,)] bhb
    bhd:f64[] = mul bha bhc
    bhe:f64[] = add bgx bhd
    bhf:f64[] = div bhe bgh
    bhg:i32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] 0:i32[]
    bhh:f64[9] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr=None
    ] bgc bhg bhf
    bhi:f64[1] = dynamic_slice[slice_sizes=(1,)] bdc 8:i64[]
    bhj:f64[] = squeeze[dimensions=(0,)] bhi
    bhk:f64[1] = dynamic_slice[slice_sizes=(1,)] bdc 6:i64[]
    bhl:f64[] = squeeze[dimensions=(0,)] bhk
    bhm:f64[] = sub bhj bhl
    bhn:f64[1] = dynamic_slice[slice_sizes=(1,)] beo 6:i64[]
    bho:f64[] = squeeze[dimensions=(0,)] bhn
    bhp:i64[] = add -1:i64[] 9:i64[]
    bhq:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bhp
    bhr:i32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] bhq
    bhs:f64[9] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr=None
    ] bgl bhr bho
    bht:i64[] = add -1:i64[] 8:i64[]
    bhu:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bht
    bhv:i32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] bhu
    bhw:f64[8] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr=None
    ] bfr bhv bhm
    bhx:f64[1] = dynamic_slice[slice_sizes=(1,)] beo 7:i64[]
    bhy:f64[] = squeeze[dimensions=(0,)] bhx
    bhz:f64[] = integer_pow[y=2] bhy
    bia:f64[1] = dynamic_slice[slice_sizes=(1,)] bfc 6:i64[]
    bib:f64[] = squeeze[dimensions=(0,)] bia
    bic:f64[] = mul bhz bib
    bid:f64[] = mul 2.0:f64[] bhm
    bie:f64[1] = dynamic_slice[slice_sizes=(1,)] beo 7:i64[]
    bif:f64[] = squeeze[dimensions=(0,)] bie
    big:f64[] = add bid bif
    bih:f64[1] = dynamic_slice[slice_sizes=(1,)] beo 6:i64[]
    bii:f64[] = squeeze[dimensions=(0,)] bih
    bij:f64[] = mul big bii
    bik:f64[1] = dynamic_slice[slice_sizes=(1,)] bfc 7:i64[]
    bil:f64[] = squeeze[dimensions=(0,)] bik
    bim:f64[] = mul bij bil
    bin:f64[] = add bic bim
    bio:f64[] = div bin bhm
    bip:i64[] = add -1:i64[] 9:i64[]
    biq:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bip
    bir:i32[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] biq
    bis:f64[9] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,), operand_batching_dims=(), scatter_indices_batching_dims=())
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr=None
    ] bhh bir bio
    bit:bool[9] = eq bhs 0.0:f64[]
    biu:f64[9] = pjit[
      name=_where
      jaxpr={ lambda ; bit:bool[9] biv:i64[] bhs:f64[9]. let
          biw:f64[] = convert_element_type[new_dtype=float64 weak_type=False] biv
          bix:f64[9] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(9,)
            sharding=None
          ] biw
          biu:f64[9] = select_n bit bhs bix
        in (biu,) }
    ] bit 1:i64[] bhs
    biy:bool[8] = slice[limit_indices=(9,) start_indices=(1,) strides=None] bit
    biz:f64[8] = pjit[
      name=_where
      jaxpr={ lambda ; bev:bool[8] bex:i64[] beo:f64[8]. let
          bey:f64[] = convert_element_type[new_dtype=float64 weak_type=False] bex
          bez:f64[8] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(8,)
            sharding=None
          ] bey
          bew:f64[8] = select_n bev beo bez
        in (bew,) }
    ] biy 0:i64[] bhw
    bja:bool[8] = slice[limit_indices=(8,) start_indices=(0,) strides=None] bit
    bjb:f64[8] = pjit[
      name=_where
      jaxpr={ lambda ; bev:bool[8] bex:i64[] beo:f64[8]. let
          bey:f64[] = convert_element_type[new_dtype=float64 weak_type=False] bex
          bez:f64[8] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(8,)
            sharding=None
          ] bey
          bew:f64[8] = select_n bev beo bez
        in (bew,) }
    ] bja 0:i64[] bgn
    bjc:f64[9] = pjit[
      name=_where
      jaxpr={ lambda ; bit:bool[9] biv:i64[] bhs:f64[9]. let
          biw:f64[] = convert_element_type[new_dtype=float64 weak_type=False] biv
          bix:f64[9] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(9,)
            sharding=None
          ] biw
          biu:f64[9] = select_n bit bhs bix
        in (biu,) }
    ] bit 0:i64[] bis
    bjd:f64[9] = custom_jvp_call[
      name=_asarray
      call_jaxpr={ lambda ; bje:f64[9]. let  in (bje,) }
      jvp=_asarray_jvp
      symbolic_zeros=False
    ] biu
    bjf:f64[8] = custom_jvp_call[
      name=_asarray
      call_jaxpr={ lambda ; bjg:f64[8]. let  in (bjg,) }
      jvp=_asarray_jvp
      symbolic_zeros=False
    ] biz
    bjh:f64[8] = custom_jvp_call[
      name=_asarray
      call_jaxpr={ lambda ; bji:f64[8]. let  in (bji,) }
      jvp=_asarray_jvp
      symbolic_zeros=False
    ] bjb
    _:i64[] ben:f64[9] _:i32[] _:f64[9] _:f64[8] _:f64[8] = pjit[
      name=linear_solve
      jaxpr={ lambda ; bjd:f64[9] bjf:f64[8] bjh:f64[8] bjc:f64[9]. let
          bjj:f64[9] = custom_jvp_call[
            name=_asarray
            call_jaxpr={ lambda ; bjk:f64[9]. let  in (bjk,) }
            jvp=_asarray_jvp
            symbolic_zeros=False
          ] bjc
          bjl:f64[9] = stop_gradient bjd
          bjm:f64[8] = stop_gradient bjf
          bjn:f64[8] = stop_gradient bjh
          _:f64[9] _:f64[8] _:f64[8] = custom_jvp_call[
            name=_nondifferentiable
            call_jaxpr={ lambda ; bjo:f64[9] bjp:f64[8] bjq:f64[8]. let
                
              in (bjo, bjp, bjq) }
            jvp=_nondifferentiable_jvp
            symbolic_zeros=False
          ] bjl bjm bjn
          custom_jvp_call[
            name=_nondifferentiable
            call_jaxpr={ lambda ; . let  in () }
            jvp=_nondifferentiable_jvp
            symbolic_zeros=False
          ] 
          custom_jvp_call[
            name=_nondifferentiable
            call_jaxpr={ lambda ; . let  in () }
            jvp=_nondifferentiable_jvp
            symbolic_zeros=False
          ] 
          ben:f64[9] _:i32[] = linear_solve[
            flatten=<equinox.internal._primitive.Flatten object at 0x7f2ebc792710>
            static=(<object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, True)
            treedef=PyTreeDef((CustomNode(TridiagonalLinearOperator[('diagonal', 'lower_diagonal', 'upper_diagonal'), ()], [*, *, *]), ((*, *, *), CustomNode(Static[(), (('_leaves', [ShapeDtypeStruct(shape=(9,), dtype=float64), ShapeDtypeStruct(shape=(9,), dtype=float64), PyTreeDef((*, *))]), ('_treedef', PyTreeDef(([*, *], *))))], [])), *, {}, CustomNode(Tridiagonal[(), ()], []), *))
          ] bjd bjf bjh _ _ _ bjj
        in (0:i64[], ben, _, _, _, _) }
    ] bjd bjf bjh bjc
  in (0:i64[], ben) } in
let _take = { lambda ; bdb:f64[9] bko:i32[1]. let
    bkq:bool[1] = lt bko 0:i32[]
    bkr:i32[1] = add bko 9:i32[]
    bks:i32[1] = pjit[
      name=_where
      jaxpr={ lambda ; bkq:bool[1] bkr:i32[1] bko:i32[1]. let
          bks:i32[1] = select_n bkq bko bkr
        in (bks,) }
    ] bkq bkr bko
    bkt:i32[1,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(1, 1)
      sharding=None
    ] bks
    bkp:f64[1] = gather[
      dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
      fill_value=nan
      indices_are_sorted=False
      mode=GatherScatterMode.FILL_OR_DROP
      slice_sizes=(1,)
      unique_indices=False
    ] bdb bkt
  in (bkp,) } in
let _get_t_der = { lambda ; bkn:f64[1] bcz:i64[] bkm:f64[1]. let
    blm:f64[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] 0.0:f64[]
    bln:f64[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] 1.0:f64[]
    blo:f64[1] = pjit[name=atleast_1d jaxpr=atleast_1d] bkm
    blp:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(1, 1)
      sharding=None
    ] blo
    blq:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bcz
    blr:i32[] = clamp 0:i32[] blq 4:i32[]
    bll:f64[1,4] = cond[
      branches=(
        { lambda ; bls:f64[1] blt:f64[1] blu:f64[1,1] blv:f64[1]. let
            blw:f64[1] = integer_pow[y=2] bls
            blx:f64[1] = integer_pow[y=3] bls
            bly:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] blt
            blz:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bls
            bma:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] blw
            bmb:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] blx
            bmc:f64[4,1] = concatenate[dimension=0] bly blz bma bmb
            bmd:f64[1,4] = transpose[permutation=(1, 0)] bmc
            bme:f64[1,1] = integer_pow[y=0] blu
            bmf:f64[1,4] = mul bmd bme
          in (bmf,) }
        { lambda ; bmg:f64[1] bmh:f64[1] bmi:f64[1,1] bmj:f64[1]. let
            bmk:f64[1] = mul 2.0:f64[] bmg
            bml:f64[1] = integer_pow[y=2] bmg
            bmm:f64[1] = mul 3.0:f64[] bml
            bmn:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bmj
            bmo:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bmh
            bmp:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bmk
            bmq:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bmm
            bmr:f64[4,1] = concatenate[dimension=0] bmn bmo bmp bmq
            bms:f64[1,4] = transpose[permutation=(1, 0)] bmr
            bmt:f64[1,4] = mul bms bmi
          in (bmt,) }
        { lambda ; bmu:f64[1] bmv:f64[1] bmw:f64[1,1] bmx:f64[1]. let
            bmy:f64[1] = mul 2.0:f64[] bmv
            bmz:f64[1] = mul 6.0:f64[] bmu
            bna:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bmx
            bnb:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bmx
            bnc:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bmy
            bnd:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bmz
            bne:f64[4,1] = concatenate[dimension=0] bna bnb bnc bnd
            bnf:f64[1,4] = transpose[permutation=(1, 0)] bne
            bng:f64[1,1] = integer_pow[y=2] bmw
            bnh:f64[1,4] = mul bnf bng
          in (bnh,) }
        { lambda ; bni:f64[1] bnj:f64[1] bnk:f64[1,1] bnl:f64[1]. let
            bnm:f64[1] = mul 6.0:f64[] bnj
            bnn:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bnl
            bno:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bnl
            bnp:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bnl
            bnq:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bnm
            bnr:f64[4,1] = concatenate[dimension=0] bnn bno bnp bnq
            bns:f64[1,4] = transpose[permutation=(1, 0)] bnr
            bnt:f64[1,1] = integer_pow[y=3] bnk
            bnu:f64[1,4] = mul bns bnt
          in (bnu,) }
        { lambda ; bnv:f64[1] bnw:f64[1] bnx:f64[1,1] bny:f64[1]. let
            bnz:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bny
            boa:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bny
            bob:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bny
            boc:f64[1,1] = broadcast_in_dim[
              broadcast_dimensions=(1,)
              shape=(1, 1)
              sharding=None
            ] bny
            bod:f64[4,1] = concatenate[dimension=0] bnz boa bob boc
            boe:f64[1,4] = transpose[permutation=(1, 0)] bod
            bof:f64[1,1] = mul bnx 0.0:f64[]
            bog:f64[1,4] = mul boe bof
          in (bog,) }
      )
    ] blr bkn bln blp blm
  in (bll,) } in
let _extrap = { lambda ; bde:f64[1] boh:f64[1] bdc:f64[9] bda:bool[] boj:bool[]. let
    bok:bool[] = and True:bool[] bda
    bol:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bok
    bom:f64[1] = cond[
      branches=(
        { lambda ; bon:f64[9] boo:f64[1] bop:f64[1] boq:bool[]. let
            bor:f64[1] = slice[
              limit_indices=(1,)
              start_indices=(0,)
              strides=None
            ] bon
            bos:f64[] = squeeze[dimensions=(0,)] bor
            bot:bool[1] = lt boo bos
            bou:f64[1] = pjit[name=_where jaxpr=_where] bot nan:f64[] bop
          in (bou,) }
        { lambda ; bov:f64[9] bow:f64[1] box:f64[1] boy:bool[]. let  in (box,) }
      )
    ] bol bdc bde boh bda
    boz:bool[] = and True:bool[] boj
    bpa:i32[] = convert_element_type[new_dtype=int32 weak_type=False] boz
    boi:f64[1] = cond[
      branches=(
        { lambda ; bpb:f64[9] bpc:f64[1] bpd:f64[1] bpe:bool[]. let
            bpf:f64[1] = dynamic_slice[slice_sizes=(1,)] bpb 8:i64[]
            bpg:f64[] = squeeze[dimensions=(0,)] bpf
            bph:bool[1] = gt bpc bpg
            bpi:f64[1] = pjit[name=_where jaxpr=_where] bph nan:f64[] bpd
          in (bpi,) }
        { lambda ; bov:f64[9] bow:f64[1] box:f64[1] boy:bool[]. let  in (box,) }
      )
    ] bpa bdc bde bom boj
  in (boi,) } in
let _jacobi = { lambda ; bm:f64[25] bn:f64[25] bo:i64[] bp:f64[1,1] br:i64[]. let
    bs:f64[] = squeeze[dimensions=(0, 1)] bp
    bt:f64[25] = add bn bm
    bu:f64[25] = add bt 1.0:f64[]
    bv:f64[25] = div bu 2.0:f64[]
    bw:f64[25] = add bn bm
    bx:f64[25] = add bw 2.0:f64[]
    by:f64[25] = add bn bm
    bz:f64[25] = add by 1.0:f64[]
    ca:f64[25] = mul bx bz
    cb:f64[25] = div ca 4.0:f64[]
    cc:f64[25] = add bn bm
    cd:f64[25] = add cc 3.0:f64[]
    ce:f64[25] = add bn bm
    cf:f64[25] = add ce 2.0:f64[]
    cg:f64[25] = mul cd cf
    ch:f64[25] = add bn bm
    ci:f64[25] = add ch 1.0:f64[]
    cj:f64[25] = mul cg ci
    ck:f64[25] = div cj 8.0:f64[]
    cl:f64[25] = add bn bm
    cm:f64[25] = add cl 4.0:f64[]
    cn:f64[25] = add bn bm
    co:f64[25] = add cn 3.0:f64[]
    cp:f64[25] = mul cm co
    cq:f64[25] = add bn bm
    cr:f64[25] = add cq 2.0:f64[]
    cs:f64[25] = mul cp cr
    ct:f64[25] = add bn bm
    cu:f64[25] = add ct 1.0:f64[]
    cv:f64[25] = mul cs cu
    cw:f64[25] = div cv 16.0:f64[]
    cx:f64[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] 1.0:f64[]
    cy:f64[25,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(25, 1)
      sharding=None
    ] bv
    cz:f64[25,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(25, 1)
      sharding=None
    ] cb
    da:f64[25,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(25, 1)
      sharding=None
    ] ck
    db:f64[25,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(25, 1)
      sharding=None
    ] cw
    dc:f64[25,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(25, 1)
      sharding=None
    ] cx
    dd:f64[25,5] = concatenate[dimension=1] dc cy cz da db
    de:bool[] = lt br 0:i64[]
    df:i64[] = convert_element_type[new_dtype=int64 weak_type=False] br
    dg:i64[] = add df 5:i64[]
    dh:i64[] = select_n de br dg
    di:i64[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] dh
    dj:f64[25,1] = gather[
      dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
      fill_value=None
      indices_are_sorted=True
      mode=GatherScatterMode.PROMISE_IN_BOUNDS
      slice_sizes=(25, 1)
      unique_indices=True
    ] dd di
    dk:f64[25] = squeeze[dimensions=(1,)] dj
    dl:f64[] = convert_element_type[new_dtype=float64 weak_type=False] br
    dm:f64[25] = sub bm dl
    dn:f64[] = convert_element_type[new_dtype=float64 weak_type=False] br
    do:f64[25] = add bn dn
    dp:i64[] = add bo br
    dq:f64[] = convert_element_type[new_dtype=float64 weak_type=False] dp
    dr:f64[25] = add do dq
    ds:f64[25] = add dr 2.0:f64[]
    dt:f64[] = sub bs 1.0:f64[]
    du:f64[25] = mul ds dt
    dv:f64[25] = add do 1.0:f64[]
    dw:f64[25] = mul 2.0:f64[] dv
    dx:f64[25] = div du dw
    dy:f64[25] = add dx 1.0:f64[]
    dz:f64[25] = sub dm 1.0:f64[]
    ea:f64[25] = max dz 0.0:f64[]
    eb:i64[25] = convert_element_type[new_dtype=int64 weak_type=False] ea
    ec:i64[25] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(25,)
      sharding=None
    ] 0:i64[]
    _:i64[25] _:i64[25] _:f64[25] ed:f64[25] = while[
      body_jaxpr={ lambda ; ee:f64[25] ef:i64[] eg:f64[] eh:i64[25] ei:i64[25] ej:f64[25]
          ek:f64[25]. let
          el:i64[25] = add eh 1:i64[]
          em:f64[25] = convert_element_type[new_dtype=float64 weak_type=True] eh
          en:f64[25] = add em 1.0:f64[]
          eo:f64[25] = mul 2.0:f64[] en
          ep:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] eo
          eq:f64[25] = add ep ee
          er:f64[] = convert_element_type[new_dtype=float64 weak_type=False] ef
          es:f64[25] = add eq er
          et:f64[25] = add es 1.0:f64[]
          eu:f64[25] = mul es et
          ev:f64[25] = add es 2.0:f64[]
          ew:f64[25] = mul eu ev
          ex:f64[] = sub eg 1.0:f64[]
          ey:f64[25] = mul ew ex
          ez:f64[25] = mul ey ek
          fa:f64[25] = mul 2.0:f64[] en
          fb:f64[] = convert_element_type[new_dtype=float64 weak_type=True] ef
          fc:f64[25] = add en fb
          fd:f64[25] = mul fa fc
          fe:f64[25] = add es 2.0:f64[]
          ff:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] fd
          fg:f64[25] = mul ff fe
          fh:f64[25] = mul fg ej
          fi:f64[25] = add ez fh
          fj:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] en
          fk:f64[25] = add fj ee
          fl:f64[25] = add fk 1.0:f64[]
          fm:f64[25] = mul 2.0:f64[] fl
          fn:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] en
          fo:f64[25] = add fn ee
          fp:f64[] = convert_element_type[new_dtype=float64 weak_type=False] ef
          fq:f64[25] = add fo fp
          fr:f64[25] = add fq 1.0:f64[]
          fs:f64[25] = mul fm fr
          ft:f64[25] = mul fs es
          fu:f64[25] = div fi ft
          fv:f64[25] = add fu ek
        in (el, ei, fu, fv) }
      body_nconsts=3
      cond_jaxpr={ lambda ; fw:i64[25] fx:i64[25] fy:f64[25] fz:f64[25]. let
          ga:bool[25] = lt fw fx
        in (ga,) }
      cond_nconsts=0
    ] do dp bs ec eb dx dy
    gb:f64[25] = add dm do
    gc:f64[25] = pjit[
      name=_binom
      jaxpr={ lambda ; gb:f64[25] dm:f64[25]. let
          gd:i64[25] = convert_element_type[new_dtype=int64 weak_type=False] dm
          ge:i64[25] = add 1:i64[] gd
          gf:i64[25] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(25,)
            sharding=None
          ] 1:i64[]
          gg:f64[25] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(25,)
            sharding=None
          ] 1.0:f64[]
          _:i64[25] _:i64[25] gc:f64[25] = while[
            body_jaxpr={ lambda ; gh:f64[25] gi:i64[25] gj:i64[25] gk:f64[25]. let
                gl:i64[25] = add gi 1:i64[]
                gm:f64[25] = add gh 1.0:f64[]
                gn:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] gi
                go:f64[25] = sub gm gn
                gp:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] gk
                gq:f64[25] = mul gp go
                gr:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] gi
                gs:f64[25] = div gq gr
              in (gl, gj, gs) }
            body_nconsts=1
            cond_jaxpr={ lambda ; gt:i64[25] gu:i64[25] gv:f64[25]. let
                gw:bool[25] = lt gt gu
              in (gw,) }
            cond_nconsts=0
          ] gb gf ge gg
        in (gc,) }
    ] gb dm
    gx:f64[25] = mul gc ed
    gy:bool[25] = lt dm 0.0:f64[]
    gz:f64[25] = pjit[
      name=_where
      jaxpr={ lambda ; gy:bool[25] ha:i64[] gx:f64[25]. let
          hb:f64[] = convert_element_type[new_dtype=float64 weak_type=False] ha
          hc:f64[25] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(25,)
            sharding=None
          ] hb
          gz:f64[25] = select_n gy gx hc
        in (gz,) }
    ] gy 0:i64[] gx
    hd:bool[25] = eq dm 0.0:f64[]
    he:f64[25] = pjit[
      name=_where
      jaxpr={ lambda ; hd:bool[25] hf:f64[] gz:f64[25]. let
          hg:f64[] = convert_element_type[new_dtype=float64 weak_type=False] hf
          hh:f64[25] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(25,)
            sharding=None
          ] hg
          he:f64[25] = select_n hd gz hh
        in (he,) }
    ] hd 1.0:f64[] gz
    hi:bool[25] = eq dm 1.0:f64[]
    hj:f64[25] = add do 1.0:f64[]
    hk:f64[25] = mul 2.0:f64[] hj
    hl:f64[] = convert_element_type[new_dtype=float64 weak_type=False] dp
    hm:f64[25] = add do hl
    hn:f64[25] = add hm 2.0:f64[]
    ho:f64[] = sub bs 1.0:f64[]
    hp:f64[25] = mul hn ho
    hq:f64[25] = add hk hp
    hr:f64[25] = mul 0.5:f64[] hq
    hs:f64[25] = pjit[
      name=_where
      jaxpr={ lambda ; hi:bool[25] hr:f64[25] he:f64[25]. let
          hs:f64[25] = select_n hi he hr
        in (hs,) }
    ] hi hr he
    ht:f64[25] = mul dk hs
    bq:f64[1,25] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 25)
      sharding=None
    ] ht
  in (bq,) } in
let _jacobi1 = { lambda ; qd:f64[20] qe:f64[20] qf:i64[] qg:f64[1,1] qi:i64[]. let
    qj:f64[] = squeeze[dimensions=(0, 1)] qg
    qk:f64[20] = add qe qd
    ql:f64[20] = add qk 1.0:f64[]
    qm:f64[20] = div ql 2.0:f64[]
    qn:f64[20] = add qe qd
    qo:f64[20] = add qn 2.0:f64[]
    qp:f64[20] = add qe qd
    qq:f64[20] = add qp 1.0:f64[]
    qr:f64[20] = mul qo qq
    qs:f64[20] = div qr 4.0:f64[]
    qt:f64[20] = add qe qd
    qu:f64[20] = add qt 3.0:f64[]
    qv:f64[20] = add qe qd
    qw:f64[20] = add qv 2.0:f64[]
    qx:f64[20] = mul qu qw
    qy:f64[20] = add qe qd
    qz:f64[20] = add qy 1.0:f64[]
    ra:f64[20] = mul qx qz
    rb:f64[20] = div ra 8.0:f64[]
    rc:f64[20] = add qe qd
    rd:f64[20] = add rc 4.0:f64[]
    re:f64[20] = add qe qd
    rf:f64[20] = add re 3.0:f64[]
    rg:f64[20] = mul rd rf
    rh:f64[20] = add qe qd
    ri:f64[20] = add rh 2.0:f64[]
    rj:f64[20] = mul rg ri
    rk:f64[20] = add qe qd
    rl:f64[20] = add rk 1.0:f64[]
    rm:f64[20] = mul rj rl
    rn:f64[20] = div rm 16.0:f64[]
    ro:f64[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] 1.0:f64[]
    rp:f64[20,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(20, 1)
      sharding=None
    ] qm
    rq:f64[20,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(20, 1)
      sharding=None
    ] qs
    rr:f64[20,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(20, 1)
      sharding=None
    ] rb
    rs:f64[20,1] = broadcast_in_dim[
      broadcast_dimensions=(0,)
      shape=(20, 1)
      sharding=None
    ] rn
    rt:f64[20,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(20, 1)
      sharding=None
    ] ro
    ru:f64[20,5] = concatenate[dimension=1] rt rp rq rr rs
    rv:bool[] = lt qi 0:i64[]
    rw:i64[] = convert_element_type[new_dtype=int64 weak_type=False] qi
    rx:i64[] = add rw 5:i64[]
    ry:i64[] = select_n rv qi rx
    rz:i64[1] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(1,)
      sharding=None
    ] ry
    sa:f64[20,1] = gather[
      dimension_numbers=GatherDimensionNumbers(offset_dims=(0, np.int64(1)), collapsed_slice_dims=(), start_index_map=(np.int64(1),), operand_batching_dims=(), start_indices_batching_dims=())
      fill_value=None
      indices_are_sorted=True
      mode=GatherScatterMode.PROMISE_IN_BOUNDS
      slice_sizes=(20, 1)
      unique_indices=True
    ] ru rz
    sb:f64[20] = squeeze[dimensions=(1,)] sa
    sc:f64[] = convert_element_type[new_dtype=float64 weak_type=False] qi
    sd:f64[20] = sub qd sc
    se:f64[] = convert_element_type[new_dtype=float64 weak_type=False] qi
    sf:f64[20] = add qe se
    sg:i64[] = add qf qi
    sh:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sg
    si:f64[20] = add sf sh
    sj:f64[20] = add si 2.0:f64[]
    sk:f64[] = sub qj 1.0:f64[]
    sl:f64[20] = mul sj sk
    sm:f64[20] = add sf 1.0:f64[]
    sn:f64[20] = mul 2.0:f64[] sm
    so:f64[20] = div sl sn
    sp:f64[20] = add so 1.0:f64[]
    sq:f64[20] = sub sd 1.0:f64[]
    sr:f64[20] = max sq 0.0:f64[]
    ss:i64[20] = convert_element_type[new_dtype=int64 weak_type=False] sr
    st:i64[20] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(20,)
      sharding=None
    ] 0:i64[]
    _:i64[20] _:i64[20] _:f64[20] su:f64[20] = while[
      body_jaxpr={ lambda ; sv:f64[20] sw:i64[] sx:f64[] sy:i64[20] sz:i64[20] ta:f64[20]
          tb:f64[20]. let
          tc:i64[20] = add sy 1:i64[]
          td:f64[20] = convert_element_type[new_dtype=float64 weak_type=True] sy
          te:f64[20] = add td 1.0:f64[]
          tf:f64[20] = mul 2.0:f64[] te
          tg:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] tf
          th:f64[20] = add tg sv
          ti:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sw
          tj:f64[20] = add th ti
          tk:f64[20] = add tj 1.0:f64[]
          tl:f64[20] = mul tj tk
          tm:f64[20] = add tj 2.0:f64[]
          tn:f64[20] = mul tl tm
          to:f64[] = sub sx 1.0:f64[]
          tp:f64[20] = mul tn to
          tq:f64[20] = mul tp tb
          tr:f64[20] = mul 2.0:f64[] te
          ts:f64[] = convert_element_type[new_dtype=float64 weak_type=True] sw
          tt:f64[20] = add te ts
          tu:f64[20] = mul tr tt
          tv:f64[20] = add tj 2.0:f64[]
          tw:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] tu
          tx:f64[20] = mul tw tv
          ty:f64[20] = mul tx ta
          tz:f64[20] = add tq ty
          ua:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] te
          ub:f64[20] = add ua sv
          uc:f64[20] = add ub 1.0:f64[]
          ud:f64[20] = mul 2.0:f64[] uc
          ue:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] te
          uf:f64[20] = add ue sv
          ug:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sw
          uh:f64[20] = add uf ug
          ui:f64[20] = add uh 1.0:f64[]
          uj:f64[20] = mul ud ui
          uk:f64[20] = mul uj tj
          ul:f64[20] = div tz uk
          um:f64[20] = add ul tb
        in (tc, sz, ul, um) }
      body_nconsts=3
      cond_jaxpr={ lambda ; un:i64[20] uo:i64[20] up:f64[20] uq:f64[20]. let
          ur:bool[20] = lt un uo
        in (ur,) }
      cond_nconsts=0
    ] sf sg qj st ss so sp
    us:f64[20] = add sd sf
    ut:f64[20] = pjit[
      name=_binom
      jaxpr={ lambda ; us:f64[20] sd:f64[20]. let
          uu:i64[20] = convert_element_type[new_dtype=int64 weak_type=False] sd
          uv:i64[20] = add 1:i64[] uu
          uw:i64[20] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(20,)
            sharding=None
          ] 1:i64[]
          ux:f64[20] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(20,)
            sharding=None
          ] 1.0:f64[]
          _:i64[20] _:i64[20] ut:f64[20] = while[
            body_jaxpr={ lambda ; uy:f64[20] uz:i64[20] va:i64[20] vb:f64[20]. let
                vc:i64[20] = add uz 1:i64[]
                vd:f64[20] = add uy 1.0:f64[]
                ve:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] uz
                vf:f64[20] = sub vd ve
                vg:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] vb
                vh:f64[20] = mul vg vf
                vi:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] uz
                vj:f64[20] = div vh vi
              in (vc, va, vj) }
            body_nconsts=1
            cond_jaxpr={ lambda ; vk:i64[20] vl:i64[20] vm:f64[20]. let
                vn:bool[20] = lt vk vl
              in (vn,) }
            cond_nconsts=0
          ] us uw uv ux
        in (ut,) }
    ] us sd
    vo:f64[20] = mul ut su
    vp:bool[20] = lt sd 0.0:f64[]
    vq:f64[20] = pjit[
      name=_where
      jaxpr={ lambda ; vp:bool[20] vr:i64[] vo:f64[20]. let
          vs:f64[] = convert_element_type[new_dtype=float64 weak_type=False] vr
          vt:f64[20] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(20,)
            sharding=None
          ] vs
          vq:f64[20] = select_n vp vo vt
        in (vq,) }
    ] vp 0:i64[] vo
    vu:bool[20] = eq sd 0.0:f64[]
    vv:f64[20] = pjit[
      name=_where
      jaxpr={ lambda ; vu:bool[20] vw:f64[] vq:f64[20]. let
          vx:f64[] = convert_element_type[new_dtype=float64 weak_type=False] vw
          vy:f64[20] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(20,)
            sharding=None
          ] vx
          vv:f64[20] = select_n vu vq vy
        in (vv,) }
    ] vu 1.0:f64[] vq
    vz:bool[20] = eq sd 1.0:f64[]
    wa:f64[20] = add sf 1.0:f64[]
    wb:f64[20] = mul 2.0:f64[] wa
    wc:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sg
    wd:f64[20] = add sf wc
    we:f64[20] = add wd 2.0:f64[]
    wf:f64[] = sub qj 1.0:f64[]
    wg:f64[20] = mul we wf
    wh:f64[20] = add wb wg
    wi:f64[20] = mul 0.5:f64[] wh
    wj:f64[20] = pjit[
      name=_where
      jaxpr={ lambda ; vz:bool[20] wi:f64[20] vv:f64[20]. let
          wj:f64[20] = select_n vz vv wi
        in (wj,) }
    ] vz wi vv
    wk:f64[20] = mul sb wj
    qh:f64[1,20] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 20)
      sharding=None
    ] wk
  in (qh,) } in
let jaxpr6 = { lambda ; bdi:f64[9] bdj:f64[] bdk:i32[] bdl:i32[]. let
    bdm:u32[] = convert_element_type[new_dtype=uint32 weak_type=False] bdk
    bdn:u32[] = convert_element_type[new_dtype=uint32 weak_type=False] bdl
    bdo:u32[] = add bdm bdn
    bdp:u32[] = div bdo 2:u32[]
    bdq:i32[] = convert_element_type[new_dtype=int32 weak_type=False] bdp
    bdr:bool[] = lt bdq 0:i32[]
    bds:i32[] = add bdq 9:i32[]
    bdt:i32[] = select_n bdr bdq bds
    bdu:f64[1] = dynamic_slice[slice_sizes=(1,)] bdi bdt
    bdv:f64[] = squeeze[dimensions=(0,)] bdu
    bdw:bool[] = eq bdj 0.0:f64[]
    bdx:f64[] = select_n bdw bdj 0.0:f64[]
    bdy:bool[] = ne bdj bdj
    bdz:f64[] = select_n bdy bdx nan:f64[]
    bea:bool[] = eq bdv 0.0:f64[]
    beb:f64[] = select_n bea bdv 0.0:f64[]
    bec:bool[] = ne bdv bdv
    bed:f64[] = select_n bec beb nan:f64[]
    bee:bool[] = lt_to bdz bed
    bef:i32[] = pjit[
      name=_where
      jaxpr={ lambda ; bee:bool[] bdk:i32[] bdq:i32[]. let
          bef:i32[] = select_n bee bdq bdk
        in (bef,) }
    ] bee bdk bdq
    beg:i32[] = pjit[
      name=_where
      jaxpr={ lambda ; bee:bool[] bdk:i32[] bdq:i32[]. let
          bef:i32[] = select_n bee bdq bdk
        in (bef,) }
    ] bee bdq bdl
  in (bef, beg) } in
let diff = { lambda ; bdc:f64[9]. let
    bep:f64[8] = slice[limit_indices=(9,) start_indices=(1,) strides=None] bdc
    beq:f64[8] = slice[limit_indices=(8,) start_indices=(0,) strides=None] bdc
    beo:f64[8] = sub bep beq
  in (beo,) } in
let diff1 = { lambda ; bdb:f64[9]. let
    bes:f64[8] = slice[limit_indices=(9,) start_indices=(1,) strides=None] bdb
    bet:f64[8] = slice[limit_indices=(8,) start_indices=(0,) strides=None] bdb
    ber:f64[8] = sub bes bet
  in (ber,) } in
let _where11 = { lambda ; bev:bool[8] bex:i64[] beo:f64[8]. let
    bey:f64[] = convert_element_type[new_dtype=float64 weak_type=False] bex
    bez:f64[8] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(8,)
      sharding=None
    ] bey
    bew:f64[8] = select_n bev beo bez
  in (bew,) } in
let _where12 = { lambda ; bit:bool[9] biv:i64[] bhs:f64[9]. let
    biw:f64[] = convert_element_type[new_dtype=float64 weak_type=False] biv
    bix:f64[9] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(9,)
      sharding=None
    ] biw
    biu:f64[9] = select_n bit bhs bix
  in (biu,) } in
let jaxpr7 = { lambda ; bje:f64[9]. let  in (bje,) } in
let jaxpr8 = { lambda ; bjg:f64[8]. let  in (bjg,) } in
let jaxpr9 = { lambda ; bji:f64[8]. let  in (bji,) } in
let linear_solve = { lambda ; bjd:f64[9] bjf:f64[8] bjh:f64[8] bjc:f64[9]. let
    bjj:f64[9] = custom_jvp_call[
      name=_asarray
      call_jaxpr={ lambda ; bjk:f64[9]. let  in (bjk,) }
      jvp=_asarray_jvp
      symbolic_zeros=False
    ] bjc
    bjl:f64[9] = stop_gradient bjd
    bjm:f64[8] = stop_gradient bjf
    bjn:f64[8] = stop_gradient bjh
    _:f64[9] _:f64[8] _:f64[8] = custom_jvp_call[
      name=_nondifferentiable
      call_jaxpr={ lambda ; bjo:f64[9] bjp:f64[8] bjq:f64[8]. let
          
        in (bjo, bjp, bjq) }
      jvp=_nondifferentiable_jvp
      symbolic_zeros=False
    ] bjl bjm bjn
    custom_jvp_call[
      name=_nondifferentiable
      call_jaxpr={ lambda ; . let  in () }
      jvp=_nondifferentiable_jvp
      symbolic_zeros=False
    ] 
    custom_jvp_call[
      name=_nondifferentiable
      call_jaxpr={ lambda ; . let  in () }
      jvp=_nondifferentiable_jvp
      symbolic_zeros=False
    ] 
    ben:f64[9] _:i32[] = linear_solve[
      flatten=<equinox.internal._primitive.Flatten object at 0x7f2ebc792710>
      static=(<object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, <object object at 0x7f333cd61f20>, True)
      treedef=PyTreeDef((CustomNode(TridiagonalLinearOperator[('diagonal', 'lower_diagonal', 'upper_diagonal'), ()], [*, *, *]), ((*, *, *), CustomNode(Static[(), (('_leaves', [ShapeDtypeStruct(shape=(9,), dtype=float64), ShapeDtypeStruct(shape=(9,), dtype=float64), PyTreeDef((*, *))]), ('_treedef', PyTreeDef(([*, *], *))))], [])), *, {}, CustomNode(Tridiagonal[(), ()], []), *))
    ] bjd bjf bjh _ _ _ bjj
  in (0:i64[], ben, _, _, _, _) } in
let _where13 = { lambda ; bkq:bool[1] bkr:i32[1] bko:i32[1]. let
    bks:i32[1] = select_n bkq bko bkr
  in (bks,) } in
let jaxpr10 = { lambda ; bls:f64[1] blt:f64[1] blu:f64[1,1] blv:f64[1]. let
    blw:f64[1] = integer_pow[y=2] bls
    blx:f64[1] = integer_pow[y=3] bls
    bly:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] blt
    blz:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bls
    bma:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] blw
    bmb:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] blx
    bmc:f64[4,1] = concatenate[dimension=0] bly blz bma bmb
    bmd:f64[1,4] = transpose[permutation=(1, 0)] bmc
    bme:f64[1,1] = integer_pow[y=0] blu
    bmf:f64[1,4] = mul bmd bme
  in (bmf,) } in
let jaxpr11 = { lambda ; bmg:f64[1] bmh:f64[1] bmi:f64[1,1] bmj:f64[1]. let
    bmk:f64[1] = mul 2.0:f64[] bmg
    bml:f64[1] = integer_pow[y=2] bmg
    bmm:f64[1] = mul 3.0:f64[] bml
    bmn:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bmj
    bmo:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bmh
    bmp:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bmk
    bmq:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bmm
    bmr:f64[4,1] = concatenate[dimension=0] bmn bmo bmp bmq
    bms:f64[1,4] = transpose[permutation=(1, 0)] bmr
    bmt:f64[1,4] = mul bms bmi
  in (bmt,) } in
let jaxpr12 = { lambda ; bmu:f64[1] bmv:f64[1] bmw:f64[1,1] bmx:f64[1]. let
    bmy:f64[1] = mul 2.0:f64[] bmv
    bmz:f64[1] = mul 6.0:f64[] bmu
    bna:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bmx
    bnb:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bmx
    bnc:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bmy
    bnd:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bmz
    bne:f64[4,1] = concatenate[dimension=0] bna bnb bnc bnd
    bnf:f64[1,4] = transpose[permutation=(1, 0)] bne
    bng:f64[1,1] = integer_pow[y=2] bmw
    bnh:f64[1,4] = mul bnf bng
  in (bnh,) } in
let jaxpr13 = { lambda ; bni:f64[1] bnj:f64[1] bnk:f64[1,1] bnl:f64[1]. let
    bnm:f64[1] = mul 6.0:f64[] bnj
    bnn:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bnl
    bno:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bnl
    bnp:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bnl
    bnq:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bnm
    bnr:f64[4,1] = concatenate[dimension=0] bnn bno bnp bnq
    bns:f64[1,4] = transpose[permutation=(1, 0)] bnr
    bnt:f64[1,1] = integer_pow[y=3] bnk
    bnu:f64[1,4] = mul bns bnt
  in (bnu,) } in
let jaxpr14 = { lambda ; bnv:f64[1] bnw:f64[1] bnx:f64[1,1] bny:f64[1]. let
    bnz:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bny
    boa:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bny
    bob:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bny
    boc:f64[1,1] = broadcast_in_dim[
      broadcast_dimensions=(1,)
      shape=(1, 1)
      sharding=None
    ] bny
    bod:f64[4,1] = concatenate[dimension=0] bnz boa bob boc
    boe:f64[1,4] = transpose[permutation=(1, 0)] bod
    bof:f64[1,1] = mul bnx 0.0:f64[]
    bog:f64[1,4] = mul boe bof
  in (bog,) } in
let jaxpr15 = { lambda ; bon:f64[9] boo:f64[1] bop:f64[1] boq:bool[]. let
    bor:f64[1] = slice[limit_indices=(1,) start_indices=(0,) strides=None] bon
    bos:f64[] = squeeze[dimensions=(0,)] bor
    bot:bool[1] = lt boo bos
    bou:f64[1] = pjit[name=_where jaxpr=_where] bot nan:f64[] bop
  in (bou,) } in
let jaxpr16 = { lambda ; bov:f64[9] bow:f64[1] box:f64[1] boy:bool[]. let
    
  in (box,) } in
let jaxpr17 = { lambda ; bpb:f64[9] bpc:f64[1] bpd:f64[1] bpe:bool[]. let
    bpf:f64[1] = dynamic_slice[slice_sizes=(1,)] bpb 8:i64[]
    bpg:f64[] = squeeze[dimensions=(0,)] bpf
    bph:bool[1] = gt bpc bpg
    bpi:f64[1] = pjit[name=_where jaxpr=_where] bph nan:f64[] bpd
  in (bpi,) } in
let jaxpr18 = { lambda ; fw:i64[25] fx:i64[25] fy:f64[25] fz:f64[25]. let
    ga:bool[25] = lt fw fx
  in (ga,) } in
let jaxpr19 = { lambda ; ee:f64[25] ef:i64[] eg:f64[] eh:i64[25] ei:i64[25] ej:f64[25]
    ek:f64[25]. let
    el:i64[25] = add eh 1:i64[]
    em:f64[25] = convert_element_type[new_dtype=float64 weak_type=True] eh
    en:f64[25] = add em 1.0:f64[]
    eo:f64[25] = mul 2.0:f64[] en
    ep:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] eo
    eq:f64[25] = add ep ee
    er:f64[] = convert_element_type[new_dtype=float64 weak_type=False] ef
    es:f64[25] = add eq er
    et:f64[25] = add es 1.0:f64[]
    eu:f64[25] = mul es et
    ev:f64[25] = add es 2.0:f64[]
    ew:f64[25] = mul eu ev
    ex:f64[] = sub eg 1.0:f64[]
    ey:f64[25] = mul ew ex
    ez:f64[25] = mul ey ek
    fa:f64[25] = mul 2.0:f64[] en
    fb:f64[] = convert_element_type[new_dtype=float64 weak_type=True] ef
    fc:f64[25] = add en fb
    fd:f64[25] = mul fa fc
    fe:f64[25] = add es 2.0:f64[]
    ff:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] fd
    fg:f64[25] = mul ff fe
    fh:f64[25] = mul fg ej
    fi:f64[25] = add ez fh
    fj:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] en
    fk:f64[25] = add fj ee
    fl:f64[25] = add fk 1.0:f64[]
    fm:f64[25] = mul 2.0:f64[] fl
    fn:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] en
    fo:f64[25] = add fn ee
    fp:f64[] = convert_element_type[new_dtype=float64 weak_type=False] ef
    fq:f64[25] = add fo fp
    fr:f64[25] = add fq 1.0:f64[]
    fs:f64[25] = mul fm fr
    ft:f64[25] = mul fs es
    fu:f64[25] = div fi ft
    fv:f64[25] = add fu ek
  in (el, ei, fu, fv) } in
let _binom = { lambda ; gb:f64[25] dm:f64[25]. let
    gd:i64[25] = convert_element_type[new_dtype=int64 weak_type=False] dm
    ge:i64[25] = add 1:i64[] gd
    gf:i64[25] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(25,)
      sharding=None
    ] 1:i64[]
    gg:f64[25] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(25,)
      sharding=None
    ] 1.0:f64[]
    _:i64[25] _:i64[25] gc:f64[25] = while[
      body_jaxpr={ lambda ; gh:f64[25] gi:i64[25] gj:i64[25] gk:f64[25]. let
          gl:i64[25] = add gi 1:i64[]
          gm:f64[25] = add gh 1.0:f64[]
          gn:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] gi
          go:f64[25] = sub gm gn
          gp:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] gk
          gq:f64[25] = mul gp go
          gr:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] gi
          gs:f64[25] = div gq gr
        in (gl, gj, gs) }
      body_nconsts=1
      cond_jaxpr={ lambda ; gt:i64[25] gu:i64[25] gv:f64[25]. let
          gw:bool[25] = lt gt gu
        in (gw,) }
      cond_nconsts=0
    ] gb gf ge gg
  in (gc,) } in
let _where14 = { lambda ; gy:bool[25] ha:i64[] gx:f64[25]. let
    hb:f64[] = convert_element_type[new_dtype=float64 weak_type=False] ha
    hc:f64[25] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(25,)
      sharding=None
    ] hb
    gz:f64[25] = select_n gy gx hc
  in (gz,) } in
let _where15 = { lambda ; hd:bool[25] hf:f64[] gz:f64[25]. let
    hg:f64[] = convert_element_type[new_dtype=float64 weak_type=False] hf
    hh:f64[25] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(25,)
      sharding=None
    ] hg
    he:f64[25] = select_n hd gz hh
  in (he,) } in
let _where16 = { lambda ; hi:bool[25] hr:f64[25] he:f64[25]. let
    hs:f64[25] = select_n hi he hr
  in (hs,) } in
let jaxpr20 = { lambda ; un:i64[20] uo:i64[20] up:f64[20] uq:f64[20]. let
    ur:bool[20] = lt un uo
  in (ur,) } in
let jaxpr21 = { lambda ; sv:f64[20] sw:i64[] sx:f64[] sy:i64[20] sz:i64[20] ta:f64[20]
    tb:f64[20]. let
    tc:i64[20] = add sy 1:i64[]
    td:f64[20] = convert_element_type[new_dtype=float64 weak_type=True] sy
    te:f64[20] = add td 1.0:f64[]
    tf:f64[20] = mul 2.0:f64[] te
    tg:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] tf
    th:f64[20] = add tg sv
    ti:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sw
    tj:f64[20] = add th ti
    tk:f64[20] = add tj 1.0:f64[]
    tl:f64[20] = mul tj tk
    tm:f64[20] = add tj 2.0:f64[]
    tn:f64[20] = mul tl tm
    to:f64[] = sub sx 1.0:f64[]
    tp:f64[20] = mul tn to
    tq:f64[20] = mul tp tb
    tr:f64[20] = mul 2.0:f64[] te
    ts:f64[] = convert_element_type[new_dtype=float64 weak_type=True] sw
    tt:f64[20] = add te ts
    tu:f64[20] = mul tr tt
    tv:f64[20] = add tj 2.0:f64[]
    tw:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] tu
    tx:f64[20] = mul tw tv
    ty:f64[20] = mul tx ta
    tz:f64[20] = add tq ty
    ua:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] te
    ub:f64[20] = add ua sv
    uc:f64[20] = add ub 1.0:f64[]
    ud:f64[20] = mul 2.0:f64[] uc
    ue:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] te
    uf:f64[20] = add ue sv
    ug:f64[] = convert_element_type[new_dtype=float64 weak_type=False] sw
    uh:f64[20] = add uf ug
    ui:f64[20] = add uh 1.0:f64[]
    uj:f64[20] = mul ud ui
    uk:f64[20] = mul uj tj
    ul:f64[20] = div tz uk
    um:f64[20] = add ul tb
  in (tc, sz, ul, um) } in
let _binom1 = { lambda ; us:f64[20] sd:f64[20]. let
    uu:i64[20] = convert_element_type[new_dtype=int64 weak_type=False] sd
    uv:i64[20] = add 1:i64[] uu
    uw:i64[20] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(20,)
      sharding=None
    ] 1:i64[]
    ux:f64[20] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(20,)
      sharding=None
    ] 1.0:f64[]
    _:i64[20] _:i64[20] ut:f64[20] = while[
      body_jaxpr={ lambda ; uy:f64[20] uz:i64[20] va:i64[20] vb:f64[20]. let
          vc:i64[20] = add uz 1:i64[]
          vd:f64[20] = add uy 1.0:f64[]
          ve:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] uz
          vf:f64[20] = sub vd ve
          vg:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] vb
          vh:f64[20] = mul vg vf
          vi:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] uz
          vj:f64[20] = div vh vi
        in (vc, va, vj) }
      body_nconsts=1
      cond_jaxpr={ lambda ; vk:i64[20] vl:i64[20] vm:f64[20]. let
          vn:bool[20] = lt vk vl
        in (vn,) }
      cond_nconsts=0
    ] us uw uv ux
  in (ut,) } in
let _where17 = { lambda ; vp:bool[20] vr:i64[] vo:f64[20]. let
    vs:f64[] = convert_element_type[new_dtype=float64 weak_type=False] vr
    vt:f64[20] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(20,)
      sharding=None
    ] vs
    vq:f64[20] = select_n vp vo vt
  in (vq,) } in
let _where18 = { lambda ; vu:bool[20] vw:f64[] vq:f64[20]. let
    vx:f64[] = convert_element_type[new_dtype=float64 weak_type=False] vw
    vy:f64[20] = broadcast_in_dim[
      broadcast_dimensions=()
      shape=(20,)
      sharding=None
    ] vx
    vv:f64[20] = select_n vu vq vy
  in (vv,) } in
let _where19 = { lambda ; vz:bool[20] wi:f64[20] vv:f64[20]. let
    wj:f64[20] = select_n vz vv wi
  in (wj,) } in
let _where20 = { lambda ; bee:bool[] bdk:i32[] bdq:i32[]. let
    bef:i32[] = select_n bee bdq bdk
  in (bef,) } in
let jaxpr22 = { lambda ; bjk:f64[9]. let  in (bjk,) } in
let jaxpr23 = { lambda ; bjo:f64[9] bjp:f64[8] bjq:f64[8]. let
    
  in (bjo, bjp, bjq) } in
let jaxpr24 = { lambda ; . let  in () } in
let jaxpr25 = { lambda ; . let  in () } in
let jaxpr26 = { lambda ; gt:i64[25] gu:i64[25] gv:f64[25]. let
    gw:bool[25] = lt gt gu
  in (gw,) } in
let jaxpr27 = { lambda ; gh:f64[25] gi:i64[25] gj:i64[25] gk:f64[25]. let
    gl:i64[25] = add gi 1:i64[]
    gm:f64[25] = add gh 1.0:f64[]
    gn:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] gi
    go:f64[25] = sub gm gn
    gp:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] gk
    gq:f64[25] = mul gp go
    gr:f64[25] = convert_element_type[new_dtype=float64 weak_type=False] gi
    gs:f64[25] = div gq gr
  in (gl, gj, gs) } in
let jaxpr28 = { lambda ; vk:i64[20] vl:i64[20] vm:f64[20]. let
    vn:bool[20] = lt vk vl
  in (vn,) } in
let jaxpr29 = { lambda ; uy:f64[20] uz:i64[20] va:i64[20] vb:f64[20]. let
    vc:i64[20] = add uz 1:i64[]
    vd:f64[20] = add uy 1.0:f64[]
    ve:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] uz
    vf:f64[20] = sub vd ve
    vg:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] vb
    vh:f64[20] = mul vg vf
    vi:f64[20] = convert_element_type[new_dtype=float64 weak_type=False] uz
    vj:f64[20] = div vh vi
  in (vc, va, vj) } in
{ lambda ; bpj:i64[] bpk:f64[1,4] bpl:f64[3] bpm:f64[20] bpn:f64[] bpo:f64[25] bpp:f64[20]
    bpq:f64[1] bpr:f64[0] bps:f64[9] bpt:f64[3] bpu:f64[9] bpv:f64[9] bpw:f64[5]
    bpx:f64[9] bpy:f64[8] bpz:i64[] bqa:f64[0] bqb:f64[0] bqc:f64[20] bqd:f64[0]
    bqe:f64[1] bqf:f64[25] bqg:f64[1] bqh:f64[9] bqi:f64[0] bqj:f64[0] bqk:f64[20]
    bql:f64[0] bqm:f64[8] bqn:f64[0] bqo:f64[0] bqp:f64[0] bqq:f64[9] bqr:f64[0]
    bqs:f64[5]. let
    bqt:f64[4] = pjit[
      name=vf
      jaxpr={ lambda bqu:i64[1] bqv:i64[1] bqw:i64[1] bqx:i64[25] bqy:i64[25] bqz:i64[9]
          bra:i64[1] brb:i64[25] brc:i64[25] brd:i64[25] bre:i64[1] brf:i64[1] brg:i64[1]
          brh:i64[25] bri:i64[25] brj:i64[9] brk:i64[1] brl:i64[1] brm:i64[1] brn:i64[1]
          bro:i64[25] brp:i64[25] brq:i64[9] brr:i64[1] brs:i64[1] brt:i64[1] bru:i64[1]
          brv:i64[25] brw:i64[25] brx:i64[9] bry:i64[1] brz:i64[1] bsa:i64[1] bsb:i64[1]
          bsc:i64[25] bsd:i64[25] bse:i64[9] bsf:i64[1] bsg:i64[1] bsh:i64[1] bsi:i64[1]
          bsj:i64[25] bsk:i64[25] bsl:i64[9] bsm:i64[1] bsn:i64[1] bso:i64[1] bsp:i64[1]
          bsq:i64[25] bsr:i64[25] bss:i64[9] bst:i64[1] bsu:i64[1] bsv:i64[1] bsw:i64[1]
          bsx:i64[25] bsy:i64[25] bsz:i64[9] bta:i64[1] btb:i64[1] btc:i64[1] btd:i64[1]
          bte:i64[25] btf:i64[25] btg:i64[9] bth:i64[1] bti:i64[1] btj:i64[1] btk:i64[1]
          btl:i64[25] btm:i64[25] btn:i64[9] bto:i64[1] btp:i64[1] btq:i64[1] btr:i64[1]
          bts:i64[20] btt:i64[20] btu:i64[8] btv:i64[1] btw:i64[20] btx:i64[20] bty:i64[20]
          btz:i64[1] bua:i64[1] bub:i64[1] buc:i64[20] bud:i64[20] bue:i64[8] buf:i64[1]
          bug:i64[1] buh:i64[1] bui:i64[1] buj:i64[20] buk:i64[20] bul:i64[8] bum:i64[1]
          bun:i64[1] buo:i64[1] bup:i64[1] buq:i64[20] bur:i64[20] bus:i64[8] but:i64[1]
          buu:i64[1] buv:i64[1] buw:i64[1] bux:i64[20] buy:i64[20] buz:i64[8] bva:i64[1]
          bvb:i64[1] bvc:i64[1] bvd:i64[1] bve:i64[20] bvf:i64[20] bvg:i64[8] bvh:i64[1]
          bvi:i64[1] bvj:i64[1] bvk:i64[1] bvl:i64[20] bvm:i64[20] bvn:i64[8] bvo:i64[1]
          bvp:i64[1] bvq:i64[1] bvr:i64[1] bvs:i64[20] bvt:i64[20] bvu:i64[8] bvv:i64[1]
          bvw:i64[1] bvx:i64[1] bvy:i64[1] bvz:i64[20] bwa:i64[20] bwb:i64[8] bwc:i64[1]
          bwd:i64[1] bwe:i64[1] bwf:i64[1] bwg:i64[20] bwh:i64[20] bwi:i64[8] bwj:i64[1]
          bwk:i64[1] bwl:i64[1] bwm:i64[1] bwn:i64[20] bwo:i64[20] bwp:i64[8] bwq:i64[1]
          bwr:i64[20] bws:i64[20] bwt:i64[20] bwu:i64[1] bwv:i64[1] bww:i64[1] bwx:i64[20]
          bwy:i64[20] bwz:i64[8] bxa:i64[1] bxb:i64[1] bxc:i64[1] bxd:i64[1] bxe:i64[20]
          bxf:i64[20] bxg:i64[8] bxh:i64[1] bxi:i64[1] bxj:i64[1] bxk:i64[1] bxl:i64[20]
          bxm:i64[20] bxn:i64[8] bxo:i64[1] bxp:i64[1] bxq:i64[1] bxr:i64[1] bxs:i64[20]
          bxt:i64[20] bxu:i64[8] bxv:i64[1] bxw:i64[1] bxx:i64[1] bxy:i64[1] bxz:i64[20]
          bya:i64[20] byb:i64[8] byc:i64[1] byd:i64[1] bye:i64[1] byf:i64[1] byg:i64[20]
          byh:i64[20] byi:i64[8] byj:i64[1] byk:i64[1] byl:i64[1] bym:i64[1] byn:i64[20]
          byo:i64[20] byp:i64[8] byq:i64[1]; bpj:i64[] bpk:f64[1,4] bpl:f64[3] bpm:f64[20]
          bpn:f64[] bpo:f64[25] bpp:f64[20] bpq:f64[1] bpr:f64[0] bps:f64[9] bpt:f64[3]
          bpu:f64[9] bpv:f64[9] bpw:f64[5] bpx:f64[9] bpy:f64[8] bpz:i64[] bqa:f64[0]
          bqb:f64[0] bqc:f64[20] bqd:f64[0] bqe:f64[1] bqf:f64[25] bqg:f64[1] bqh:f64[9]
          bqi:f64[0] bqj:f64[0] bqk:f64[20] bql:f64[0] bqm:f64[8] bqn:f64[0] bqo:f64[0]
          bqp:f64[0] bqq:f64[9] bqr:f64[0] bqs:f64[5]. let
          byr:f64[4] = squeeze[dimensions=(0,)] bpk
          bys:f64[1] = slice[limit_indices=(1,) start_indices=(0,) strides=(1,)] bpl
          byt:f64[] = squeeze[dimensions=(0,)] bys
          byu:f64[1] = slice[limit_indices=(2,) start_indices=(1,) strides=(1,)] bpl
          byv:f64[] = squeeze[dimensions=(0,)] byu
          byw:f64[1] = slice[limit_indices=(3,) start_indices=(2,) strides=(1,)] bpl
          byx:f64[] = squeeze[dimensions=(0,)] byw
          byy:f64[1] = slice[limit_indices=(1,) start_indices=(0,) strides=(1,)] byr
          byz:f64[] = squeeze[dimensions=(0,)] byy
          bza:f64[1] = slice[limit_indices=(2,) start_indices=(1,) strides=(1,)] byr
          bzb:f64[] = squeeze[dimensions=(0,)] bza
          bzc:f64[1] = slice[limit_indices=(3,) start_indices=(2,) strides=(1,)] byr
          bzd:f64[] = squeeze[dimensions=(0,)] bzc
          bze:f64[1] = slice[limit_indices=(4,) start_indices=(3,) strides=(1,)] byr
          bzf:f64[] = squeeze[dimensions=(0,)] bze
          bzg:f64[] = integer_pow[y=2] byz
          bzh:f64[] = integer_pow[y=2] bzb
          bzi:f64[] = add bzg bzh
          bzj:f64[] = sqrt bzi
          bzk:f64[] = atan2 bzb byz
          bzl:bool[] = lt bzj 1e-06:f64[]
          bzm:f64[] = pjit[
            name=_where
            jaxpr={ lambda ; bzl:bool[] bzn:f64[] bzj:f64[]. let
                bzo:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] bzn
                bzm:f64[] = select_n bzl bzj bzo
              in (bzm,) }
          ] bzl 1e-06:f64[] bzj
          bzp:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] bzm
          bzq:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] bzk
          bzr:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] bzd
          bzs:f64[3] = concatenate[dimension=0] bzp bzq bzr
          bzt:f64[3] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(3,)
            sharding=None
          ] 0.0:f64[]
          bzu:f64[1,3] = pjit[name=atleast_2d jaxpr=atleast_2d] bzs
          bzv:f64[1,3] = pjit[name=atleast_2d jaxpr=atleast_2d] bzt
          bzw:f64[3,1] = transpose[permutation=(1, 0)] bzu
          bzx:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] bzw
          bzy:f64[1] = squeeze[dimensions=(0,)] bzx
          bzz:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] bzw
          caa:f64[1] = squeeze[dimensions=(0,)] bzz
          cab:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] bzw
          cac:f64[1] = squeeze[dimensions=(0,)] cab
          cad:bool[1] = eq bzy 0.0:f64[]
          cae:f64[1] = pjit[name=_where jaxpr=_where] cad 1e-12:f64[] bzy
          caf:f64[1,1] = pjit[name=atleast_2d jaxpr=atleast_2d1] cae
          cag:f64[1,1] = transpose[permutation=(1, 0)] caf
          cah:f64[1,1] = pjit[name=atleast_2d jaxpr=atleast_2d1] caa
          cai:f64[1,1] = transpose[permutation=(1, 0)] cah
          caj:f64[1,1] = pjit[name=atleast_2d jaxpr=atleast_2d1] cac
          cak:f64[1,1] = transpose[permutation=(1, 0)] caj
          cal:f64[1,3] = concatenate[dimension=1] cag cai cak
          cam:f64[3,1] = transpose[permutation=(1, 0)] cal
          can:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] cam
          cao:f64[1] = squeeze[dimensions=(0,)] can
          cap:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] cam
          caq:f64[1] = squeeze[dimensions=(0,)] cap
          car:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] cam
          cas:f64[1] = squeeze[dimensions=(0,)] car
          cat:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bqu
          cau:bool[1] = lt cat 0:i64[]
          cav:i64[1] = add cat 1:i64[]
          caw:i64[1] = select_n cau cat cav
          cax:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] caw
          cay:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cax
          caz:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cao cay
          cba:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bqv
          cbb:bool[1] = lt cba 0:i64[]
          cbc:i64[1] = add cba 1:i64[]
          cbd:i64[1] = select_n cbb cba cbc
          cbe:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cbd
          cbf:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cbe
          cbg:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] caq cbf
          cbh:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bqw
          cbi:bool[1] = lt cbh 0:i64[]
          cbj:i64[1] = add cbh 1:i64[]
          cbk:i64[1] = select_n cbi cbh cbj
          cbl:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cbk
          cbm:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cbl
          cbn:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cas cbm
          cbo:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] caz
          cbp:f64[1,25] = pjit[name=zernike_radial jaxpr=zernike_radial] cbo bqx
            bqy
          cbq:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cbg
          cbr:f64[1,9] = pjit[name=fourier jaxpr=fourier] cbq bqz 0:i64[]
          cbs:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cbn
          cbt:f64[1,1] = pjit[name=fourier jaxpr=fourier1] cbs bra 1:i64[] 0:i64[]
          cbu:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bqu
          cbv:bool[1] = lt cbu 0:i64[]
          cbw:i64[1] = add cbu 1:i64[]
          cbx:i64[1] = select_n cbv cbu cbw
          cby:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cbx
          cbz:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cby
          cca:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 25)
            unique_indices=False
          ] cbp cbz
          ccb:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brb
          ccc:bool[25] = lt ccb 0:i64[]
          ccd:i64[25] = add ccb 25:i64[]
          cce:i64[25] = select_n ccc ccb ccd
          ccf:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cce
          ccg:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] ccf
          cch:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cca ccg
          cci:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bqv
          ccj:bool[1] = lt cci 0:i64[]
          cck:i64[1] = add cci 1:i64[]
          ccl:i64[1] = select_n ccj cci cck
          ccm:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ccl
          ccn:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ccm
          cco:f64[1,9] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 9)
            unique_indices=False
          ] cbr ccn
          ccp:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brc
          ccq:bool[25] = lt ccp 0:i64[]
          ccr:i64[25] = add ccp 9:i64[]
          ccs:i64[25] = select_n ccq ccp ccr
          cct:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] ccs
          ccu:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cct
          ccv:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cco ccu
          ccw:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bqw
          ccx:bool[1] = lt ccw 0:i64[]
          ccy:i64[1] = add ccw 1:i64[]
          ccz:i64[1] = select_n ccx ccw ccy
          cda:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ccz
          cdb:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cda
          cdc:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cbt cdb
          cdd:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brd
          cde:bool[25] = lt cdd 0:i64[]
          cdf:i64[25] = add cdd 1:i64[]
          cdg:i64[25] = select_n cde cdd cdf
          cdh:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cdg
          cdi:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cdh
          cdj:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cdc cdi
          cdk:f64[1,25] = mul cch ccv
          cdl:f64[1,25] = mul cdk cdj
          cdm:f64[3,1] = transpose[permutation=(1, 0)] cal
          cdn:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] cdm
          cdo:f64[1] = squeeze[dimensions=(0,)] cdn
          cdp:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] cdm
          cdq:f64[1] = squeeze[dimensions=(0,)] cdp
          cdr:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] cdm
          cds:f64[1] = squeeze[dimensions=(0,)] cdr
          cdt:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bre
          cdu:bool[1] = lt cdt 0:i64[]
          cdv:i64[1] = add cdt 1:i64[]
          cdw:i64[1] = select_n cdu cdt cdv
          cdx:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cdw
          cdy:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cdx
          cdz:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cdo cdy
          cea:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brf
          ceb:bool[1] = lt cea 0:i64[]
          cec:i64[1] = add cea 1:i64[]
          ced:i64[1] = select_n ceb cea cec
          cee:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ced
          cef:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cee
          ceg:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cdq cef
          ceh:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brg
          cei:bool[1] = lt ceh 0:i64[]
          cej:i64[1] = add ceh 1:i64[]
          cek:i64[1] = select_n cei ceh cej
          cel:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cek
          cem:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cel
          cen:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cds cem
          ceo:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cdz
          cep:f64[1,25] = pjit[name=zernike_radial jaxpr=zernike_radial1] ceo brh
            bri
          ceq:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ceg
          cer:f64[1,9] = pjit[name=fourier jaxpr=fourier] ceq brj 0:i64[]
          ces:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cen
          cet:f64[1,1] = pjit[name=fourier jaxpr=fourier1] ces brk 1:i64[] 0:i64[]
          ceu:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bre
          cev:bool[1] = lt ceu 0:i64[]
          cew:i64[1] = add ceu 1:i64[]
          cex:i64[1] = select_n cev ceu cew
          cey:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cex
          cez:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cey
          cfa:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 25)
            unique_indices=False
          ] cep cez
          cfb:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brb
          cfc:bool[25] = lt cfb 0:i64[]
          cfd:i64[25] = add cfb 25:i64[]
          cfe:i64[25] = select_n cfc cfb cfd
          cff:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cfe
          cfg:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cff
          cfh:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cfa cfg
          cfi:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brf
          cfj:bool[1] = lt cfi 0:i64[]
          cfk:i64[1] = add cfi 1:i64[]
          cfl:i64[1] = select_n cfj cfi cfk
          cfm:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cfl
          cfn:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cfm
          cfo:f64[1,9] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 9)
            unique_indices=False
          ] cer cfn
          cfp:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brc
          cfq:bool[25] = lt cfp 0:i64[]
          cfr:i64[25] = add cfp 9:i64[]
          cfs:i64[25] = select_n cfq cfp cfr
          cft:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cfs
          cfu:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cft
          cfv:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cfo cfu
          cfw:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brg
          cfx:bool[1] = lt cfw 0:i64[]
          cfy:i64[1] = add cfw 1:i64[]
          cfz:i64[1] = select_n cfx cfw cfy
          cga:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cfz
          cgb:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cga
          cgc:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cet cgb
          cgd:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brd
          cge:bool[25] = lt cgd 0:i64[]
          cgf:i64[25] = add cgd 1:i64[]
          cgg:i64[25] = select_n cge cgd cgf
          cgh:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cgg
          cgi:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cgh
          cgj:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cgc cgi
          cgk:f64[1,25] = mul cfh cfv
          cgl:f64[1,25] = mul cgk cgj
          cgm:f64[3,1] = transpose[permutation=(1, 0)] cal
          cgn:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] cgm
          cgo:f64[1] = squeeze[dimensions=(0,)] cgn
          cgp:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] cgm
          cgq:f64[1] = squeeze[dimensions=(0,)] cgp
          cgr:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] cgm
          cgs:f64[1] = squeeze[dimensions=(0,)] cgr
          cgt:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brl
          cgu:bool[1] = lt cgt 0:i64[]
          cgv:i64[1] = add cgt 1:i64[]
          cgw:i64[1] = select_n cgu cgt cgv
          cgx:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cgw
          cgy:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cgx
          cgz:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cgo cgy
          cha:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brm
          chb:bool[1] = lt cha 0:i64[]
          chc:i64[1] = add cha 1:i64[]
          chd:i64[1] = select_n chb cha chc
          che:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] chd
          chf:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] che
          chg:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cgq chf
          chh:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brn
          chi:bool[1] = lt chh 0:i64[]
          chj:i64[1] = add chh 1:i64[]
          chk:i64[1] = select_n chi chh chj
          chl:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] chk
          chm:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] chl
          chn:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cgs chm
          cho:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cgz
          chp:f64[1,25] = pjit[
            name=zernike_radial
            jaxpr={ lambda ; cho:f64[1,1] bro:i64[25] brp:i64[25]. let
                chq:i64[25] = abs brp
                chr:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] chq
                chs:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] bro
                cht:f64[25] = sub chs chr
                chu:f64[25] = pjit[name=floor_divide jaxpr=floor_divide] cht 2:i64[]
                chv:f64[25] = pow -1.0:f64[] chu
                chw:f64[1,1] = integer_pow[y=2] cho
                chx:f64[1,1] = mul 2.0:f64[] chw
                chy:f64[1,1] = sub 1.0:f64[] chx
                chz:f64[1,25] = custom_jvp_call[
                  name=_jacobi
                  call_jaxpr={ lambda ; cia:f64[25] cib:f64[25] cic:i64[] cid:f64[1,1]. let
                      cie:f64[1,25] = pjit[name=_jacobi jaxpr=_jacobi] cia cib cic
                        cid 0:i64[]
                    in (cie,) }
                  jvp=_jacobi_jvp
                  symbolic_zeros=False
                ] chu chr 0:i64[] chy
                cif:f64[1,25] = custom_jvp_call[
                  name=_jacobi
                  call_jaxpr={ lambda ; cig:f64[25] cih:f64[25] cii:i64[] cij:f64[1,1]. let
                      cik:f64[1,25] = pjit[name=_jacobi jaxpr=_jacobi] cig cih cii
                        cij 1:i64[]
                    in (cik,) }
                  jvp=_jacobi_jvp
                  symbolic_zeros=False
                ] chu chr 0:i64[] chy
                cil:f64[1,25] = custom_jvp_call[
                  name=_jacobi
                  call_jaxpr={ lambda ; cim:f64[25] cin:f64[25] cio:i64[] cip:f64[1,1]. let
                      ciq:f64[1,25] = pjit[name=_jacobi jaxpr=_jacobi] cim cin cio
                        cip 2:i64[]
                    in (ciq,) }
                  jvp=_jacobi_jvp
                  symbolic_zeros=False
                ] chu chr 0:i64[] chy
                cir:f64[25] = sub chr 1.0:f64[]
                cis:f64[25] = mul cir chr
                cit:f64[25] = sub chr 2.0:f64[]
                ciu:f64[25] = max cit 0.0:f64[]
                civ:f64[1,25] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 25)
                  sharding=None
                ] ciu
                ciw:f64[1,25] = pow cho civ
                cix:f64[1,25] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 25)
                  sharding=None
                ] cis
                ciy:f64[1,25] = mul cix ciw
                ciz:f64[1,25] = mul ciy chz
                cja:f64[25] = mul 2.0:f64[] chr
                cjb:f64[25] = add cja 1.0:f64[]
                cjc:f64[25] = mul 4.0:f64[] cjb
                cjd:f64[1,25] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 25)
                  sharding=None
                ] chr
                cje:f64[1,25] = pow cho cjd
                cjf:f64[1,25] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 25)
                  sharding=None
                ] cjc
                cjg:f64[1,25] = mul cjf cje
                cjh:f64[1,25] = mul cjg cif
                cji:f64[1,25] = sub ciz cjh
                cjj:f64[25] = add chr 2.0:f64[]
                cjk:f64[1,25] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 25)
                  sharding=None
                ] cjj
                cjl:f64[1,25] = pow cho cjk
                cjm:f64[1,25] = mul 16.0:f64[] cjl
                cjn:f64[1,25] = mul cjm cil
                cjo:f64[1,25] = add cji cjn
                cjp:f64[25] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] bro
                cjq:f64[25] = sub cjp chr
                cjr:f64[25] = pjit[name=remainder jaxpr=remainder] cjq 2:i64[]
                cjs:bool[25] = eq cjr 0.0:f64[]
                cjt:f64[1,25] = pjit[name=_where jaxpr=_where2] cjs cjo 0.0:f64[]
                cju:f64[1,25] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 25)
                  sharding=None
                ] chv
                chp:f64[1,25] = mul cju cjt
              in (chp,) }
          ] cho bro brp
          cjv:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] chg
          cjw:f64[1,9] = pjit[name=fourier jaxpr=fourier] cjv brq 0:i64[]
          cjx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] chn
          cjy:f64[1,1] = pjit[name=fourier jaxpr=fourier1] cjx brr 1:i64[] 0:i64[]
          cjz:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brl
          cka:bool[1] = lt cjz 0:i64[]
          ckb:i64[1] = add cjz 1:i64[]
          ckc:i64[1] = select_n cka cjz ckb
          ckd:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ckc
          cke:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ckd
          ckf:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 25)
            unique_indices=False
          ] chp cke
          ckg:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brb
          ckh:bool[25] = lt ckg 0:i64[]
          cki:i64[25] = add ckg 25:i64[]
          ckj:i64[25] = select_n ckh ckg cki
          ckk:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] ckj
          ckl:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] ckk
          ckm:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] ckf ckl
          ckn:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brm
          cko:bool[1] = lt ckn 0:i64[]
          ckp:i64[1] = add ckn 1:i64[]
          ckq:i64[1] = select_n cko ckn ckp
          ckr:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ckq
          cks:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ckr
          ckt:f64[1,9] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 9)
            unique_indices=False
          ] cjw cks
          cku:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brc
          ckv:bool[25] = lt cku 0:i64[]
          ckw:i64[25] = add cku 9:i64[]
          ckx:i64[25] = select_n ckv cku ckw
          cky:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] ckx
          ckz:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cky
          cla:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] ckt ckz
          clb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brn
          clc:bool[1] = lt clb 0:i64[]
          cld:i64[1] = add clb 1:i64[]
          cle:i64[1] = select_n clc clb cld
          clf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cle
          clg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] clf
          clh:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cjy clg
          cli:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brd
          clj:bool[25] = lt cli 0:i64[]
          clk:i64[25] = add cli 1:i64[]
          cll:i64[25] = select_n clj cli clk
          clm:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cll
          cln:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] clm
          clo:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] clh cln
          clp:f64[1,25] = mul ckm cla
          clq:f64[1,25] = mul clp clo
          clr:f64[3,1] = transpose[permutation=(1, 0)] cal
          cls:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] clr
          clt:f64[1] = squeeze[dimensions=(0,)] cls
          clu:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] clr
          clv:f64[1] = squeeze[dimensions=(0,)] clu
          clw:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] clr
          clx:f64[1] = squeeze[dimensions=(0,)] clw
          cly:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brs
          clz:bool[1] = lt cly 0:i64[]
          cma:i64[1] = add cly 1:i64[]
          cmb:i64[1] = select_n clz cly cma
          cmc:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cmb
          cmd:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cmc
          cme:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] clt cmd
          cmf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brt
          cmg:bool[1] = lt cmf 0:i64[]
          cmh:i64[1] = add cmf 1:i64[]
          cmi:i64[1] = select_n cmg cmf cmh
          cmj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cmi
          cmk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cmj
          cml:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] clv cmk
          cmm:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bru
          cmn:bool[1] = lt cmm 0:i64[]
          cmo:i64[1] = add cmm 1:i64[]
          cmp:i64[1] = select_n cmn cmm cmo
          cmq:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cmp
          cmr:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cmq
          cms:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] clx cmr
          cmt:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cme
          cmu:f64[1,25] = pjit[name=zernike_radial jaxpr=zernike_radial] cmt brv
            brw
          cmv:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cml
          cmw:f64[1,9] = pjit[name=fourier jaxpr=fourier] cmv brx 1:i64[]
          cmx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cms
          cmy:f64[1,1] = pjit[name=fourier jaxpr=fourier1] cmx bry 1:i64[] 0:i64[]
          cmz:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brs
          cna:bool[1] = lt cmz 0:i64[]
          cnb:i64[1] = add cmz 1:i64[]
          cnc:i64[1] = select_n cna cmz cnb
          cnd:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cnc
          cne:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cnd
          cnf:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 25)
            unique_indices=False
          ] cmu cne
          cng:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brb
          cnh:bool[25] = lt cng 0:i64[]
          cni:i64[25] = add cng 25:i64[]
          cnj:i64[25] = select_n cnh cng cni
          cnk:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cnj
          cnl:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cnk
          cnm:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cnf cnl
          cnn:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brt
          cno:bool[1] = lt cnn 0:i64[]
          cnp:i64[1] = add cnn 1:i64[]
          cnq:i64[1] = select_n cno cnn cnp
          cnr:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cnq
          cns:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cnr
          cnt:f64[1,9] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 9)
            unique_indices=False
          ] cmw cns
          cnu:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brc
          cnv:bool[25] = lt cnu 0:i64[]
          cnw:i64[25] = add cnu 9:i64[]
          cnx:i64[25] = select_n cnv cnu cnw
          cny:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cnx
          cnz:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cny
          coa:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cnt cnz
          cob:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bru
          coc:bool[1] = lt cob 0:i64[]
          cod:i64[1] = add cob 1:i64[]
          coe:i64[1] = select_n coc cob cod
          cof:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] coe
          cog:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cof
          coh:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cmy cog
          coi:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brd
          coj:bool[25] = lt coi 0:i64[]
          cok:i64[25] = add coi 1:i64[]
          col:i64[25] = select_n coj coi cok
          com:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] col
          con:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] com
          coo:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] coh con
          cop:f64[1,25] = mul cnm coa
          coq:f64[1,25] = mul cop coo
          cor:f64[3,1] = transpose[permutation=(1, 0)] cal
          cos:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] cor
          cot:f64[1] = squeeze[dimensions=(0,)] cos
          cou:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] cor
          cov:f64[1] = squeeze[dimensions=(0,)] cou
          cow:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] cor
          cox:f64[1] = squeeze[dimensions=(0,)] cow
          coy:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brz
          coz:bool[1] = lt coy 0:i64[]
          cpa:i64[1] = add coy 1:i64[]
          cpb:i64[1] = select_n coz coy cpa
          cpc:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cpb
          cpd:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cpc
          cpe:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cot cpd
          cpf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsa
          cpg:bool[1] = lt cpf 0:i64[]
          cph:i64[1] = add cpf 1:i64[]
          cpi:i64[1] = select_n cpg cpf cph
          cpj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cpi
          cpk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cpj
          cpl:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cov cpk
          cpm:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsb
          cpn:bool[1] = lt cpm 0:i64[]
          cpo:i64[1] = add cpm 1:i64[]
          cpp:i64[1] = select_n cpn cpm cpo
          cpq:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cpp
          cpr:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cpq
          cps:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cox cpr
          cpt:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cpe
          cpu:f64[1,25] = pjit[name=zernike_radial jaxpr=zernike_radial1] cpt bsc
            bsd
          cpv:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cpl
          cpw:f64[1,9] = pjit[name=fourier jaxpr=fourier] cpv bse 1:i64[]
          cpx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cps
          cpy:f64[1,1] = pjit[name=fourier jaxpr=fourier1] cpx bsf 1:i64[] 0:i64[]
          cpz:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brz
          cqa:bool[1] = lt cpz 0:i64[]
          cqb:i64[1] = add cpz 1:i64[]
          cqc:i64[1] = select_n cqa cpz cqb
          cqd:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cqc
          cqe:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cqd
          cqf:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 25)
            unique_indices=False
          ] cpu cqe
          cqg:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brb
          cqh:bool[25] = lt cqg 0:i64[]
          cqi:i64[25] = add cqg 25:i64[]
          cqj:i64[25] = select_n cqh cqg cqi
          cqk:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cqj
          cql:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cqk
          cqm:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cqf cql
          cqn:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsa
          cqo:bool[1] = lt cqn 0:i64[]
          cqp:i64[1] = add cqn 1:i64[]
          cqq:i64[1] = select_n cqo cqn cqp
          cqr:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cqq
          cqs:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cqr
          cqt:f64[1,9] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 9)
            unique_indices=False
          ] cpw cqs
          cqu:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brc
          cqv:bool[25] = lt cqu 0:i64[]
          cqw:i64[25] = add cqu 9:i64[]
          cqx:i64[25] = select_n cqv cqu cqw
          cqy:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cqx
          cqz:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cqy
          cra:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cqt cqz
          crb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsb
          crc:bool[1] = lt crb 0:i64[]
          crd:i64[1] = add crb 1:i64[]
          cre:i64[1] = select_n crc crb crd
          crf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cre
          crg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] crf
          crh:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cpy crg
          cri:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brd
          crj:bool[25] = lt cri 0:i64[]
          crk:i64[25] = add cri 1:i64[]
          crl:i64[25] = select_n crj cri crk
          crm:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] crl
          crn:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] crm
          cro:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] crh crn
          crp:f64[1,25] = mul cqm cra
          crq:f64[1,25] = mul crp cro
          crr:f64[3,1] = transpose[permutation=(1, 0)] cal
          crs:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] crr
          crt:f64[1] = squeeze[dimensions=(0,)] crs
          cru:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] crr
          crv:f64[1] = squeeze[dimensions=(0,)] cru
          crw:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] crr
          crx:f64[1] = squeeze[dimensions=(0,)] crw
          cry:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsg
          crz:bool[1] = lt cry 0:i64[]
          csa:i64[1] = add cry 1:i64[]
          csb:i64[1] = select_n crz cry csa
          csc:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] csb
          csd:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] csc
          cse:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] crt csd
          csf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsh
          csg:bool[1] = lt csf 0:i64[]
          csh:i64[1] = add csf 1:i64[]
          csi:i64[1] = select_n csg csf csh
          csj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] csi
          csk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] csj
          csl:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] crv csk
          csm:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsi
          csn:bool[1] = lt csm 0:i64[]
          cso:i64[1] = add csm 1:i64[]
          csp:i64[1] = select_n csn csm cso
          csq:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] csp
          csr:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] csq
          css:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] crx csr
          cst:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cse
          csu:f64[1,25] = pjit[name=zernike_radial jaxpr=zernike_radial] cst bsj
            bsk
          csv:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] csl
          csw:f64[1,9] = pjit[name=fourier jaxpr=fourier] csv bsl 2:i64[]
          csx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] css
          csy:f64[1,1] = pjit[name=fourier jaxpr=fourier1] csx bsm 1:i64[] 0:i64[]
          csz:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsg
          cta:bool[1] = lt csz 0:i64[]
          ctb:i64[1] = add csz 1:i64[]
          ctc:i64[1] = select_n cta csz ctb
          ctd:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ctc
          cte:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ctd
          ctf:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 25)
            unique_indices=False
          ] csu cte
          ctg:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brb
          cth:bool[25] = lt ctg 0:i64[]
          cti:i64[25] = add ctg 25:i64[]
          ctj:i64[25] = select_n cth ctg cti
          ctk:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] ctj
          ctl:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] ctk
          ctm:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] ctf ctl
          ctn:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsh
          cto:bool[1] = lt ctn 0:i64[]
          ctp:i64[1] = add ctn 1:i64[]
          ctq:i64[1] = select_n cto ctn ctp
          ctr:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ctq
          cts:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ctr
          ctt:f64[1,9] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 9)
            unique_indices=False
          ] csw cts
          ctu:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brc
          ctv:bool[25] = lt ctu 0:i64[]
          ctw:i64[25] = add ctu 9:i64[]
          ctx:i64[25] = select_n ctv ctu ctw
          cty:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] ctx
          ctz:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cty
          cua:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] ctt ctz
          cub:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsi
          cuc:bool[1] = lt cub 0:i64[]
          cud:i64[1] = add cub 1:i64[]
          cue:i64[1] = select_n cuc cub cud
          cuf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cue
          cug:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cuf
          cuh:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] csy cug
          cui:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brd
          cuj:bool[25] = lt cui 0:i64[]
          cuk:i64[25] = add cui 1:i64[]
          cul:i64[25] = select_n cuj cui cuk
          cum:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cul
          cun:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cum
          cuo:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cuh cun
          cup:f64[1,25] = mul ctm cua
          cuq:f64[1,25] = mul cup cuo
          cur:f64[3,1] = transpose[permutation=(1, 0)] cal
          cus:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] cur
          cut:f64[1] = squeeze[dimensions=(0,)] cus
          cuu:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] cur
          cuv:f64[1] = squeeze[dimensions=(0,)] cuu
          cuw:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] cur
          cux:f64[1] = squeeze[dimensions=(0,)] cuw
          cuy:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsn
          cuz:bool[1] = lt cuy 0:i64[]
          cva:i64[1] = add cuy 1:i64[]
          cvb:i64[1] = select_n cuz cuy cva
          cvc:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cvb
          cvd:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cvc
          cve:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cut cvd
          cvf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bso
          cvg:bool[1] = lt cvf 0:i64[]
          cvh:i64[1] = add cvf 1:i64[]
          cvi:i64[1] = select_n cvg cvf cvh
          cvj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cvi
          cvk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cvj
          cvl:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cuv cvk
          cvm:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsp
          cvn:bool[1] = lt cvm 0:i64[]
          cvo:i64[1] = add cvm 1:i64[]
          cvp:i64[1] = select_n cvn cvm cvo
          cvq:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cvp
          cvr:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cvq
          cvs:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cux cvr
          cvt:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cve
          cvu:f64[1,25] = pjit[name=zernike_radial jaxpr=zernike_radial] cvt bsq
            bsr
          cvv:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cvl
          cvw:f64[1,9] = pjit[name=fourier jaxpr=fourier] cvv bss 0:i64[]
          cvx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cvs
          cvy:f64[1,1] = pjit[name=fourier jaxpr=fourier1] cvx bst 1:i64[] 1:i64[]
          cvz:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsn
          cwa:bool[1] = lt cvz 0:i64[]
          cwb:i64[1] = add cvz 1:i64[]
          cwc:i64[1] = select_n cwa cvz cwb
          cwd:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cwc
          cwe:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cwd
          cwf:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 25)
            unique_indices=False
          ] cvu cwe
          cwg:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brb
          cwh:bool[25] = lt cwg 0:i64[]
          cwi:i64[25] = add cwg 25:i64[]
          cwj:i64[25] = select_n cwh cwg cwi
          cwk:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cwj
          cwl:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cwk
          cwm:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cwf cwl
          cwn:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bso
          cwo:bool[1] = lt cwn 0:i64[]
          cwp:i64[1] = add cwn 1:i64[]
          cwq:i64[1] = select_n cwo cwn cwp
          cwr:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cwq
          cws:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cwr
          cwt:f64[1,9] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 9)
            unique_indices=False
          ] cvw cws
          cwu:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brc
          cwv:bool[25] = lt cwu 0:i64[]
          cww:i64[25] = add cwu 9:i64[]
          cwx:i64[25] = select_n cwv cwu cww
          cwy:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cwx
          cwz:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cwy
          cxa:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cwt cwz
          cxb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsp
          cxc:bool[1] = lt cxb 0:i64[]
          cxd:i64[1] = add cxb 1:i64[]
          cxe:i64[1] = select_n cxc cxb cxd
          cxf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cxe
          cxg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cxf
          cxh:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cvy cxg
          cxi:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brd
          cxj:bool[25] = lt cxi 0:i64[]
          cxk:i64[25] = add cxi 1:i64[]
          cxl:i64[25] = select_n cxj cxi cxk
          cxm:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] cxl
          cxn:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] cxm
          cxo:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cxh cxn
          cxp:f64[1,25] = mul cwm cxa
          cxq:f64[1,25] = mul cxp cxo
          cxr:f64[3,1] = transpose[permutation=(1, 0)] cal
          cxs:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] cxr
          cxt:f64[1] = squeeze[dimensions=(0,)] cxs
          cxu:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] cxr
          cxv:f64[1] = squeeze[dimensions=(0,)] cxu
          cxw:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] cxr
          cxx:f64[1] = squeeze[dimensions=(0,)] cxw
          cxy:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsu
          cxz:bool[1] = lt cxy 0:i64[]
          cya:i64[1] = add cxy 1:i64[]
          cyb:i64[1] = select_n cxz cxy cya
          cyc:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cyb
          cyd:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cyc
          cye:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cxt cyd
          cyf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsv
          cyg:bool[1] = lt cyf 0:i64[]
          cyh:i64[1] = add cyf 1:i64[]
          cyi:i64[1] = select_n cyg cyf cyh
          cyj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cyi
          cyk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cyj
          cyl:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cxv cyk
          cym:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsw
          cyn:bool[1] = lt cym 0:i64[]
          cyo:i64[1] = add cym 1:i64[]
          cyp:i64[1] = select_n cyn cym cyo
          cyq:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] cyp
          cyr:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cyq
          cys:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] cxx cyr
          cyt:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cye
          cyu:f64[1,25] = pjit[name=zernike_radial jaxpr=zernike_radial1] cyt bsx
            bsy
          cyv:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cyl
          cyw:f64[1,9] = pjit[name=fourier jaxpr=fourier] cyv bsz 0:i64[]
          cyx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] cys
          cyy:f64[1,1] = pjit[name=fourier jaxpr=fourier1] cyx bta 1:i64[] 1:i64[]
          cyz:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsu
          cza:bool[1] = lt cyz 0:i64[]
          czb:i64[1] = add cyz 1:i64[]
          czc:i64[1] = select_n cza cyz czb
          czd:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] czc
          cze:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] czd
          czf:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 25)
            unique_indices=False
          ] cyu cze
          czg:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brb
          czh:bool[25] = lt czg 0:i64[]
          czi:i64[25] = add czg 25:i64[]
          czj:i64[25] = select_n czh czg czi
          czk:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] czj
          czl:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] czk
          czm:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] czf czl
          czn:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsv
          czo:bool[1] = lt czn 0:i64[]
          czp:i64[1] = add czn 1:i64[]
          czq:i64[1] = select_n czo czn czp
          czr:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] czq
          czs:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] czr
          czt:f64[1,9] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 9)
            unique_indices=False
          ] cyw czs
          czu:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brc
          czv:bool[25] = lt czu 0:i64[]
          czw:i64[25] = add czu 9:i64[]
          czx:i64[25] = select_n czv czu czw
          czy:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] czx
          czz:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] czy
          daa:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] czt czz
          dab:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bsw
          dac:bool[1] = lt dab 0:i64[]
          dad:i64[1] = add dab 1:i64[]
          dae:i64[1] = select_n dac dab dad
          daf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dae
          dag:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] daf
          dah:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] cyy dag
          dai:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brd
          daj:bool[25] = lt dai 0:i64[]
          dak:i64[25] = add dai 1:i64[]
          dal:i64[25] = select_n daj dai dak
          dam:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] dal
          dan:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] dam
          dao:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dah dan
          dap:f64[1,25] = mul czm daa
          daq:f64[1,25] = mul dap dao
          dar:f64[3,1] = transpose[permutation=(1, 0)] cal
          das:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] dar
          dat:f64[1] = squeeze[dimensions=(0,)] das
          dau:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] dar
          dav:f64[1] = squeeze[dimensions=(0,)] dau
          daw:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] dar
          dax:f64[1] = squeeze[dimensions=(0,)] daw
          day:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btb
          daz:bool[1] = lt day 0:i64[]
          dba:i64[1] = add day 1:i64[]
          dbb:i64[1] = select_n daz day dba
          dbc:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dbb
          dbd:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dbc
          dbe:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dat dbd
          dbf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btc
          dbg:bool[1] = lt dbf 0:i64[]
          dbh:i64[1] = add dbf 1:i64[]
          dbi:i64[1] = select_n dbg dbf dbh
          dbj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dbi
          dbk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dbj
          dbl:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dav dbk
          dbm:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btd
          dbn:bool[1] = lt dbm 0:i64[]
          dbo:i64[1] = add dbm 1:i64[]
          dbp:i64[1] = select_n dbn dbm dbo
          dbq:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dbp
          dbr:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dbq
          dbs:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dax dbr
          dbt:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dbe
          dbu:f64[1,25] = pjit[name=zernike_radial jaxpr=zernike_radial] dbt bte
            btf
          dbv:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dbl
          dbw:f64[1,9] = pjit[name=fourier jaxpr=fourier] dbv btg 1:i64[]
          dbx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dbs
          dby:f64[1,1] = pjit[name=fourier jaxpr=fourier1] dbx bth 1:i64[] 1:i64[]
          dbz:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btb
          dca:bool[1] = lt dbz 0:i64[]
          dcb:i64[1] = add dbz 1:i64[]
          dcc:i64[1] = select_n dca dbz dcb
          dcd:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dcc
          dce:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dcd
          dcf:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 25)
            unique_indices=False
          ] dbu dce
          dcg:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brb
          dch:bool[25] = lt dcg 0:i64[]
          dci:i64[25] = add dcg 25:i64[]
          dcj:i64[25] = select_n dch dcg dci
          dck:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] dcj
          dcl:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] dck
          dcm:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dcf dcl
          dcn:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btc
          dco:bool[1] = lt dcn 0:i64[]
          dcp:i64[1] = add dcn 1:i64[]
          dcq:i64[1] = select_n dco dcn dcp
          dcr:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dcq
          dcs:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dcr
          dct:f64[1,9] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 9)
            unique_indices=False
          ] dbw dcs
          dcu:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brc
          dcv:bool[25] = lt dcu 0:i64[]
          dcw:i64[25] = add dcu 9:i64[]
          dcx:i64[25] = select_n dcv dcu dcw
          dcy:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] dcx
          dcz:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] dcy
          dda:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dct dcz
          ddb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btd
          ddc:bool[1] = lt ddb 0:i64[]
          ddd:i64[1] = add ddb 1:i64[]
          dde:i64[1] = select_n ddc ddb ddd
          ddf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dde
          ddg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ddf
          ddh:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dby ddg
          ddi:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brd
          ddj:bool[25] = lt ddi 0:i64[]
          ddk:i64[25] = add ddi 1:i64[]
          ddl:i64[25] = select_n ddj ddi ddk
          ddm:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] ddl
          ddn:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] ddm
          ddo:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] ddh ddn
          ddp:f64[1,25] = mul dcm dda
          ddq:f64[1,25] = mul ddp ddo
          ddr:f64[3,1] = transpose[permutation=(1, 0)] cal
          dds:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] ddr
          ddt:f64[1] = squeeze[dimensions=(0,)] dds
          ddu:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] ddr
          ddv:f64[1] = squeeze[dimensions=(0,)] ddu
          ddw:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] ddr
          ddx:f64[1] = squeeze[dimensions=(0,)] ddw
          ddy:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bti
          ddz:bool[1] = lt ddy 0:i64[]
          dea:i64[1] = add ddy 1:i64[]
          deb:i64[1] = select_n ddz ddy dea
          dec:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] deb
          ded:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dec
          dee:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] ddt ded
          def:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btj
          deg:bool[1] = lt def 0:i64[]
          deh:i64[1] = add def 1:i64[]
          dei:i64[1] = select_n deg def deh
          dej:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dei
          dek:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dej
          del:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] ddv dek
          dem:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btk
          den:bool[1] = lt dem 0:i64[]
          deo:i64[1] = add dem 1:i64[]
          dep:i64[1] = select_n den dem deo
          deq:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dep
          der:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] deq
          des:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] ddx der
          det:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dee
          deu:f64[1,25] = pjit[name=zernike_radial jaxpr=zernike_radial] det btl
            btm
          dev:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] del
          dew:f64[1,9] = pjit[name=fourier jaxpr=fourier] dev btn 0:i64[]
          dex:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] des
          dey:f64[1,1] = pjit[name=fourier jaxpr=fourier1] dex bto 1:i64[] 2:i64[]
          dez:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bti
          dfa:bool[1] = lt dez 0:i64[]
          dfb:i64[1] = add dez 1:i64[]
          dfc:i64[1] = select_n dfa dez dfb
          dfd:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dfc
          dfe:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dfd
          dff:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 25)
            unique_indices=False
          ] deu dfe
          dfg:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brb
          dfh:bool[25] = lt dfg 0:i64[]
          dfi:i64[25] = add dfg 25:i64[]
          dfj:i64[25] = select_n dfh dfg dfi
          dfk:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] dfj
          dfl:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] dfk
          dfm:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dff dfl
          dfn:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btj
          dfo:bool[1] = lt dfn 0:i64[]
          dfp:i64[1] = add dfn 1:i64[]
          dfq:i64[1] = select_n dfo dfn dfp
          dfr:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dfq
          dfs:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dfr
          dft:f64[1,9] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 9)
            unique_indices=False
          ] dew dfs
          dfu:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brc
          dfv:bool[25] = lt dfu 0:i64[]
          dfw:i64[25] = add dfu 9:i64[]
          dfx:i64[25] = select_n dfv dfu dfw
          dfy:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] dfx
          dfz:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] dfy
          dga:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dft dfz
          dgb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btk
          dgc:bool[1] = lt dgb 0:i64[]
          dgd:i64[1] = add dgb 1:i64[]
          dge:i64[1] = select_n dgc dgb dgd
          dgf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dge
          dgg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dgf
          dgh:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dey dgg
          dgi:i64[25] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] brd
          dgj:bool[25] = lt dgi 0:i64[]
          dgk:i64[25] = add dgi 1:i64[]
          dgl:i64[25] = select_n dgj dgi dgk
          dgm:i32[25] = convert_element_type[new_dtype=int32 weak_type=False] dgl
          dgn:i32[25,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(25, 1)
            sharding=None
          ] dgm
          dgo:f64[1,25] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dgh dgn
          dgp:f64[1,25] = mul dfm dga
          dgq:f64[1,25] = mul dgp dgo
          dgr:f64[3,1] = transpose[permutation=(1, 0)] cal
          dgs:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] dgr
          dgt:f64[1] = squeeze[dimensions=(0,)] dgs
          dgu:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] dgr
          dgv:f64[1] = squeeze[dimensions=(0,)] dgu
          dgw:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] dgr
          dgx:f64[1] = squeeze[dimensions=(0,)] dgw
          dgy:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btp
          dgz:bool[1] = lt dgy 0:i64[]
          dha:i64[1] = add dgy 1:i64[]
          dhb:i64[1] = select_n dgz dgy dha
          dhc:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dhb
          dhd:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dhc
          dhe:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dgt dhd
          dhf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btq
          dhg:bool[1] = lt dhf 0:i64[]
          dhh:i64[1] = add dhf 1:i64[]
          dhi:i64[1] = select_n dhg dhf dhh
          dhj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dhi
          dhk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dhj
          dhl:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dgv dhk
          dhm:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btr
          dhn:bool[1] = lt dhm 0:i64[]
          dho:i64[1] = add dhm 1:i64[]
          dhp:i64[1] = select_n dhn dhm dho
          dhq:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dhp
          dhr:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dhq
          dhs:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dgx dhr
          dht:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dhe
          dhu:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] dht bts
            btt
          dhv:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dhl
          dhw:f64[1,8] = pjit[name=fourier jaxpr=fourier2] dhv btu 0:i64[]
          dhx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dhs
          dhy:f64[1,1] = pjit[name=fourier jaxpr=fourier1] dhx btv 1:i64[] 0:i64[]
          dhz:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btp
          dia:bool[1] = lt dhz 0:i64[]
          dib:i64[1] = add dhz 1:i64[]
          dic:i64[1] = select_n dia dhz dib
          did:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dic
          die:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] did
          dif:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] dhu die
          dig:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btw
          dih:bool[20] = lt dig 0:i64[]
          dii:i64[20] = add dig 20:i64[]
          dij:i64[20] = select_n dih dig dii
          dik:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dij
          dil:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] dik
          dim:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dif dil
          din:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btq
          dio:bool[1] = lt din 0:i64[]
          dip:i64[1] = add din 1:i64[]
          diq:i64[1] = select_n dio din dip
          dir:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] diq
          dis:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dir
          dit:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] dhw dis
          diu:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btx
          div:bool[20] = lt diu 0:i64[]
          diw:i64[20] = add diu 8:i64[]
          dix:i64[20] = select_n div diu diw
          diy:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dix
          diz:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] diy
          dja:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dit diz
          djb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btr
          djc:bool[1] = lt djb 0:i64[]
          djd:i64[1] = add djb 1:i64[]
          dje:i64[1] = select_n djc djb djd
          djf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dje
          djg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] djf
          djh:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dhy djg
          dji:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bty
          djj:bool[20] = lt dji 0:i64[]
          djk:i64[20] = add dji 1:i64[]
          djl:i64[20] = select_n djj dji djk
          djm:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] djl
          djn:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] djm
          djo:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] djh djn
          djp:f64[1,20] = mul dim dja
          _:f64[1,20] = mul djp djo
          djq:f64[3,1] = transpose[permutation=(1, 0)] cal
          djr:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] djq
          djs:f64[1] = squeeze[dimensions=(0,)] djr
          djt:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] djq
          dju:f64[1] = squeeze[dimensions=(0,)] djt
          djv:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] djq
          djw:f64[1] = squeeze[dimensions=(0,)] djv
          djx:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btz
          djy:bool[1] = lt djx 0:i64[]
          djz:i64[1] = add djx 1:i64[]
          dka:i64[1] = select_n djy djx djz
          dkb:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dka
          dkc:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dkb
          dkd:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] djs dkc
          dke:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bua
          dkf:bool[1] = lt dke 0:i64[]
          dkg:i64[1] = add dke 1:i64[]
          dkh:i64[1] = select_n dkf dke dkg
          dki:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dkh
          dkj:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dki
          dkk:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dju dkj
          dkl:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bub
          dkm:bool[1] = lt dkl 0:i64[]
          dkn:i64[1] = add dkl 1:i64[]
          dko:i64[1] = select_n dkm dkl dkn
          dkp:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dko
          dkq:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dkp
          dkr:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] djw dkq
          dks:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dkd
          dkt:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial3] dks buc
            bud
          dku:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dkk
          dkv:f64[1,8] = pjit[name=fourier jaxpr=fourier2] dku bue 0:i64[]
          dkw:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dkr
          dkx:f64[1,1] = pjit[name=fourier jaxpr=fourier1] dkw buf 1:i64[] 0:i64[]
          dky:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btz
          dkz:bool[1] = lt dky 0:i64[]
          dla:i64[1] = add dky 1:i64[]
          dlb:i64[1] = select_n dkz dky dla
          dlc:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dlb
          dld:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dlc
          dle:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] dkt dld
          dlf:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btw
          dlg:bool[20] = lt dlf 0:i64[]
          dlh:i64[20] = add dlf 20:i64[]
          dli:i64[20] = select_n dlg dlf dlh
          dlj:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dli
          dlk:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] dlj
          dll:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dle dlk
          dlm:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bua
          dln:bool[1] = lt dlm 0:i64[]
          dlo:i64[1] = add dlm 1:i64[]
          dlp:i64[1] = select_n dln dlm dlo
          dlq:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dlp
          dlr:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dlq
          dls:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] dkv dlr
          dlt:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btx
          dlu:bool[20] = lt dlt 0:i64[]
          dlv:i64[20] = add dlt 8:i64[]
          dlw:i64[20] = select_n dlu dlt dlv
          dlx:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dlw
          dly:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] dlx
          dlz:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dls dly
          dma:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bub
          dmb:bool[1] = lt dma 0:i64[]
          dmc:i64[1] = add dma 1:i64[]
          dmd:i64[1] = select_n dmb dma dmc
          dme:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dmd
          dmf:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dme
          dmg:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dkx dmf
          dmh:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bty
          dmi:bool[20] = lt dmh 0:i64[]
          dmj:i64[20] = add dmh 1:i64[]
          dmk:i64[20] = select_n dmi dmh dmj
          dml:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dmk
          dmm:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] dml
          dmn:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dmg dmm
          dmo:f64[1,20] = mul dll dlz
          dmp:f64[1,20] = mul dmo dmn
          dmq:f64[3,1] = transpose[permutation=(1, 0)] cal
          dmr:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] dmq
          dms:f64[1] = squeeze[dimensions=(0,)] dmr
          dmt:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] dmq
          dmu:f64[1] = squeeze[dimensions=(0,)] dmt
          dmv:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] dmq
          dmw:f64[1] = squeeze[dimensions=(0,)] dmv
          dmx:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bug
          dmy:bool[1] = lt dmx 0:i64[]
          dmz:i64[1] = add dmx 1:i64[]
          dna:i64[1] = select_n dmy dmx dmz
          dnb:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dna
          dnc:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dnb
          dnd:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dms dnc
          dne:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] buh
          dnf:bool[1] = lt dne 0:i64[]
          dng:i64[1] = add dne 1:i64[]
          dnh:i64[1] = select_n dnf dne dng
          dni:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dnh
          dnj:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dni
          dnk:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dmu dnj
          dnl:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bui
          dnm:bool[1] = lt dnl 0:i64[]
          dnn:i64[1] = add dnl 1:i64[]
          dno:i64[1] = select_n dnm dnl dnn
          dnp:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dno
          dnq:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dnp
          dnr:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dmw dnq
          dns:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dnd
          dnt:f64[1,20] = pjit[
            name=zernike_radial
            jaxpr={ lambda ; dns:f64[1,1] buj:i64[20] buk:i64[20]. let
                dnu:i64[20] = abs buk
                dnv:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] dnu
                dnw:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] buj
                dnx:f64[20] = sub dnw dnv
                dny:f64[20] = pjit[name=floor_divide jaxpr=floor_divide1] dnx 2:i64[]
                dnz:f64[20] = pow -1.0:f64[] dny
                doa:f64[1,1] = integer_pow[y=2] dns
                dob:f64[1,1] = mul 2.0:f64[] doa
                doc:f64[1,1] = sub 1.0:f64[] dob
                dod:f64[1,20] = custom_jvp_call[
                  name=_jacobi
                  call_jaxpr={ lambda ; doe:f64[20] dof:f64[20] dog:i64[] doh:f64[1,1]. let
                      doi:f64[1,20] = pjit[name=_jacobi jaxpr=_jacobi1] doe dof dog
                        doh 0:i64[]
                    in (doi,) }
                  jvp=_jacobi_jvp
                  symbolic_zeros=False
                ] dny dnv 0:i64[] doc
                doj:f64[1,20] = custom_jvp_call[
                  name=_jacobi
                  call_jaxpr={ lambda ; dok:f64[20] dol:f64[20] dom:i64[] don:f64[1,1]. let
                      doo:f64[1,20] = pjit[name=_jacobi jaxpr=_jacobi1] dok dol dom
                        don 1:i64[]
                    in (doo,) }
                  jvp=_jacobi_jvp
                  symbolic_zeros=False
                ] dny dnv 0:i64[] doc
                dop:f64[1,20] = custom_jvp_call[
                  name=_jacobi
                  call_jaxpr={ lambda ; doq:f64[20] dor:f64[20] dos:i64[] dot:f64[1,1]. let
                      dou:f64[1,20] = pjit[name=_jacobi jaxpr=_jacobi1] doq dor dos
                        dot 2:i64[]
                    in (dou,) }
                  jvp=_jacobi_jvp
                  symbolic_zeros=False
                ] dny dnv 0:i64[] doc
                dov:f64[20] = sub dnv 1.0:f64[]
                dow:f64[20] = mul dov dnv
                dox:f64[20] = sub dnv 2.0:f64[]
                doy:f64[20] = max dox 0.0:f64[]
                doz:f64[1,20] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 20)
                  sharding=None
                ] doy
                dpa:f64[1,20] = pow dns doz
                dpb:f64[1,20] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 20)
                  sharding=None
                ] dow
                dpc:f64[1,20] = mul dpb dpa
                dpd:f64[1,20] = mul dpc dod
                dpe:f64[20] = mul 2.0:f64[] dnv
                dpf:f64[20] = add dpe 1.0:f64[]
                dpg:f64[20] = mul 4.0:f64[] dpf
                dph:f64[1,20] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 20)
                  sharding=None
                ] dnv
                dpi:f64[1,20] = pow dns dph
                dpj:f64[1,20] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 20)
                  sharding=None
                ] dpg
                dpk:f64[1,20] = mul dpj dpi
                dpl:f64[1,20] = mul dpk doj
                dpm:f64[1,20] = sub dpd dpl
                dpn:f64[20] = add dnv 2.0:f64[]
                dpo:f64[1,20] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 20)
                  sharding=None
                ] dpn
                dpp:f64[1,20] = pow dns dpo
                dpq:f64[1,20] = mul 16.0:f64[] dpp
                dpr:f64[1,20] = mul dpq dop
                dps:f64[1,20] = add dpm dpr
                dpt:f64[20] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] buj
                dpu:f64[20] = sub dpt dnv
                dpv:f64[20] = pjit[name=remainder jaxpr=remainder1] dpu 2:i64[]
                dpw:bool[20] = eq dpv 0.0:f64[]
                dpx:f64[1,20] = pjit[name=_where jaxpr=_where7] dpw dps 0.0:f64[]
                dpy:f64[1,20] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(1, 20)
                  sharding=None
                ] dnz
                dnt:f64[1,20] = mul dpy dpx
              in (dnt,) }
          ] dns buj buk
          dpz:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dnk
          dqa:f64[1,8] = pjit[name=fourier jaxpr=fourier2] dpz bul 0:i64[]
          dqb:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dnr
          dqc:f64[1,1] = pjit[name=fourier jaxpr=fourier1] dqb bum 1:i64[] 0:i64[]
          dqd:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bug
          dqe:bool[1] = lt dqd 0:i64[]
          dqf:i64[1] = add dqd 1:i64[]
          dqg:i64[1] = select_n dqe dqd dqf
          dqh:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dqg
          dqi:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dqh
          dqj:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] dnt dqi
          dqk:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btw
          dql:bool[20] = lt dqk 0:i64[]
          dqm:i64[20] = add dqk 20:i64[]
          dqn:i64[20] = select_n dql dqk dqm
          dqo:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dqn
          dqp:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] dqo
          dqq:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dqj dqp
          dqr:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] buh
          dqs:bool[1] = lt dqr 0:i64[]
          dqt:i64[1] = add dqr 1:i64[]
          dqu:i64[1] = select_n dqs dqr dqt
          dqv:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dqu
          dqw:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dqv
          dqx:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] dqa dqw
          dqy:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btx
          dqz:bool[20] = lt dqy 0:i64[]
          dra:i64[20] = add dqy 8:i64[]
          drb:i64[20] = select_n dqz dqy dra
          drc:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] drb
          drd:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] drc
          dre:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dqx drd
          drf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bui
          drg:bool[1] = lt drf 0:i64[]
          drh:i64[1] = add drf 1:i64[]
          dri:i64[1] = select_n drg drf drh
          drj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dri
          drk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] drj
          drl:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dqc drk
          drm:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bty
          drn:bool[20] = lt drm 0:i64[]
          dro:i64[20] = add drm 1:i64[]
          drp:i64[20] = select_n drn drm dro
          drq:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] drp
          drr:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] drq
          drs:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] drl drr
          drt:f64[1,20] = mul dqq dre
          dru:f64[1,20] = mul drt drs
          drv:f64[3,1] = transpose[permutation=(1, 0)] cal
          drw:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] drv
          drx:f64[1] = squeeze[dimensions=(0,)] drw
          dry:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] drv
          drz:f64[1] = squeeze[dimensions=(0,)] dry
          dsa:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] drv
          dsb:f64[1] = squeeze[dimensions=(0,)] dsa
          dsc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bun
          dsd:bool[1] = lt dsc 0:i64[]
          dse:i64[1] = add dsc 1:i64[]
          dsf:i64[1] = select_n dsd dsc dse
          dsg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dsf
          dsh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dsg
          dsi:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] drx dsh
          dsj:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] buo
          dsk:bool[1] = lt dsj 0:i64[]
          dsl:i64[1] = add dsj 1:i64[]
          dsm:i64[1] = select_n dsk dsj dsl
          dsn:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dsm
          dso:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dsn
          dsp:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] drz dso
          dsq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bup
          dsr:bool[1] = lt dsq 0:i64[]
          dss:i64[1] = add dsq 1:i64[]
          dst:i64[1] = select_n dsr dsq dss
          dsu:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dst
          dsv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dsu
          dsw:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dsb dsv
          dsx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dsi
          dsy:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] dsx buq
            bur
          dsz:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dsp
          dta:f64[1,8] = pjit[name=fourier jaxpr=fourier2] dsz bus 1:i64[]
          dtb:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dsw
          dtc:f64[1,1] = pjit[name=fourier jaxpr=fourier1] dtb but 1:i64[] 0:i64[]
          dtd:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bun
          dte:bool[1] = lt dtd 0:i64[]
          dtf:i64[1] = add dtd 1:i64[]
          dtg:i64[1] = select_n dte dtd dtf
          dth:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dtg
          dti:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dth
          dtj:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] dsy dti
          dtk:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btw
          dtl:bool[20] = lt dtk 0:i64[]
          dtm:i64[20] = add dtk 20:i64[]
          dtn:i64[20] = select_n dtl dtk dtm
          dto:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dtn
          dtp:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] dto
          dtq:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dtj dtp
          dtr:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] buo
          dts:bool[1] = lt dtr 0:i64[]
          dtt:i64[1] = add dtr 1:i64[]
          dtu:i64[1] = select_n dts dtr dtt
          dtv:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dtu
          dtw:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dtv
          dtx:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] dta dtw
          dty:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btx
          dtz:bool[20] = lt dty 0:i64[]
          dua:i64[20] = add dty 8:i64[]
          dub:i64[20] = select_n dtz dty dua
          duc:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dub
          dud:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] duc
          due:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dtx dud
          duf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bup
          dug:bool[1] = lt duf 0:i64[]
          duh:i64[1] = add duf 1:i64[]
          dui:i64[1] = select_n dug duf duh
          duj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dui
          duk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] duj
          dul:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dtc duk
          dum:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bty
          dun:bool[20] = lt dum 0:i64[]
          duo:i64[20] = add dum 1:i64[]
          dup:i64[20] = select_n dun dum duo
          duq:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dup
          dur:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] duq
          dus:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dul dur
          dut:f64[1,20] = mul dtq due
          duu:f64[1,20] = mul dut dus
          duv:f64[3,1] = transpose[permutation=(1, 0)] cal
          duw:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] duv
          dux:f64[1] = squeeze[dimensions=(0,)] duw
          duy:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] duv
          duz:f64[1] = squeeze[dimensions=(0,)] duy
          dva:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] duv
          dvb:f64[1] = squeeze[dimensions=(0,)] dva
          dvc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] buu
          dvd:bool[1] = lt dvc 0:i64[]
          dve:i64[1] = add dvc 1:i64[]
          dvf:i64[1] = select_n dvd dvc dve
          dvg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dvf
          dvh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dvg
          dvi:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dux dvh
          dvj:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] buv
          dvk:bool[1] = lt dvj 0:i64[]
          dvl:i64[1] = add dvj 1:i64[]
          dvm:i64[1] = select_n dvk dvj dvl
          dvn:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dvm
          dvo:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dvn
          dvp:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] duz dvo
          dvq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] buw
          dvr:bool[1] = lt dvq 0:i64[]
          dvs:i64[1] = add dvq 1:i64[]
          dvt:i64[1] = select_n dvr dvq dvs
          dvu:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dvt
          dvv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dvu
          dvw:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dvb dvv
          dvx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dvi
          dvy:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial3] dvx bux
            buy
          dvz:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dvp
          dwa:f64[1,8] = pjit[name=fourier jaxpr=fourier2] dvz buz 1:i64[]
          dwb:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dvw
          dwc:f64[1,1] = pjit[name=fourier jaxpr=fourier1] dwb bva 1:i64[] 0:i64[]
          dwd:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] buu
          dwe:bool[1] = lt dwd 0:i64[]
          dwf:i64[1] = add dwd 1:i64[]
          dwg:i64[1] = select_n dwe dwd dwf
          dwh:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dwg
          dwi:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dwh
          dwj:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] dvy dwi
          dwk:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btw
          dwl:bool[20] = lt dwk 0:i64[]
          dwm:i64[20] = add dwk 20:i64[]
          dwn:i64[20] = select_n dwl dwk dwm
          dwo:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dwn
          dwp:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] dwo
          dwq:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dwj dwp
          dwr:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] buv
          dws:bool[1] = lt dwr 0:i64[]
          dwt:i64[1] = add dwr 1:i64[]
          dwu:i64[1] = select_n dws dwr dwt
          dwv:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dwu
          dww:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dwv
          dwx:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] dwa dww
          dwy:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btx
          dwz:bool[20] = lt dwy 0:i64[]
          dxa:i64[20] = add dwy 8:i64[]
          dxb:i64[20] = select_n dwz dwy dxa
          dxc:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dxb
          dxd:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] dxc
          dxe:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dwx dxd
          dxf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] buw
          dxg:bool[1] = lt dxf 0:i64[]
          dxh:i64[1] = add dxf 1:i64[]
          dxi:i64[1] = select_n dxg dxf dxh
          dxj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dxi
          dxk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dxj
          dxl:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dwc dxk
          dxm:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bty
          dxn:bool[20] = lt dxm 0:i64[]
          dxo:i64[20] = add dxm 1:i64[]
          dxp:i64[20] = select_n dxn dxm dxo
          dxq:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dxp
          dxr:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] dxq
          dxs:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dxl dxr
          dxt:f64[1,20] = mul dwq dxe
          dxu:f64[1,20] = mul dxt dxs
          dxv:f64[3,1] = transpose[permutation=(1, 0)] cal
          dxw:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] dxv
          dxx:f64[1] = squeeze[dimensions=(0,)] dxw
          dxy:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] dxv
          dxz:f64[1] = squeeze[dimensions=(0,)] dxy
          dya:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] dxv
          dyb:f64[1] = squeeze[dimensions=(0,)] dya
          dyc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvb
          dyd:bool[1] = lt dyc 0:i64[]
          dye:i64[1] = add dyc 1:i64[]
          dyf:i64[1] = select_n dyd dyc dye
          dyg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dyf
          dyh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dyg
          dyi:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dxx dyh
          dyj:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvc
          dyk:bool[1] = lt dyj 0:i64[]
          dyl:i64[1] = add dyj 1:i64[]
          dym:i64[1] = select_n dyk dyj dyl
          dyn:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dym
          dyo:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dyn
          dyp:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dxz dyo
          dyq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvd
          dyr:bool[1] = lt dyq 0:i64[]
          dys:i64[1] = add dyq 1:i64[]
          dyt:i64[1] = select_n dyr dyq dys
          dyu:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dyt
          dyv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dyu
          dyw:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] dyb dyv
          dyx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dyi
          dyy:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] dyx bve
            bvf
          dyz:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dyp
          dza:f64[1,8] = pjit[name=fourier jaxpr=fourier2] dyz bvg 2:i64[]
          dzb:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dyw
          dzc:f64[1,1] = pjit[name=fourier jaxpr=fourier1] dzb bvh 1:i64[] 0:i64[]
          dzd:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvb
          dze:bool[1] = lt dzd 0:i64[]
          dzf:i64[1] = add dzd 1:i64[]
          dzg:i64[1] = select_n dze dzd dzf
          dzh:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dzg
          dzi:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dzh
          dzj:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] dyy dzi
          dzk:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btw
          dzl:bool[20] = lt dzk 0:i64[]
          dzm:i64[20] = add dzk 20:i64[]
          dzn:i64[20] = select_n dzl dzk dzm
          dzo:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] dzn
          dzp:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] dzo
          dzq:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dzj dzp
          dzr:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvc
          dzs:bool[1] = lt dzr 0:i64[]
          dzt:i64[1] = add dzr 1:i64[]
          dzu:i64[1] = select_n dzs dzr dzt
          dzv:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] dzu
          dzw:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] dzv
          dzx:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] dza dzw
          dzy:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btx
          dzz:bool[20] = lt dzy 0:i64[]
          eaa:i64[20] = add dzy 8:i64[]
          eab:i64[20] = select_n dzz dzy eaa
          eac:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] eab
          ead:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] eac
          eae:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dzx ead
          eaf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvd
          eag:bool[1] = lt eaf 0:i64[]
          eah:i64[1] = add eaf 1:i64[]
          eai:i64[1] = select_n eag eaf eah
          eaj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eai
          eak:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eaj
          eal:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] dzc eak
          eam:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bty
          ean:bool[20] = lt eam 0:i64[]
          eao:i64[20] = add eam 1:i64[]
          eap:i64[20] = select_n ean eam eao
          eaq:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] eap
          ear:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] eaq
          eas:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eal ear
          eat:f64[1,20] = mul dzq eae
          eau:f64[1,20] = mul eat eas
          eav:f64[3,1] = transpose[permutation=(1, 0)] cal
          eaw:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] eav
          eax:f64[1] = squeeze[dimensions=(0,)] eaw
          eay:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] eav
          eaz:f64[1] = squeeze[dimensions=(0,)] eay
          eba:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] eav
          ebb:f64[1] = squeeze[dimensions=(0,)] eba
          ebc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvi
          ebd:bool[1] = lt ebc 0:i64[]
          ebe:i64[1] = add ebc 1:i64[]
          ebf:i64[1] = select_n ebd ebc ebe
          ebg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ebf
          ebh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ebg
          ebi:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] eax ebh
          ebj:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvj
          ebk:bool[1] = lt ebj 0:i64[]
          ebl:i64[1] = add ebj 1:i64[]
          ebm:i64[1] = select_n ebk ebj ebl
          ebn:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ebm
          ebo:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ebn
          ebp:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] eaz ebo
          ebq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvk
          ebr:bool[1] = lt ebq 0:i64[]
          ebs:i64[1] = add ebq 1:i64[]
          ebt:i64[1] = select_n ebr ebq ebs
          ebu:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ebt
          ebv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ebu
          ebw:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] ebb ebv
          ebx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ebi
          eby:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] ebx bvl
            bvm
          ebz:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ebp
          eca:f64[1,8] = pjit[name=fourier jaxpr=fourier2] ebz bvn 0:i64[]
          ecb:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ebw
          ecc:f64[1,1] = pjit[name=fourier jaxpr=fourier1] ecb bvo 1:i64[] 1:i64[]
          ecd:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvi
          ece:bool[1] = lt ecd 0:i64[]
          ecf:i64[1] = add ecd 1:i64[]
          ecg:i64[1] = select_n ece ecd ecf
          ech:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ecg
          eci:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ech
          ecj:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] eby eci
          eck:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btw
          ecl:bool[20] = lt eck 0:i64[]
          ecm:i64[20] = add eck 20:i64[]
          ecn:i64[20] = select_n ecl eck ecm
          eco:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] ecn
          ecp:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] eco
          ecq:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] ecj ecp
          ecr:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvj
          ecs:bool[1] = lt ecr 0:i64[]
          ect:i64[1] = add ecr 1:i64[]
          ecu:i64[1] = select_n ecs ecr ect
          ecv:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ecu
          ecw:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ecv
          ecx:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] eca ecw
          ecy:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btx
          ecz:bool[20] = lt ecy 0:i64[]
          eda:i64[20] = add ecy 8:i64[]
          edb:i64[20] = select_n ecz ecy eda
          edc:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] edb
          edd:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] edc
          ede:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] ecx edd
          edf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvk
          edg:bool[1] = lt edf 0:i64[]
          edh:i64[1] = add edf 1:i64[]
          edi:i64[1] = select_n edg edf edh
          edj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] edi
          edk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] edj
          edl:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] ecc edk
          edm:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bty
          edn:bool[20] = lt edm 0:i64[]
          edo:i64[20] = add edm 1:i64[]
          edp:i64[20] = select_n edn edm edo
          edq:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] edp
          edr:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] edq
          eds:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] edl edr
          edt:f64[1,20] = mul ecq ede
          edu:f64[1,20] = mul edt eds
          edv:f64[3,1] = transpose[permutation=(1, 0)] cal
          edw:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] edv
          edx:f64[1] = squeeze[dimensions=(0,)] edw
          edy:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] edv
          edz:f64[1] = squeeze[dimensions=(0,)] edy
          eea:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] edv
          eeb:f64[1] = squeeze[dimensions=(0,)] eea
          eec:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvp
          eed:bool[1] = lt eec 0:i64[]
          eee:i64[1] = add eec 1:i64[]
          eef:i64[1] = select_n eed eec eee
          eeg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eef
          eeh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eeg
          eei:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] edx eeh
          eej:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvq
          eek:bool[1] = lt eej 0:i64[]
          eel:i64[1] = add eej 1:i64[]
          eem:i64[1] = select_n eek eej eel
          een:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eem
          eeo:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] een
          eep:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] edz eeo
          eeq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvr
          eer:bool[1] = lt eeq 0:i64[]
          ees:i64[1] = add eeq 1:i64[]
          eet:i64[1] = select_n eer eeq ees
          eeu:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eet
          eev:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eeu
          eew:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] eeb eev
          eex:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eei
          eey:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial3] eex bvs
            bvt
          eez:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eep
          efa:f64[1,8] = pjit[name=fourier jaxpr=fourier2] eez bvu 0:i64[]
          efb:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eew
          efc:f64[1,1] = pjit[name=fourier jaxpr=fourier1] efb bvv 1:i64[] 1:i64[]
          efd:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvp
          efe:bool[1] = lt efd 0:i64[]
          eff:i64[1] = add efd 1:i64[]
          efg:i64[1] = select_n efe efd eff
          efh:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] efg
          efi:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] efh
          efj:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] eey efi
          efk:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btw
          efl:bool[20] = lt efk 0:i64[]
          efm:i64[20] = add efk 20:i64[]
          efn:i64[20] = select_n efl efk efm
          efo:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] efn
          efp:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] efo
          efq:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] efj efp
          efr:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvq
          efs:bool[1] = lt efr 0:i64[]
          eft:i64[1] = add efr 1:i64[]
          efu:i64[1] = select_n efs efr eft
          efv:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] efu
          efw:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] efv
          efx:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] efa efw
          efy:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btx
          efz:bool[20] = lt efy 0:i64[]
          ega:i64[20] = add efy 8:i64[]
          egb:i64[20] = select_n efz efy ega
          egc:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] egb
          egd:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] egc
          ege:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] efx egd
          egf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvr
          egg:bool[1] = lt egf 0:i64[]
          egh:i64[1] = add egf 1:i64[]
          egi:i64[1] = select_n egg egf egh
          egj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] egi
          egk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] egj
          egl:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] efc egk
          egm:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bty
          egn:bool[20] = lt egm 0:i64[]
          ego:i64[20] = add egm 1:i64[]
          egp:i64[20] = select_n egn egm ego
          egq:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] egp
          egr:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] egq
          egs:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] egl egr
          egt:f64[1,20] = mul efq ege
          egu:f64[1,20] = mul egt egs
          egv:f64[3,1] = transpose[permutation=(1, 0)] cal
          egw:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] egv
          egx:f64[1] = squeeze[dimensions=(0,)] egw
          egy:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] egv
          egz:f64[1] = squeeze[dimensions=(0,)] egy
          eha:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] egv
          ehb:f64[1] = squeeze[dimensions=(0,)] eha
          ehc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvw
          ehd:bool[1] = lt ehc 0:i64[]
          ehe:i64[1] = add ehc 1:i64[]
          ehf:i64[1] = select_n ehd ehc ehe
          ehg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ehf
          ehh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ehg
          ehi:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] egx ehh
          ehj:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvx
          ehk:bool[1] = lt ehj 0:i64[]
          ehl:i64[1] = add ehj 1:i64[]
          ehm:i64[1] = select_n ehk ehj ehl
          ehn:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ehm
          eho:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ehn
          ehp:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] egz eho
          ehq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvy
          ehr:bool[1] = lt ehq 0:i64[]
          ehs:i64[1] = add ehq 1:i64[]
          eht:i64[1] = select_n ehr ehq ehs
          ehu:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eht
          ehv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ehu
          ehw:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] ehb ehv
          ehx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ehi
          ehy:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] ehx bvz
            bwa
          ehz:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ehp
          eia:f64[1,8] = pjit[name=fourier jaxpr=fourier2] ehz bwb 1:i64[]
          eib:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ehw
          eic:f64[1,1] = pjit[name=fourier jaxpr=fourier1] eib bwc 1:i64[] 1:i64[]
          eid:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvw
          eie:bool[1] = lt eid 0:i64[]
          eif:i64[1] = add eid 1:i64[]
          eig:i64[1] = select_n eie eid eif
          eih:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eig
          eii:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eih
          eij:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] ehy eii
          eik:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btw
          eil:bool[20] = lt eik 0:i64[]
          eim:i64[20] = add eik 20:i64[]
          ein:i64[20] = select_n eil eik eim
          eio:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] ein
          eip:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] eio
          eiq:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eij eip
          eir:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvx
          eis:bool[1] = lt eir 0:i64[]
          eit:i64[1] = add eir 1:i64[]
          eiu:i64[1] = select_n eis eir eit
          eiv:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eiu
          eiw:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eiv
          eix:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] eia eiw
          eiy:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btx
          eiz:bool[20] = lt eiy 0:i64[]
          eja:i64[20] = add eiy 8:i64[]
          ejb:i64[20] = select_n eiz eiy eja
          ejc:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] ejb
          ejd:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] ejc
          eje:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eix ejd
          ejf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bvy
          ejg:bool[1] = lt ejf 0:i64[]
          ejh:i64[1] = add ejf 1:i64[]
          eji:i64[1] = select_n ejg ejf ejh
          ejj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eji
          ejk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ejj
          ejl:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eic ejk
          ejm:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bty
          ejn:bool[20] = lt ejm 0:i64[]
          ejo:i64[20] = add ejm 1:i64[]
          ejp:i64[20] = select_n ejn ejm ejo
          ejq:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] ejp
          ejr:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] ejq
          ejs:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] ejl ejr
          ejt:f64[1,20] = mul eiq eje
          eju:f64[1,20] = mul ejt ejs
          ejv:f64[3,1] = transpose[permutation=(1, 0)] cal
          ejw:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] ejv
          ejx:f64[1] = squeeze[dimensions=(0,)] ejw
          ejy:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] ejv
          ejz:f64[1] = squeeze[dimensions=(0,)] ejy
          eka:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] ejv
          ekb:f64[1] = squeeze[dimensions=(0,)] eka
          ekc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwd
          ekd:bool[1] = lt ekc 0:i64[]
          eke:i64[1] = add ekc 1:i64[]
          ekf:i64[1] = select_n ekd ekc eke
          ekg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ekf
          ekh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ekg
          eki:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] ejx ekh
          ekj:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwe
          ekk:bool[1] = lt ekj 0:i64[]
          ekl:i64[1] = add ekj 1:i64[]
          ekm:i64[1] = select_n ekk ekj ekl
          ekn:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ekm
          eko:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ekn
          ekp:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] ejz eko
          ekq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwf
          ekr:bool[1] = lt ekq 0:i64[]
          eks:i64[1] = add ekq 1:i64[]
          ekt:i64[1] = select_n ekr ekq eks
          eku:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ekt
          ekv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eku
          ekw:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] ekb ekv
          ekx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eki
          eky:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] ekx bwg
            bwh
          ekz:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ekp
          ela:f64[1,8] = pjit[name=fourier jaxpr=fourier2] ekz bwi 0:i64[]
          elb:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ekw
          elc:f64[1,1] = pjit[name=fourier jaxpr=fourier1] elb bwj 1:i64[] 2:i64[]
          eld:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwd
          ele:bool[1] = lt eld 0:i64[]
          elf:i64[1] = add eld 1:i64[]
          elg:i64[1] = select_n ele eld elf
          elh:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] elg
          eli:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] elh
          elj:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] eky eli
          elk:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btw
          ell:bool[20] = lt elk 0:i64[]
          elm:i64[20] = add elk 20:i64[]
          eln:i64[20] = select_n ell elk elm
          elo:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] eln
          elp:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] elo
          elq:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] elj elp
          elr:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwe
          els:bool[1] = lt elr 0:i64[]
          elt:i64[1] = add elr 1:i64[]
          elu:i64[1] = select_n els elr elt
          elv:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] elu
          elw:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] elv
          elx:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] ela elw
          ely:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] btx
          elz:bool[20] = lt ely 0:i64[]
          ema:i64[20] = add ely 8:i64[]
          emb:i64[20] = select_n elz ely ema
          emc:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] emb
          emd:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] emc
          eme:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] elx emd
          emf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwf
          emg:bool[1] = lt emf 0:i64[]
          emh:i64[1] = add emf 1:i64[]
          emi:i64[1] = select_n emg emf emh
          emj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] emi
          emk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] emj
          eml:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] elc emk
          emm:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bty
          emn:bool[20] = lt emm 0:i64[]
          emo:i64[20] = add emm 1:i64[]
          emp:i64[20] = select_n emn emm emo
          emq:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] emp
          emr:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] emq
          ems:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eml emr
          emt:f64[1,20] = mul elq eme
          emu:f64[1,20] = mul emt ems
          emv:f64[3,1] = transpose[permutation=(1, 0)] cal
          emw:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] emv
          emx:f64[1] = squeeze[dimensions=(0,)] emw
          emy:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] emv
          emz:f64[1] = squeeze[dimensions=(0,)] emy
          ena:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] emv
          enb:f64[1] = squeeze[dimensions=(0,)] ena
          enc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwk
          end:bool[1] = lt enc 0:i64[]
          ene:i64[1] = add enc 1:i64[]
          enf:i64[1] = select_n end enc ene
          eng:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] enf
          enh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eng
          eni:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] emx enh
          enj:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwl
          enk:bool[1] = lt enj 0:i64[]
          enl:i64[1] = add enj 1:i64[]
          enm:i64[1] = select_n enk enj enl
          enn:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] enm
          eno:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] enn
          enp:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] emz eno
          enq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwm
          enr:bool[1] = lt enq 0:i64[]
          ens:i64[1] = add enq 1:i64[]
          ent:i64[1] = select_n enr enq ens
          enu:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ent
          env:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] enu
          enw:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] enb env
          enx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eni
          eny:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] enx bwn
            bwo
          enz:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] enp
          eoa:f64[1,8] = pjit[name=fourier jaxpr=fourier2] enz bwp 0:i64[]
          eob:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] enw
          eoc:f64[1,1] = pjit[name=fourier jaxpr=fourier1] eob bwq 1:i64[] 0:i64[]
          eod:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwk
          eoe:bool[1] = lt eod 0:i64[]
          eof:i64[1] = add eod 1:i64[]
          eog:i64[1] = select_n eoe eod eof
          eoh:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eog
          eoi:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eoh
          eoj:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] eny eoi
          eok:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwr
          eol:bool[20] = lt eok 0:i64[]
          eom:i64[20] = add eok 20:i64[]
          eon:i64[20] = select_n eol eok eom
          eoo:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] eon
          eop:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] eoo
          eoq:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eoj eop
          eor:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwl
          eos:bool[1] = lt eor 0:i64[]
          eot:i64[1] = add eor 1:i64[]
          eou:i64[1] = select_n eos eor eot
          eov:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eou
          eow:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eov
          eox:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] eoa eow
          eoy:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bws
          eoz:bool[20] = lt eoy 0:i64[]
          epa:i64[20] = add eoy 8:i64[]
          epb:i64[20] = select_n eoz eoy epa
          epc:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] epb
          epd:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] epc
          epe:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eox epd
          epf:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwm
          epg:bool[1] = lt epf 0:i64[]
          eph:i64[1] = add epf 1:i64[]
          epi:i64[1] = select_n epg epf eph
          epj:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] epi
          epk:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] epj
          epl:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eoc epk
          epm:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwt
          epn:bool[20] = lt epm 0:i64[]
          epo:i64[20] = add epm 1:i64[]
          epp:i64[20] = select_n epn epm epo
          epq:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] epp
          epr:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] epq
          eps:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] epl epr
          ept:f64[1,20] = mul eoq epe
          _:f64[1,20] = mul ept eps
          epu:f64[3,1] = transpose[permutation=(1, 0)] cal
          epv:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] epu
          epw:f64[1] = squeeze[dimensions=(0,)] epv
          epx:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] epu
          epy:f64[1] = squeeze[dimensions=(0,)] epx
          epz:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] epu
          eqa:f64[1] = squeeze[dimensions=(0,)] epz
          eqb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwu
          eqc:bool[1] = lt eqb 0:i64[]
          eqd:i64[1] = add eqb 1:i64[]
          eqe:i64[1] = select_n eqc eqb eqd
          eqf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eqe
          eqg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eqf
          eqh:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] epw eqg
          eqi:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwv
          eqj:bool[1] = lt eqi 0:i64[]
          eqk:i64[1] = add eqi 1:i64[]
          eql:i64[1] = select_n eqj eqi eqk
          eqm:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eql
          eqn:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eqm
          eqo:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] epy eqn
          eqp:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bww
          eqq:bool[1] = lt eqp 0:i64[]
          eqr:i64[1] = add eqp 1:i64[]
          eqs:i64[1] = select_n eqq eqp eqr
          eqt:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eqs
          equ:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eqt
          eqv:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] eqa equ
          eqw:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eqh
          eqx:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] eqw bwx
            bwy
          eqy:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eqo
          eqz:f64[1,8] = pjit[name=fourier jaxpr=fourier2] eqy bwz 1:i64[]
          era:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eqv
          erb:f64[1,1] = pjit[name=fourier jaxpr=fourier1] era bxa 1:i64[] 0:i64[]
          erc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwu
          erd:bool[1] = lt erc 0:i64[]
          ere:i64[1] = add erc 1:i64[]
          erf:i64[1] = select_n erd erc ere
          erg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] erf
          erh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] erg
          eri:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] eqx erh
          erj:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwr
          erk:bool[20] = lt erj 0:i64[]
          erl:i64[20] = add erj 20:i64[]
          erm:i64[20] = select_n erk erj erl
          ern:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] erm
          ero:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] ern
          erp:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eri ero
          erq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwv
          err:bool[1] = lt erq 0:i64[]
          ers:i64[1] = add erq 1:i64[]
          ert:i64[1] = select_n err erq ers
          eru:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ert
          erv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eru
          erw:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] eqz erv
          erx:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bws
          ery:bool[20] = lt erx 0:i64[]
          erz:i64[20] = add erx 8:i64[]
          esa:i64[20] = select_n ery erx erz
          esb:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] esa
          esc:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] esb
          esd:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] erw esc
          ese:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bww
          esf:bool[1] = lt ese 0:i64[]
          esg:i64[1] = add ese 1:i64[]
          esh:i64[1] = select_n esf ese esg
          esi:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] esh
          esj:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] esi
          esk:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] erb esj
          esl:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwt
          esm:bool[20] = lt esl 0:i64[]
          esn:i64[20] = add esl 1:i64[]
          eso:i64[20] = select_n esm esl esn
          esp:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] eso
          esq:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] esp
          esr:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] esk esq
          ess:f64[1,20] = mul erp esd
          est:f64[1,20] = mul ess esr
          esu:f64[3,1] = transpose[permutation=(1, 0)] cal
          esv:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] esu
          esw:f64[1] = squeeze[dimensions=(0,)] esv
          esx:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] esu
          esy:f64[1] = squeeze[dimensions=(0,)] esx
          esz:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] esu
          eta:f64[1] = squeeze[dimensions=(0,)] esz
          etb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxb
          etc:bool[1] = lt etb 0:i64[]
          etd:i64[1] = add etb 1:i64[]
          ete:i64[1] = select_n etc etb etd
          etf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ete
          etg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] etf
          eth:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] esw etg
          eti:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxc
          etj:bool[1] = lt eti 0:i64[]
          etk:i64[1] = add eti 1:i64[]
          etl:i64[1] = select_n etj eti etk
          etm:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] etl
          etn:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] etm
          eto:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] esy etn
          etp:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxd
          etq:bool[1] = lt etp 0:i64[]
          etr:i64[1] = add etp 1:i64[]
          ets:i64[1] = select_n etq etp etr
          ett:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ets
          etu:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ett
          etv:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] eta etu
          etw:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eth
          etx:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial3] etw bxe
            bxf
          ety:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eto
          etz:f64[1,8] = pjit[name=fourier jaxpr=fourier2] ety bxg 1:i64[]
          eua:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] etv
          eub:f64[1,1] = pjit[name=fourier jaxpr=fourier1] eua bxh 1:i64[] 0:i64[]
          euc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxb
          eud:bool[1] = lt euc 0:i64[]
          eue:i64[1] = add euc 1:i64[]
          euf:i64[1] = select_n eud euc eue
          eug:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] euf
          euh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eug
          eui:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] etx euh
          euj:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwr
          euk:bool[20] = lt euj 0:i64[]
          eul:i64[20] = add euj 20:i64[]
          eum:i64[20] = select_n euk euj eul
          eun:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] eum
          euo:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] eun
          eup:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eui euo
          euq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxc
          eur:bool[1] = lt euq 0:i64[]
          eus:i64[1] = add euq 1:i64[]
          eut:i64[1] = select_n eur euq eus
          euu:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eut
          euv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] euu
          euw:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] etz euv
          eux:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bws
          euy:bool[20] = lt eux 0:i64[]
          euz:i64[20] = add eux 8:i64[]
          eva:i64[20] = select_n euy eux euz
          evb:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] eva
          evc:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] evb
          evd:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] euw evc
          eve:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxd
          evf:bool[1] = lt eve 0:i64[]
          evg:i64[1] = add eve 1:i64[]
          evh:i64[1] = select_n evf eve evg
          evi:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] evh
          evj:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] evi
          evk:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eub evj
          evl:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwt
          evm:bool[20] = lt evl 0:i64[]
          evn:i64[20] = add evl 1:i64[]
          evo:i64[20] = select_n evm evl evn
          evp:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] evo
          evq:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] evp
          evr:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] evk evq
          evs:f64[1,20] = mul eup evd
          evt:f64[1,20] = mul evs evr
          evu:f64[3,1] = transpose[permutation=(1, 0)] cal
          evv:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] evu
          evw:f64[1] = squeeze[dimensions=(0,)] evv
          evx:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] evu
          evy:f64[1] = squeeze[dimensions=(0,)] evx
          evz:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] evu
          ewa:f64[1] = squeeze[dimensions=(0,)] evz
          ewb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxi
          ewc:bool[1] = lt ewb 0:i64[]
          ewd:i64[1] = add ewb 1:i64[]
          ewe:i64[1] = select_n ewc ewb ewd
          ewf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ewe
          ewg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ewf
          ewh:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] evw ewg
          ewi:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxj
          ewj:bool[1] = lt ewi 0:i64[]
          ewk:i64[1] = add ewi 1:i64[]
          ewl:i64[1] = select_n ewj ewi ewk
          ewm:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ewl
          ewn:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ewm
          ewo:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] evy ewn
          ewp:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxk
          ewq:bool[1] = lt ewp 0:i64[]
          ewr:i64[1] = add ewp 1:i64[]
          ews:i64[1] = select_n ewq ewp ewr
          ewt:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ews
          ewu:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ewt
          ewv:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] ewa ewu
          eww:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ewh
          ewx:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] eww bxl
            bxm
          ewy:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ewo
          ewz:f64[1,8] = pjit[name=fourier jaxpr=fourier2] ewy bxn 2:i64[]
          exa:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ewv
          exb:f64[1,1] = pjit[name=fourier jaxpr=fourier1] exa bxo 1:i64[] 0:i64[]
          exc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxi
          exd:bool[1] = lt exc 0:i64[]
          exe:i64[1] = add exc 1:i64[]
          exf:i64[1] = select_n exd exc exe
          exg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] exf
          exh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] exg
          exi:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] ewx exh
          exj:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwr
          exk:bool[20] = lt exj 0:i64[]
          exl:i64[20] = add exj 20:i64[]
          exm:i64[20] = select_n exk exj exl
          exn:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] exm
          exo:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] exn
          exp:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] exi exo
          exq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxj
          exr:bool[1] = lt exq 0:i64[]
          exs:i64[1] = add exq 1:i64[]
          ext:i64[1] = select_n exr exq exs
          exu:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ext
          exv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] exu
          exw:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] ewz exv
          exx:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bws
          exy:bool[20] = lt exx 0:i64[]
          exz:i64[20] = add exx 8:i64[]
          eya:i64[20] = select_n exy exx exz
          eyb:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] eya
          eyc:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] eyb
          eyd:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] exw eyc
          eye:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxk
          eyf:bool[1] = lt eye 0:i64[]
          eyg:i64[1] = add eye 1:i64[]
          eyh:i64[1] = select_n eyf eye eyg
          eyi:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eyh
          eyj:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] eyi
          eyk:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] exb eyj
          eyl:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwt
          eym:bool[20] = lt eyl 0:i64[]
          eyn:i64[20] = add eyl 1:i64[]
          eyo:i64[20] = select_n eym eyl eyn
          eyp:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] eyo
          eyq:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] eyp
          eyr:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] eyk eyq
          eys:f64[1,20] = mul exp eyd
          eyt:f64[1,20] = mul eys eyr
          eyu:f64[3,1] = transpose[permutation=(1, 0)] cal
          eyv:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] eyu
          eyw:f64[1] = squeeze[dimensions=(0,)] eyv
          eyx:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] eyu
          eyy:f64[1] = squeeze[dimensions=(0,)] eyx
          eyz:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] eyu
          eza:f64[1] = squeeze[dimensions=(0,)] eyz
          ezb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxp
          ezc:bool[1] = lt ezb 0:i64[]
          ezd:i64[1] = add ezb 1:i64[]
          eze:i64[1] = select_n ezc ezb ezd
          ezf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] eze
          ezg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ezf
          ezh:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] eyw ezg
          ezi:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxq
          ezj:bool[1] = lt ezi 0:i64[]
          ezk:i64[1] = add ezi 1:i64[]
          ezl:i64[1] = select_n ezj ezi ezk
          ezm:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ezl
          ezn:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ezm
          ezo:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] eyy ezn
          ezp:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxr
          ezq:bool[1] = lt ezp 0:i64[]
          ezr:i64[1] = add ezp 1:i64[]
          ezs:i64[1] = select_n ezq ezp ezr
          ezt:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ezs
          ezu:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ezt
          ezv:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] eza ezu
          ezw:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ezh
          ezx:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] ezw bxs
            bxt
          ezy:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ezo
          ezz:f64[1,8] = pjit[name=fourier jaxpr=fourier2] ezy bxu 0:i64[]
          faa:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ezv
          fab:f64[1,1] = pjit[name=fourier jaxpr=fourier1] faa bxv 1:i64[] 1:i64[]
          fac:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxp
          fad:bool[1] = lt fac 0:i64[]
          fae:i64[1] = add fac 1:i64[]
          faf:i64[1] = select_n fad fac fae
          fag:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] faf
          fah:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fag
          fai:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] ezx fah
          faj:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwr
          fak:bool[20] = lt faj 0:i64[]
          fal:i64[20] = add faj 20:i64[]
          fam:i64[20] = select_n fak faj fal
          fan:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] fam
          fao:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] fan
          fap:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fai fao
          faq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxq
          far:bool[1] = lt faq 0:i64[]
          fas:i64[1] = add faq 1:i64[]
          fat:i64[1] = select_n far faq fas
          fau:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fat
          fav:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fau
          faw:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] ezz fav
          fax:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bws
          fay:bool[20] = lt fax 0:i64[]
          faz:i64[20] = add fax 8:i64[]
          fba:i64[20] = select_n fay fax faz
          fbb:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] fba
          fbc:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] fbb
          fbd:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] faw fbc
          fbe:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxr
          fbf:bool[1] = lt fbe 0:i64[]
          fbg:i64[1] = add fbe 1:i64[]
          fbh:i64[1] = select_n fbf fbe fbg
          fbi:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fbh
          fbj:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fbi
          fbk:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fab fbj
          fbl:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwt
          fbm:bool[20] = lt fbl 0:i64[]
          fbn:i64[20] = add fbl 1:i64[]
          fbo:i64[20] = select_n fbm fbl fbn
          fbp:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] fbo
          fbq:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] fbp
          fbr:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fbk fbq
          fbs:f64[1,20] = mul fap fbd
          fbt:f64[1,20] = mul fbs fbr
          fbu:f64[3,1] = transpose[permutation=(1, 0)] cal
          fbv:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] fbu
          fbw:f64[1] = squeeze[dimensions=(0,)] fbv
          fbx:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] fbu
          fby:f64[1] = squeeze[dimensions=(0,)] fbx
          fbz:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] fbu
          fca:f64[1] = squeeze[dimensions=(0,)] fbz
          fcb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxw
          fcc:bool[1] = lt fcb 0:i64[]
          fcd:i64[1] = add fcb 1:i64[]
          fce:i64[1] = select_n fcc fcb fcd
          fcf:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fce
          fcg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fcf
          fch:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] fbw fcg
          fci:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxx
          fcj:bool[1] = lt fci 0:i64[]
          fck:i64[1] = add fci 1:i64[]
          fcl:i64[1] = select_n fcj fci fck
          fcm:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fcl
          fcn:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fcm
          fco:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] fby fcn
          fcp:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxy
          fcq:bool[1] = lt fcp 0:i64[]
          fcr:i64[1] = add fcp 1:i64[]
          fcs:i64[1] = select_n fcq fcp fcr
          fct:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fcs
          fcu:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fct
          fcv:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] fca fcu
          fcw:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fch
          fcx:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial3] fcw bxz
            bya
          fcy:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fco
          fcz:f64[1,8] = pjit[name=fourier jaxpr=fourier2] fcy byb 0:i64[]
          fda:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fcv
          fdb:f64[1,1] = pjit[name=fourier jaxpr=fourier1] fda byc 1:i64[] 1:i64[]
          fdc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxw
          fdd:bool[1] = lt fdc 0:i64[]
          fde:i64[1] = add fdc 1:i64[]
          fdf:i64[1] = select_n fdd fdc fde
          fdg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fdf
          fdh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fdg
          fdi:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] fcx fdh
          fdj:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwr
          fdk:bool[20] = lt fdj 0:i64[]
          fdl:i64[20] = add fdj 20:i64[]
          fdm:i64[20] = select_n fdk fdj fdl
          fdn:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] fdm
          fdo:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] fdn
          fdp:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fdi fdo
          fdq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxx
          fdr:bool[1] = lt fdq 0:i64[]
          fds:i64[1] = add fdq 1:i64[]
          fdt:i64[1] = select_n fdr fdq fds
          fdu:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fdt
          fdv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fdu
          fdw:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] fcz fdv
          fdx:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bws
          fdy:bool[20] = lt fdx 0:i64[]
          fdz:i64[20] = add fdx 8:i64[]
          fea:i64[20] = select_n fdy fdx fdz
          feb:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] fea
          fec:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] feb
          fed:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fdw fec
          fee:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bxy
          fef:bool[1] = lt fee 0:i64[]
          feg:i64[1] = add fee 1:i64[]
          feh:i64[1] = select_n fef fee feg
          fei:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] feh
          fej:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fei
          fek:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fdb fej
          fel:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwt
          fem:bool[20] = lt fel 0:i64[]
          fen:i64[20] = add fel 1:i64[]
          feo:i64[20] = select_n fem fel fen
          fep:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] feo
          feq:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] fep
          fer:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fek feq
          fes:f64[1,20] = mul fdp fed
          fet:f64[1,20] = mul fes fer
          feu:f64[3,1] = transpose[permutation=(1, 0)] cal
          fev:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] feu
          few:f64[1] = squeeze[dimensions=(0,)] fev
          fex:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] feu
          fey:f64[1] = squeeze[dimensions=(0,)] fex
          fez:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] feu
          ffa:f64[1] = squeeze[dimensions=(0,)] fez
          ffb:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] byd
          ffc:bool[1] = lt ffb 0:i64[]
          ffd:i64[1] = add ffb 1:i64[]
          ffe:i64[1] = select_n ffc ffb ffd
          fff:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ffe
          ffg:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fff
          ffh:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] few ffg
          ffi:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bye
          ffj:bool[1] = lt ffi 0:i64[]
          ffk:i64[1] = add ffi 1:i64[]
          ffl:i64[1] = select_n ffj ffi ffk
          ffm:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ffl
          ffn:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ffm
          ffo:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] fey ffn
          ffp:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] byf
          ffq:bool[1] = lt ffp 0:i64[]
          ffr:i64[1] = add ffp 1:i64[]
          ffs:i64[1] = select_n ffq ffp ffr
          fft:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] ffs
          ffu:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fft
          ffv:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] ffa ffu
          ffw:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ffh
          ffx:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] ffw byg
            byh
          ffy:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ffo
          ffz:f64[1,8] = pjit[name=fourier jaxpr=fourier2] ffy byi 1:i64[]
          fga:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ffv
          fgb:f64[1,1] = pjit[name=fourier jaxpr=fourier1] fga byj 1:i64[] 1:i64[]
          fgc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] byd
          fgd:bool[1] = lt fgc 0:i64[]
          fge:i64[1] = add fgc 1:i64[]
          fgf:i64[1] = select_n fgd fgc fge
          fgg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fgf
          fgh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fgg
          fgi:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] ffx fgh
          fgj:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwr
          fgk:bool[20] = lt fgj 0:i64[]
          fgl:i64[20] = add fgj 20:i64[]
          fgm:i64[20] = select_n fgk fgj fgl
          fgn:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] fgm
          fgo:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] fgn
          fgp:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fgi fgo
          fgq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bye
          fgr:bool[1] = lt fgq 0:i64[]
          fgs:i64[1] = add fgq 1:i64[]
          fgt:i64[1] = select_n fgr fgq fgs
          fgu:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fgt
          fgv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fgu
          fgw:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] ffz fgv
          fgx:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bws
          fgy:bool[20] = lt fgx 0:i64[]
          fgz:i64[20] = add fgx 8:i64[]
          fha:i64[20] = select_n fgy fgx fgz
          fhb:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] fha
          fhc:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] fhb
          fhd:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fgw fhc
          fhe:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] byf
          fhf:bool[1] = lt fhe 0:i64[]
          fhg:i64[1] = add fhe 1:i64[]
          fhh:i64[1] = select_n fhf fhe fhg
          fhi:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fhh
          fhj:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fhi
          fhk:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fgb fhj
          fhl:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwt
          fhm:bool[20] = lt fhl 0:i64[]
          fhn:i64[20] = add fhl 1:i64[]
          fho:i64[20] = select_n fhm fhl fhn
          fhp:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] fho
          fhq:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] fhp
          fhr:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fhk fhq
          fhs:f64[1,20] = mul fgp fhd
          fht:f64[1,20] = mul fhs fhr
          fhu:f64[3,1] = transpose[permutation=(1, 0)] cal
          fhv:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=(1, 1)
          ] fhu
          fhw:f64[1] = squeeze[dimensions=(0,)] fhv
          fhx:f64[1,1] = slice[
            limit_indices=(2, 1)
            start_indices=(1, 0)
            strides=(1, 1)
          ] fhu
          fhy:f64[1] = squeeze[dimensions=(0,)] fhx
          fhz:f64[1,1] = slice[
            limit_indices=(3, 1)
            start_indices=(2, 0)
            strides=(1, 1)
          ] fhu
          fia:f64[1] = squeeze[dimensions=(0,)] fhz
          fib:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] byk
          fic:bool[1] = lt fib 0:i64[]
          fid:i64[1] = add fib 1:i64[]
          fie:i64[1] = select_n fic fib fid
          fif:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fie
          fig:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fif
          fih:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] fhw fig
          fii:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] byl
          fij:bool[1] = lt fii 0:i64[]
          fik:i64[1] = add fii 1:i64[]
          fil:i64[1] = select_n fij fii fik
          fim:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fil
          fin:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fim
          fio:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] fhy fin
          fip:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bym
          fiq:bool[1] = lt fip 0:i64[]
          fir:i64[1] = add fip 1:i64[]
          fis:i64[1] = select_n fiq fip fir
          fit:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fis
          fiu:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fit
          fiv:f64[1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1,)
            unique_indices=False
          ] fia fiu
          fiw:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fih
          fix:f64[1,20] = pjit[name=zernike_radial jaxpr=zernike_radial2] fiw byn
            byo
          fiy:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fio
          fiz:f64[1,8] = pjit[name=fourier jaxpr=fourier2] fiy byp 0:i64[]
          fja:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fiv
          fjb:f64[1,1] = pjit[name=fourier jaxpr=fourier1] fja byq 1:i64[] 2:i64[]
          fjc:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] byk
          fjd:bool[1] = lt fjc 0:i64[]
          fje:i64[1] = add fjc 1:i64[]
          fjf:i64[1] = select_n fjd fjc fje
          fjg:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fjf
          fjh:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fjg
          fji:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 20)
            unique_indices=False
          ] fix fjh
          fjj:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwr
          fjk:bool[20] = lt fjj 0:i64[]
          fjl:i64[20] = add fjj 20:i64[]
          fjm:i64[20] = select_n fjk fjj fjl
          fjn:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] fjm
          fjo:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] fjn
          fjp:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fji fjo
          fjq:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] byl
          fjr:bool[1] = lt fjq 0:i64[]
          fjs:i64[1] = add fjq 1:i64[]
          fjt:i64[1] = select_n fjr fjq fjs
          fju:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fjt
          fjv:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fju
          fjw:f64[1,8] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 8)
            unique_indices=False
          ] fiz fjv
          fjx:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bws
          fjy:bool[20] = lt fjx 0:i64[]
          fjz:i64[20] = add fjx 8:i64[]
          fka:i64[20] = select_n fjy fjx fjz
          fkb:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] fka
          fkc:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] fkb
          fkd:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fjw fkc
          fke:i64[1] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bym
          fkf:bool[1] = lt fke 0:i64[]
          fkg:i64[1] = add fke 1:i64[]
          fkh:i64[1] = select_n fkf fke fkg
          fki:i32[1] = convert_element_type[new_dtype=int32 weak_type=False] fkh
          fkj:i32[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fki
          fkk:f64[1,1] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fjb fkj
          fkl:i64[20] = device_put[
            copy_semantics=(<CopySemantics.ALIAS: 1>,)
            devices=(None,)
            srcs=(None,)
          ] bwt
          fkm:bool[20] = lt fkl 0:i64[]
          fkn:i64[20] = add fkl 1:i64[]
          fko:i64[20] = select_n fkm fkl fkn
          fkp:i32[20] = convert_element_type[new_dtype=int32 weak_type=False] fko
          fkq:i32[20,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(20, 1)
            sharding=None
          ] fkp
          fkr:f64[1,20] = gather[
            dimension_numbers=GatherDimensionNumbers(offset_dims=(0,), collapsed_slice_dims=(1,), start_index_map=(1,), operand_batching_dims=(), start_indices_batching_dims=())
            fill_value=None
            indices_are_sorted=False
            mode=GatherScatterMode.PROMISE_IN_BOUNDS
            slice_sizes=(1, 1)
            unique_indices=False
          ] fkk fkq
          fks:f64[1,20] = mul fjp fkd
          fkt:f64[1,20] = mul fks fkr
          fku:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=None
          ] cal
          fkv:f64[1] = squeeze[dimensions=(1,)] fku
          fkw:f64[1] = convert_element_type[new_dtype=float64 weak_type=False] bqe
          fkx:f64[1] = mul fkw fkv
          fky:f64[1] = div fkx 3.141592653589793:f64[]
          fkz:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] cdl bqf
          fla:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] cgl bqf
          flb:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] dmp bqk
          flc:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 0.0:f64[]
          fld:f64[1] = mul fkz flc
          fle:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fla
          flf:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fld
          flg:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] flb
          flh:f64[3,1] = concatenate[dimension=0] fle flf flg
          fli:f64[1,3] = transpose[permutation=(1, 0)] flh
          flj:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] coq bqf
          flk:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] duu bqk
          fll:f64[1] = mul fkz flc
          flm:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] flj
          fln:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fll
          flo:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] flk
          flp:f64[3,1] = concatenate[dimension=0] flm fln flo
          flq:f64[1,3] = transpose[permutation=(1, 0)] flp
          flr:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] cxq bqf
          fls:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] edu bqk
          flt:f64[1] = add 1.0:f64[] flc
          flu:f64[1] = mul fkz flt
          flv:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] flr
          flw:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] flu
          flx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fls
          fly:f64[3,1] = concatenate[dimension=0] flv flw flx
          flz:f64[1,3] = transpose[permutation=(1, 0)] fly
          fma:f64[1,3] = pjit[name=cross jaxpr=cross] flq flz
          fmb:f64[1,3] = mul fli fma
          fmc:f64[1] = reduce_sum[axes=(1,)] fmb
          fmd:f64[1] = abs fmc
          fme:bool[1] = le fmd 0.0:f64[]
          fmf:f64[1] = pjit[name=_where jaxpr=_where1] fme 0:i64[] fky
          fmg:f64[1] = pjit[name=_where jaxpr=_where1] fme 1:i64[] fmc
          fmh:f64[1] = div fmf fmg
          fmi:f64[1,3] = mul flq flq
          fmj:f64[1] = reduce_sum[axes=(1,)] fmi
          fmk:f64[1,3] = mul flq flz
          fml:f64[1] = reduce_sum[axes=(1,)] fmk
          fmm:f64[1] = add 1.0:f64[] flc
          fmn:f64[1] = mul fmm fmj
          fmo:f64[1] = mul flc fml
          fmp:f64[1] = sub fmn fmo
          fmq:f64[1] = abs fmc
          fmr:bool[1] = le fmq 0.0:f64[]
          fms:f64[1] = pjit[name=_where jaxpr=_where1] fmr 0:i64[] fmp
          fmt:f64[1] = pjit[name=_where jaxpr=_where1] fmr 1:i64[] fmc
          fmu:f64[1] = div fms fmt
          fmv:f64[1,2] = slice[
            limit_indices=(1, 3)
            start_indices=(0, 1)
            strides=None
          ] bzv
          fmw:f64[1] = reduce_prod[axes=(1,)] fmv
          fmx:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=None
          ] cal
          fmy:f64[1] = squeeze[dimensions=(1,)] fmx
          fmz:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fmy
          fna:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fmy
          fnb:f64[1,1] = sub fna fmz
          fnc:f64[1,1] = abs fnb
          fnd:bool[1,1] = le fnc 1e-14:f64[]
          fne:f64[1] = pjit[name=nan_to_num jaxpr=nan_to_num] fmu
          fnf:f64[1] = mul fmw fne
          fng:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] fnd fnf
          fnh:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] fbt bqc
          fni:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] est bqc
          fnj:f64[1] = mul fnh fmj
          fnk:f64[1] = add 1.0:f64[] fni
          fnl:f64[1] = mul fnk fml
          fnm:f64[1] = sub fnj fnl
          fnn:f64[1] = abs fmc
          fno:bool[1] = le fnn 0.0:f64[]
          fnp:f64[1] = pjit[name=_where jaxpr=_where1] fno 0:i64[] fnm
          fnq:f64[1] = pjit[name=_where jaxpr=_where1] fno 1:i64[] fmc
          fnr:f64[1] = div fnp fnq
          fns:f64[1,2] = slice[
            limit_indices=(1, 3)
            start_indices=(0, 1)
            strides=None
          ] bzv
          fnt:f64[1] = reduce_prod[axes=(1,)] fns
          fnu:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=None
          ] cal
          fnv:f64[1] = squeeze[dimensions=(1,)] fnu
          fnw:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fnv
          fnx:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fnv
          fny:f64[1,1] = sub fnx fnw
          fnz:f64[1,1] = abs fny
          foa:bool[1,1] = le fnz 1e-14:f64[]
          fob:f64[1] = pjit[name=nan_to_num jaxpr=nan_to_num] fnr
          foc:f64[1] = mul fnt fob
          fod:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] foa foc
          foe:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=None
          ] cal
          fof:f64[1] = squeeze[dimensions=(1,)] foe
          fog:f64[1] = pjit[name=interp1d jaxpr=interp1d] 0:i64[] True:bool[] bqq
            bpu fof
          foh:f64[1] = mul fog fng
          foi:f64[1] = sub foh fod
          foj:f64[1] = add foi fod
          fok:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=None
          ] cal
          fol:f64[1] = squeeze[dimensions=(1,)] fok
          fom:f64[1] = pjit[name=interp1d jaxpr=interp1d] 0:i64[] True:bool[] bqq
            bpu fol
          fon:f64[1] = add 1.0:f64[] flc
          foo:f64[1] = mul fom fon
          fop:f64[1] = sub foo fnh
          foq:f64[1] = mul fmh fop
          for:f64[1] = add 1.0:f64[] fni
          fos:f64[1] = neg fom
          fot:f64[1] = mul fos flc
          fou:f64[1] = add fot for
          fov:f64[1] = mul fmh fou
          fow:f64[3,1] = transpose[permutation=(1, 0)] flq
          fox:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] foq
          foy:f64[3,1] = mul fox fow
          foz:f64[3,1] = transpose[permutation=(1, 0)] flz
          fpa:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fov
          fpb:f64[3,1] = mul fpa foz
          fpc:f64[3,1] = add foy fpb
          fpd:f64[1,3] = transpose[permutation=(1, 0)] fpc
          fpe:f64[1,3] = mul fpd fpd
          fpf:f64[1] = reduce_sum[axes=(1,)] fpe
          fpg:f64[1] = sqrt fpf
          fph:f64[1,3] = mul fpd flq
          fpi:f64[1] = reduce_sum[axes=(1,)] fph
          fpj:f64[1,3] = mul fpd flz
          fpk:f64[1] = reduce_sum[axes=(1,)] fpj
          fpl:f64[1] = broadcast_in_dim[
            broadcast_dimensions=()
            shape=(1,)
            sharding=None
          ] 1.0:f64[]
          fpm:f64[1] = convert_element_type[new_dtype=float64 weak_type=False] bqe
          fpn:f64[1] = mul fpl fpm
          fpo:f64[1] = div fpn 3.141592653589793:f64[]
          fpp:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] clq bqf
          fpq:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] dru bqk
          fpr:f64[1] = neg fkz
          fps:f64[1] = integer_pow[y=2] flc
          fpt:f64[1] = mul fpr fps
          fpu:f64[1] = add fpt fpp
          fpv:f64[1] = mul 2.0:f64[] fla
          fpw:f64[1] = mul fpv flc
          fpx:f64[1] = mul fkz flc
          fpy:f64[1] = add fpw fpx
          fpz:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fpu
          fqa:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fpy
          fqb:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fpq
          fqc:f64[3,1] = concatenate[dimension=0] fpz fqa fqb
          fqd:f64[1,3] = transpose[permutation=(1, 0)] fqc
          fqe:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] crq bqf
          fqf:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] dxu bqk
          fqg:f64[1] = neg fkz
          fqh:f64[1] = mul fqg flc
          fqi:f64[1] = mul fqh flc
          fqj:f64[1] = add fqi fqe
          fqk:f64[1] = mul flc fla
          fql:f64[1] = mul flj flc
          fqm:f64[1] = add fqk fql
          fqn:f64[1] = mul fkz flc
          fqo:f64[1] = add fqm fqn
          fqp:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fqj
          fqq:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fqo
          fqr:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fqf
          fqs:f64[3,1] = concatenate[dimension=0] fqp fqq fqr
          fqt:f64[1,3] = transpose[permutation=(1, 0)] fqs
          fqu:f64[1,3] = copy fqt
          fqv:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] daq bqf
          fqw:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] egu bqk
          fqx:f64[1] = neg fkz
          fqy:f64[1] = add 1.0:f64[] flc
          fqz:f64[1] = mul fqx fqy
          fra:f64[1] = mul fqz flc
          frb:f64[1] = add fra fqv
          frc:f64[1] = add 1.0:f64[] flc
          frd:f64[1] = mul frc fla
          fre:f64[1] = mul flr flc
          frf:f64[1] = add frd fre
          frg:f64[1] = mul fkz flc
          frh:f64[1] = add frf frg
          fri:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] frb
          frj:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] frh
          frk:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fqw
          frl:f64[3,1] = concatenate[dimension=0] fri frj frk
          frm:f64[1,3] = transpose[permutation=(1, 0)] frl
          frn:f64[1,3] = copy frm
          fro:f64[1,3] = pjit[name=cross jaxpr=cross] flq flz
          frp:f64[1,3] = mul fqd fro
          frq:f64[1] = reduce_sum[axes=(1,)] frp
          frr:f64[1,3] = pjit[name=cross jaxpr=cross] fqu flz
          frs:f64[1,3] = mul fli frr
          frt:f64[1] = reduce_sum[axes=(1,)] frs
          fru:f64[1] = add frq frt
          frv:f64[1,3] = pjit[name=cross jaxpr=cross] flq frn
          frw:f64[1,3] = mul fli frv
          frx:f64[1] = reduce_sum[axes=(1,)] frw
          fry:f64[1] = add fru frx
          frz:f64[1] = mul fpo fmc
          fsa:f64[1] = mul fky fry
          fsb:f64[1] = sub frz fsa
          fsc:f64[1] = integer_pow[y=2] fmc
          fsd:f64[1] = abs fsc
          fse:bool[1] = le fsd 0.0:f64[]
          fsf:f64[1] = pjit[name=_where jaxpr=_where1] fse 0:i64[] fsb
          fsg:f64[1] = pjit[name=_where jaxpr=_where1] fse 1:i64[] fsc
          fsh:f64[1] = div fsf fsg
          fsi:f64[1,3] = mul flq fqu
          fsj:f64[1] = reduce_sum[axes=(1,)] fsi
          fsk:f64[1] = mul 2.0:f64[] fsj
          fsl:f64[1,3] = mul fqu flz
          fsm:f64[1] = reduce_sum[axes=(1,)] fsl
          fsn:f64[1,3] = mul flq frn
          fso:f64[1] = reduce_sum[axes=(1,)] fsn
          fsp:f64[1] = add fsm fso
          fsq:f64[1] = add 1.0:f64[] flc
          fsr:f64[1] = mul fsq fmj
          fss:f64[1] = mul flc fml
          fst:f64[1] = sub fsr fss
          fsu:f64[1] = abs fmc
          fsv:bool[1] = le fsu 0.0:f64[]
          fsw:f64[1] = pjit[name=_where jaxpr=_where1] fsv 0:i64[] fst
          fsx:f64[1] = pjit[name=_where jaxpr=_where1] fsv 1:i64[] fmc
          fsy:f64[1] = div fsw fsx
          fsz:f64[1] = mul flc fmj
          fta:f64[1] = add 1.0:f64[] flc
          ftb:f64[1] = mul fta fsk
          ftc:f64[1] = add fsz ftb
          ftd:f64[1] = mul flc fml
          fte:f64[1] = sub ftc ftd
          ftf:f64[1] = mul flc fsp
          ftg:f64[1] = sub fte ftf
          fth:f64[1] = mul fsy fry
          fti:f64[1] = sub ftg fth
          ftj:f64[1] = abs fmc
          ftk:bool[1] = le ftj 0.0:f64[]
          ftl:f64[1] = pjit[name=_where jaxpr=_where1] ftk 0:i64[] fti
          ftm:f64[1] = pjit[name=_where jaxpr=_where1] ftk 1:i64[] fmc
          ftn:f64[1] = div ftl ftm
          fto:f64[1,2] = slice[
            limit_indices=(1, 3)
            start_indices=(0, 1)
            strides=None
          ] bzv
          ftp:f64[1] = reduce_prod[axes=(1,)] fto
          ftq:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=None
          ] cal
          ftr:f64[1] = squeeze[dimensions=(1,)] ftq
          fts:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] ftr
          ftt:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] ftr
          ftu:f64[1,1] = sub ftt fts
          ftv:f64[1,1] = abs ftu
          ftw:bool[1,1] = le ftv 1e-14:f64[]
          ftx:f64[1] = pjit[name=nan_to_num jaxpr=nan_to_num] ftn
          fty:f64[1] = mul ftp ftx
          ftz:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] ftw fty
          fua:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] evt bqc
          fub:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] fet bqc
          fuc:f64[1] = mul fnh fmj
          fud:f64[1] = add 1.0:f64[] fni
          fue:f64[1] = mul fud fml
          fuf:f64[1] = sub fuc fue
          fug:f64[1] = abs fmc
          fuh:bool[1] = le fug 0.0:f64[]
          fui:f64[1] = pjit[name=_where jaxpr=_where1] fuh 0:i64[] fuf
          fuj:f64[1] = pjit[name=_where jaxpr=_where1] fuh 1:i64[] fmc
          fuk:f64[1] = div fui fuj
          ful:f64[1] = mul fub fmj
          fum:f64[1] = mul fnh fsk
          fun:f64[1] = add ful fum
          fuo:f64[1] = mul fua fml
          fup:f64[1] = sub fun fuo
          fuq:f64[1] = add 1.0:f64[] fni
          fur:f64[1] = mul fuq fsp
          fus:f64[1] = sub fup fur
          fut:f64[1] = mul fuk fry
          fuu:f64[1] = sub fus fut
          fuv:f64[1] = abs fmc
          fuw:bool[1] = le fuv 0.0:f64[]
          fux:f64[1] = pjit[name=_where jaxpr=_where1] fuw 0:i64[] fuu
          fuy:f64[1] = pjit[name=_where jaxpr=_where1] fuw 1:i64[] fmc
          fuz:f64[1] = div fux fuy
          fva:f64[1,2] = slice[
            limit_indices=(1, 3)
            start_indices=(0, 1)
            strides=None
          ] bzv
          fvb:f64[1] = reduce_prod[axes=(1,)] fva
          fvc:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=None
          ] cal
          fvd:f64[1] = squeeze[dimensions=(1,)] fvc
          fve:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(0,)
            shape=(1, 1)
            sharding=None
          ] fvd
          fvf:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fvd
          fvg:f64[1,1] = sub fvf fve
          fvh:f64[1,1] = abs fvg
          fvi:bool[1,1] = le fvh 1e-14:f64[]
          fvj:f64[1] = pjit[name=nan_to_num jaxpr=nan_to_num] fuz
          fvk:f64[1] = mul fvb fvj
          fvl:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] fvi fvk
          fvm:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=None
          ] cal
          fvn:f64[1] = squeeze[dimensions=(1,)] fvm
          fvo:f64[1] = pjit[name=interp1d jaxpr=interp1d] 1:i64[] True:bool[] bqq
            bpu fvn
          fvp:f64[1] = integer_pow[y=2] fng
          fvq:f64[1] = mul fvo fvp
          fvr:f64[1] = mul foj ftz
          fvs:f64[1] = add fvq fvr
          fvt:f64[1] = div fvs fng
          fvu:f64[1] = sub fvt fvl
          _:f64[1] = add fvu fvl
          fvv:f64[1,1] = slice[
            limit_indices=(1, 1)
            start_indices=(0, 0)
            strides=None
          ] cal
          fvw:f64[1] = squeeze[dimensions=(1,)] fvv
          fvx:f64[1] = pjit[name=interp1d jaxpr=interp1d] 1:i64[] True:bool[] bqq
            bpu fvw
          fvy:f64[1] = mul fom flc
          fvz:f64[1] = mul fvx fon
          fwa:f64[1] = add fvy fvz
          fwb:f64[1] = sub fwa fub
          fwc:f64[1] = mul fmh fwb
          fwd:f64[1] = mul fom fon
          fwe:f64[1] = sub fwd fnh
          fwf:f64[1] = mul fsh fwe
          fwg:f64[1] = add fwc fwf
          fwh:f64[1] = neg fom
          fwi:f64[1] = mul fwh flc
          fwj:f64[1] = mul fvx flc
          fwk:f64[1] = sub fwi fwj
          fwl:f64[1] = add fwk fua
          fwm:f64[1] = mul fmh fwl
          fwn:f64[1] = neg fom
          fwo:f64[1] = mul fwn flc
          fwp:f64[1] = add fwo for
          fwq:f64[1] = mul fsh fwp
          fwr:f64[1] = add fwm fwq
          fws:f64[3,1] = transpose[permutation=(1, 0)] flq
          fwt:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fwg
          fwu:f64[3,1] = mul fwt fws
          fwv:f64[3,1] = transpose[permutation=(1, 0)] fqu
          fww:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] foq
          fwx:f64[3,1] = mul fww fwv
          fwy:f64[3,1] = add fwu fwx
          fwz:f64[3,1] = transpose[permutation=(1, 0)] flz
          fxa:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fwr
          fxb:f64[3,1] = mul fxa fwz
          fxc:f64[3,1] = add fwy fxb
          fxd:f64[3,1] = transpose[permutation=(1, 0)] frn
          fxe:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fov
          fxf:f64[3,1] = mul fxe fxd
          fxg:f64[3,1] = add fxc fxf
          fxh:f64[1,3] = transpose[permutation=(1, 0)] fxg
          fxi:f64[1,3] = mul fxh flq
          fxj:f64[1] = reduce_sum[axes=(1,)] fxi
          fxk:f64[1,3] = mul fpd fqu
          fxl:f64[1] = reduce_sum[axes=(1,)] fxk
          fxm:f64[1] = add fxj fxl
          fxn:f64[1,3] = mul fxh flz
          fxo:f64[1] = reduce_sum[axes=(1,)] fxn
          fxp:f64[1,3] = mul fpd frn
          fxq:f64[1] = reduce_sum[axes=(1,)] fxp
          fxr:f64[1] = add fxo fxq
          fxs:f64[1] = mul fwg fpi
          fxt:f64[1] = mul foq fxm
          fxu:f64[1] = add fxs fxt
          fxv:f64[1] = mul fwr fpk
          fxw:f64[1] = add fxu fxv
          fxx:f64[1] = mul fov fxr
          fxy:f64[1] = add fxw fxx
          fxz:f64[1] = mul 2.0:f64[] fpg
          fya:f64[1] = div fxy fxz
          fyb:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] cuq bqf
          fyc:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] eau bqk
          fyd:f64[1] = neg fkz
          fye:f64[1] = integer_pow[y=2] flc
          fyf:f64[1] = mul fyd fye
          fyg:f64[1] = add fyf fyb
          fyh:f64[1] = mul 2.0:f64[] flj
          fyi:f64[1] = mul fyh flc
          fyj:f64[1] = mul fkz flc
          fyk:f64[1] = add fyi fyj
          fyl:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fyg
          fym:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fyk
          fyn:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fyc
          fyo:f64[3,1] = concatenate[dimension=0] fyl fym fyn
          fyp:f64[1,3] = transpose[permutation=(1, 0)] fyo
          fyq:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] ddq bqf
          fyr:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] eju bqk
          fys:f64[1] = neg fkz
          fyt:f64[1] = add 1.0:f64[] flc
          fyu:f64[1] = mul fys fyt
          fyv:f64[1] = mul fyu flc
          fyw:f64[1] = add fyv fyq
          fyx:f64[1] = add 1.0:f64[] flc
          fyy:f64[1] = mul fyx flj
          fyz:f64[1] = mul flr flc
          fza:f64[1] = add fyy fyz
          fzb:f64[1] = mul fkz flc
          fzc:f64[1] = add fza fzb
          fzd:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fyw
          fze:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fzc
          fzf:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fyr
          fzg:f64[3,1] = concatenate[dimension=0] fzd fze fzf
          fzh:f64[1,3] = transpose[permutation=(1, 0)] fzg
          fzi:f64[1,3] = copy fzh
          fzj:f64[1,3] = pjit[name=cross jaxpr=cross] flq flz
          fzk:f64[1,3] = mul fqt fzj
          fzl:f64[1] = reduce_sum[axes=(1,)] fzk
          fzm:f64[1,3] = pjit[name=cross jaxpr=cross] fyp flz
          fzn:f64[1,3] = mul fli fzm
          fzo:f64[1] = reduce_sum[axes=(1,)] fzn
          fzp:f64[1] = add fzl fzo
          fzq:f64[1,3] = pjit[name=cross jaxpr=cross] flq fzi
          fzr:f64[1,3] = mul fli fzq
          fzs:f64[1] = reduce_sum[axes=(1,)] fzr
          fzt:f64[1] = add fzp fzs
          fzu:f64[1] = neg fky
          fzv:f64[1] = mul fzu fzt
          fzw:f64[1] = integer_pow[y=2] fmc
          fzx:f64[1] = abs fzw
          fzy:bool[1] = le fzx 0.0:f64[]
          fzz:f64[1] = pjit[name=_where jaxpr=_where1] fzy 0:i64[] fzv
          gaa:f64[1] = pjit[name=_where jaxpr=_where1] fzy 1:i64[] fzw
          gab:f64[1] = div fzz gaa
          gac:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] fht bqc
          gad:f64[1] = mul fom flc
          gae:f64[1] = sub gad gac
          gaf:f64[1] = mul fmh gae
          gag:f64[1] = mul fom fon
          gah:f64[1] = sub gag fnh
          gai:f64[1] = mul gab gah
          gaj:f64[1] = add gaf gai
          gak:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] eyt bqc
          gal:f64[1] = neg fom
          gam:f64[1] = mul gal flc
          gan:f64[1] = add gam gak
          gao:f64[1] = mul fmh gan
          gap:f64[1] = neg fom
          gaq:f64[1] = mul gap flc
          gar:f64[1] = add gaq for
          gas:f64[1] = mul gab gar
          gat:f64[1] = add gao gas
          gau:f64[3,1] = transpose[permutation=(1, 0)] flq
          gav:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] gaj
          gaw:f64[3,1] = mul gav gau
          gax:f64[3,1] = transpose[permutation=(1, 0)] fyp
          gay:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] foq
          gaz:f64[3,1] = mul gay gax
          gba:f64[3,1] = add gaw gaz
          gbb:f64[3,1] = transpose[permutation=(1, 0)] flz
          gbc:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] gat
          gbd:f64[3,1] = mul gbc gbb
          gbe:f64[3,1] = add gba gbd
          gbf:f64[3,1] = transpose[permutation=(1, 0)] fzi
          gbg:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fov
          gbh:f64[3,1] = mul gbg gbf
          gbi:f64[3,1] = add gbe gbh
          gbj:f64[1,3] = transpose[permutation=(1, 0)] gbi
          gbk:f64[1,3] = mul gbj flq
          gbl:f64[1] = reduce_sum[axes=(1,)] gbk
          gbm:f64[1,3] = mul fpd fyp
          gbn:f64[1] = reduce_sum[axes=(1,)] gbm
          gbo:f64[1] = add gbl gbn
          gbp:f64[1,3] = mul gbj flz
          gbq:f64[1] = reduce_sum[axes=(1,)] gbp
          gbr:f64[1,3] = mul fpd fzi
          gbs:f64[1] = reduce_sum[axes=(1,)] gbr
          gbt:f64[1] = add gbq gbs
          gbu:f64[1] = mul gaj fpi
          gbv:f64[1] = mul foq gbo
          gbw:f64[1] = add gbu gbv
          gbx:f64[1] = mul gat fpk
          gby:f64[1] = add gbw gbx
          gbz:f64[1] = mul fov gbt
          gca:f64[1] = add gby gbz
          gcb:f64[1] = mul 2.0:f64[] fpg
          gcc:f64[1] = div gca gcb
          gcd:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] dgq bqf
          gce:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] emu bqk
          gcf:f64[1] = neg fkz
          gcg:f64[1] = add 1.0:f64[] flc
          gch:f64[1] = integer_pow[y=2] gcg
          gci:f64[1] = mul gcf gch
          gcj:f64[1] = add gci gcd
          gck:f64[1] = mul 2.0:f64[] flr
          gcl:f64[1] = add 1.0:f64[] flc
          gcm:f64[1] = mul gck gcl
          gcn:f64[1] = mul fkz flc
          gco:f64[1] = add gcm gcn
          gcp:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] gcj
          gcq:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] gco
          gcr:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] gce
          gcs:f64[3,1] = concatenate[dimension=0] gcp gcq gcr
          gct:f64[1,3] = transpose[permutation=(1, 0)] gcs
          gcu:f64[1,3] = pjit[name=cross jaxpr=cross] flq flz
          gcv:f64[1,3] = mul frm gcu
          gcw:f64[1] = reduce_sum[axes=(1,)] gcv
          gcx:f64[1,3] = pjit[name=cross jaxpr=cross] fzh flz
          gcy:f64[1,3] = mul fli gcx
          gcz:f64[1] = reduce_sum[axes=(1,)] gcy
          gda:f64[1] = add gcw gcz
          gdb:f64[1,3] = pjit[name=cross jaxpr=cross] flq gct
          gdc:f64[1,3] = mul fli gdb
          gdd:f64[1] = reduce_sum[axes=(1,)] gdc
          gde:f64[1] = add gda gdd
          gdf:f64[1] = neg fky
          gdg:f64[1] = mul gdf gde
          gdh:f64[1] = integer_pow[y=2] fmc
          gdi:f64[1] = abs gdh
          gdj:bool[1] = le gdi 0.0:f64[]
          gdk:f64[1] = pjit[name=_where jaxpr=_where1] gdj 0:i64[] gdg
          gdl:f64[1] = pjit[name=_where jaxpr=_where1] gdj 1:i64[] gdh
          gdm:f64[1] = div gdk gdl
          gdn:f64[1] = dot_general[
            dimension_numbers=(([1], [0]), ([], []))
            preferred_element_type=float64
          ] fkt bqc
          gdo:f64[1] = mul fom flc
          gdp:f64[1] = sub gdo gdn
          gdq:f64[1] = mul fmh gdp
          gdr:f64[1] = mul fom fon
          gds:f64[1] = sub gdr fnh
          gdt:f64[1] = mul gdm gds
          gdu:f64[1] = add gdq gdt
          gdv:f64[1] = neg fom
          gdw:f64[1] = mul gdv flc
          gdx:f64[1] = add gdw gac
          gdy:f64[1] = mul fmh gdx
          gdz:f64[1] = neg fom
          gea:f64[1] = mul gdz flc
          geb:f64[1] = add gea for
          gec:f64[1] = mul gdm geb
          ged:f64[1] = add gdy gec
          gee:f64[3,1] = transpose[permutation=(1, 0)] flq
          gef:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] gdu
          geg:f64[3,1] = mul gef gee
          geh:f64[3,1] = transpose[permutation=(1, 0)] fzh
          gei:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] foq
          gej:f64[3,1] = mul gei geh
          gek:f64[3,1] = add geg gej
          gel:f64[3,1] = transpose[permutation=(1, 0)] flz
          gem:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] ged
          gen:f64[3,1] = mul gem gel
          geo:f64[3,1] = add gek gen
          gep:f64[3,1] = transpose[permutation=(1, 0)] gct
          geq:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fov
          ger:f64[3,1] = mul geq gep
          ges:f64[3,1] = add geo ger
          get:f64[1,3] = transpose[permutation=(1, 0)] ges
          geu:f64[1,3] = mul get flq
          gev:f64[1] = reduce_sum[axes=(1,)] geu
          gew:f64[1,3] = mul fpd fzh
          gex:f64[1] = reduce_sum[axes=(1,)] gew
          gey:f64[1] = add gev gex
          gez:f64[1,3] = mul get flz
          gfa:f64[1] = reduce_sum[axes=(1,)] gez
          gfb:f64[1,3] = mul fpd gct
          gfc:f64[1] = reduce_sum[axes=(1,)] gfb
          gfd:f64[1] = add gfa gfc
          gfe:f64[1] = mul gdu fpi
          gff:f64[1] = mul foq gey
          gfg:f64[1] = add gfe gff
          gfh:f64[1] = mul ged fpk
          gfi:f64[1] = add gfg gfh
          gfj:f64[1] = mul fov gfd
          gfk:f64[1] = add gfi gfj
          gfl:f64[1] = mul 2.0:f64[] fpg
          gfm:f64[1] = div gfk gfl
          gfn:f64[3,1] = transpose[permutation=(1, 0)] flq
          gfo:f64[1] = abs fmc
          gfp:bool[1] = le gfo 0.0:f64[]
          gfq:f64[3,1] = pjit[
            name=_where
            jaxpr={ lambda ; gfp:bool[1] gfr:i64[] gfn:f64[3,1]. let
                gfs:f64[] = convert_element_type[
                  new_dtype=float64
                  weak_type=False
                ] gfr
                gft:bool[3,1] = broadcast_in_dim[
                  broadcast_dimensions=(1,)
                  shape=(3, 1)
                  sharding=None
                ] gfp
                gfu:f64[3,1] = broadcast_in_dim[
                  broadcast_dimensions=()
                  shape=(3, 1)
                  sharding=None
                ] gfs
                gfq:f64[3,1] = select_n gft gfn gfu
              in (gfq,) }
          ] gfp 0:i64[] gfn
          gfv:f64[1] = pjit[name=_where jaxpr=_where1] gfp 1:i64[] fmc
          gfw:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] gfv
          gfx:f64[3,1] = div gfq gfw
          gfy:f64[1,3] = transpose[permutation=(1, 0)] gfx
          gfz:f64[1,3] = pjit[name=cross jaxpr=cross] gfy flz
          gga:f64[1,3] = pjit[name=cross jaxpr=cross] flz fli
          ggb:f64[1,3] = pjit[name=cross jaxpr=cross] fli gfy
          ggc:f64[3,1] = transpose[permutation=(1, 0)] gfz
          ggd:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fya
          gge:f64[3,1] = mul ggd ggc
          ggf:f64[1] = abs fmc
          ggg:bool[1] = le ggf 0.0:f64[]
          ggh:f64[1] = pjit[name=_where jaxpr=_where1] ggg 0:i64[] gcc
          ggi:f64[1] = pjit[name=_where jaxpr=_where1] ggg 1:i64[] fmc
          ggj:f64[1] = div ggh ggi
          ggk:f64[3,1] = transpose[permutation=(1, 0)] gga
          ggl:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] ggj
          ggm:f64[3,1] = mul ggl ggk
          ggn:f64[3,1] = add gge ggm
          ggo:f64[3,1] = transpose[permutation=(1, 0)] ggb
          ggp:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] gfm
          ggq:f64[3,1] = mul ggp ggo
          ggr:f64[3,1] = add ggn ggq
          ggs:f64[1,3] = transpose[permutation=(1, 0)] ggr
          ggt:f64[3,1] = transpose[permutation=(1, 0)] gga
          ggu:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fmc
          ggv:f64[3,1] = div ggt ggu
          ggw:f64[1,3] = transpose[permutation=(1, 0)] ggv
          ggx:f64[3,1] = transpose[permutation=(1, 0)] fpd
          ggy:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] fpg
          ggz:f64[3,1] = div ggx ggy
          gha:f64[1,3] = transpose[permutation=(1, 0)] ggz
          ghb:f64[1,3] = mul bzf gha
          ghc:f64[] = div byt byv
          ghd:f64[1] = integer_pow[y=2] fpg
          ghe:f64[1] = div ghc ghd
          ghf:f64[1] = mul byx fpg
          ghg:f64[1] = div ghf byt
          ghh:f64[] = integer_pow[y=2] bzf
          ghi:f64[1] = add ghg ghh
          ghj:f64[1] = mul ghe ghi
          ghk:f64[1,3] = pjit[name=cross jaxpr=cross] gha ggs
          ghl:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] ghj
          ghm:f64[1,3] = mul ghl ghk
          ghn:f64[1,3] = add ghb ghm
          gho:f64[1,3] = mul ghn gfz
          ghp:f64[1] = reduce_sum[axes=(1,)] gho
          ghq:f64[1,3] = mul ghn ggw
          ghr:f64[1] = reduce_sum[axes=(1,)] ghq
          ghs:f64[1,3] = mul ghn ggb
          ght:f64[1] = reduce_sum[axes=(1,)] ghs
          ghu:f64[] = cos bzk
          ghv:f64[1] = mul ghp ghu
          ghw:f64[1] = mul bzm ghr
          ghx:f64[] = sin bzk
          ghy:f64[1] = mul ghw ghx
          ghz:f64[1] = sub ghv ghy
          gia:f64[] = sin bzk
          gib:f64[1] = mul ghp gia
          gic:f64[1] = mul bzm ghr
          gid:f64[] = cos bzk
          gie:f64[1] = mul gic gid
          gif:f64[1] = add gib gie
          gig:f64[] = neg byx
          gih:f64[] = div gig byt
          gii:f64[1,3] = mul gha ggs
          gij:f64[1] = reduce_sum[axes=(1,)] gii
          gik:f64[1] = mul gih gij
          gil:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] ghz
          gim:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] gif
          gin:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] ght
          gio:f64[1,1] = broadcast_in_dim[
            broadcast_dimensions=(1,)
            shape=(1, 1)
            sharding=None
          ] gik
          gip:f64[4,1] = concatenate[dimension=0] gil gim gin gio
          bqt:f64[4] = reshape[dimensions=None new_sizes=(4,) sharding=None] gip
        in (bqt,) }
    ] bpj bpk bpl bpm bpn bpo bpp bpq bpr bps bpt bpu bpv bpw bpx bpy bpz bqa bqb
      bqc bqd bqe bqf bqg bqh bqi bqj bqk bql bqm bqn bqo bqp bqq bqr bqs
  in (bqt,) }
